# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rubocop` gem.
# Please instead update this file by running `bin/tapioca gem rubocop`.

class Parser::Source::Comment
  include ::RuboCop::Ext::Comment
end

class Parser::Source::Range
  include ::RuboCop::Ext::Range
end

class Regexp::Expression::Base
  include ::RuboCop::Ext::RegexpParser::Expression::Base
end

class Regexp::Expression::CharacterSet < ::Regexp::Expression::Subexpression
  include ::RuboCop::Ext::RegexpParser::Expression::CharacterSet
end

# source://rubocop//lib/rubocop/version.rb#3
module RuboCop; end

class RuboCop::AST::ProcessedSource
  include ::RuboCop::Ext::ProcessedSource
end

class RuboCop::AST::RegexpNode < ::RuboCop::AST::Node
  include ::RuboCop::Ext::RegexpNode
end

# This is a class that reads optional command line arguments to rubocop from environment variable.
#
# @api private
#
# source://rubocop//lib/rubocop/arguments_env.rb#6
class RuboCop::ArgumentsEnv
  class << self
    # @api private
    #
    # source://rubocop//lib/rubocop/arguments_env.rb#7
    def read_as_arguments; end
  end
end

# This is a class that reads optional command line arguments to rubocop from .rubocop file.
#
# @api private
#
# source://rubocop//lib/rubocop/arguments_file.rb#6
class RuboCop::ArgumentsFile
  class << self
    # @api private
    #
    # source://rubocop//lib/rubocop/arguments_file.rb#7
    def read_as_arguments; end
  end
end

# The CLI is a class responsible of handling all the command line interface
# logic.
#
# source://rubocop//lib/rubocop/cli.rb#8
class RuboCop::CLI
  # @return [CLI] a new instance of CLI
  #
  # source://rubocop//lib/rubocop/cli.rb#24
  def initialize; end

  # Returns the value of attribute config_store.
  #
  # source://rubocop//lib/rubocop/cli.rb#22
  def config_store; end

  # Returns the value of attribute options.
  #
  # source://rubocop//lib/rubocop/cli.rb#22
  def options; end

  # Entry point for the application logic. Here we
  # do the command line arguments processing and inspect
  # the target files.
  #
  #
  # @api public
  # @param args [Array<String>] command line arguments
  # @return [Integer] UNIX exit code
  #
  # source://rubocop//lib/rubocop/cli.rb#39
  def run(args = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cli.rb#152
  def act_on_options; end

  # source://rubocop//lib/rubocop/cli.rb#186
  def apply_default_formatter; end

  # source://rubocop//lib/rubocop/cli.rb#121
  def execute_runners; end

  # @raise [Finished]
  #
  # source://rubocop//lib/rubocop/cli.rb#177
  def handle_exiting_options; end

  # source://rubocop//lib/rubocop/cli.rb#140
  def parallel_by_default!; end

  # source://rubocop//lib/rubocop/cli.rb#76
  def profile_if_needed; end

  # source://rubocop//lib/rubocop/cli.rb#109
  def require_gem(name); end

  # source://rubocop//lib/rubocop/cli.rb#117
  def run_command(name); end

  # source://rubocop//lib/rubocop/cli.rb#169
  def set_options_to_config_loader; end

  # source://rubocop//lib/rubocop/cli.rb#129
  def suggest_extensions; end

  # @raise [OptionArgumentError]
  #
  # source://rubocop//lib/rubocop/cli.rb#133
  def validate_options_vs_config; end
end

# Home of subcommands in the CLI.
#
# @api private
#
# source://rubocop//lib/rubocop/cli/command.rb#7
module RuboCop::CLI::Command
  class << self
    # Find the command with a given name and run it in an environment.
    #
    # @api private
    #
    # source://rubocop//lib/rubocop/cli/command.rb#10
    def run(env, name); end

    private

    # @api private
    #
    # source://rubocop//lib/rubocop/cli/command.rb#16
    def class_for(name); end
  end
end

# Generate a configuration file acting as a TODO list.
#
# @api private
#
# source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#8
class RuboCop::CLI::Command::AutoGenerateConfig < ::RuboCop::CLI::Command::Base
  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#21
  def run; end

  private

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#97
  def add_formatter; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#105
  def add_inheritance_from_auto_generated_file(config_file); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#101
  def execute_runner; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#126
  def existing_configuration(config_file); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#59
  def line_length_cop(config); end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#47
  def line_length_enabled?(config); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#55
  def max_line_length(config); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#30
  def maybe_run_line_length_cop; end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#148
  def options_config_in_root?; end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#63
  def options_has_only_flag?; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#139
  def relative_path_to_todo_from_options_config; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#90
  def reset_config_and_auto_gen_file; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#81
  def run_all_cops(line_length_contents); end

  # Do an initial run with only Layout/LineLength so that cops that
  # depend on Layout/LineLength:Max get the correct value for that
  # parameter.
  #
  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#70
  def run_line_length_cop; end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#51
  def same_max_line_length?(config1, config2); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#42
  def skip_line_length_cop(reason); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#132
  def write_config_file(file_name, file_string, rubocop_yml_contents); end
end

# @api private
#
# source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#11
RuboCop::CLI::Command::AutoGenerateConfig::AUTO_GENERATED_FILE = T.let(T.unsafe(nil), String)

# @api private
#
# source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#14
RuboCop::CLI::Command::AutoGenerateConfig::PHASE_1 = T.let(T.unsafe(nil), String)

# @api private
#
# source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#18
RuboCop::CLI::Command::AutoGenerateConfig::PHASE_1_DISABLED = T.let(T.unsafe(nil), String)

# @api private
#
# source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#17
RuboCop::CLI::Command::AutoGenerateConfig::PHASE_1_OVERRIDDEN = T.let(T.unsafe(nil), String)

# @api private
#
# source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#19
RuboCop::CLI::Command::AutoGenerateConfig::PHASE_1_SKIPPED = T.let(T.unsafe(nil), String)

# @api private
#
# source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#15
RuboCop::CLI::Command::AutoGenerateConfig::PHASE_2 = T.let(T.unsafe(nil), String)

# @api private
#
# source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#12
RuboCop::CLI::Command::AutoGenerateConfig::YAML_OPTIONAL_DOC_START = T.let(T.unsafe(nil), Regexp)

# A subcommand in the CLI.
#
# @api private
#
# source://rubocop//lib/rubocop/cli/command/base.rb#8
class RuboCop::CLI::Command::Base
  # @api private
  # @return [Base] a new instance of Base
  #
  # source://rubocop//lib/rubocop/cli/command/base.rb#26
  def initialize(env); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/base.rb#9
  def env; end

  class << self
    # @api private
    #
    # source://rubocop//lib/rubocop/cli/command/base.rb#21
    def by_command_name(name); end

    # @api private
    #
    # source://rubocop//lib/rubocop/cli/command/base.rb#14
    def command_name; end

    # @api private
    #
    # source://rubocop//lib/rubocop/cli/command/base.rb#14
    def command_name=(_arg0); end

    # @api private
    # @private
    #
    # source://rubocop//lib/rubocop/cli/command/base.rb#16
    def inherited(subclass); end
  end
end

# Run all the selected cops and report the result.
#
# @api private
#
# source://rubocop//lib/rubocop/cli/command/execute_runner.rb#8
class RuboCop::CLI::Command::ExecuteRunner < ::RuboCop::CLI::Command::Base
  include ::RuboCop::Formatter::TextUtil

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/execute_runner.rb#16
  def run; end

  private

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/execute_runner.rb#85
  def bug_tracker_uri; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/execute_runner.rb#69
  def display_error_summary(errors); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/execute_runner.rb#56
  def display_summary(runner); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/execute_runner.rb#61
  def display_warning_summary(warnings); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/execute_runner.rb#22
  def execute_runner(paths); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/execute_runner.rb#91
  def maybe_print_corrected_source; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/execute_runner.rb#42
  def with_redirect; end
end

# Combination of short and long formatter names.
#
# @api private
#
# source://rubocop//lib/rubocop/cli/command/execute_runner.rb#12
RuboCop::CLI::Command::ExecuteRunner::INTEGRATION_FORMATTERS = T.let(T.unsafe(nil), Array)

# Generate a .rubocop.yml file in the current directory.
#
# @api private
#
# source://rubocop//lib/rubocop/cli/command/init_dotfile.rb#8
class RuboCop::CLI::Command::InitDotfile < ::RuboCop::CLI::Command::Base
  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/init_dotfile.rb#13
  def run; end
end

# @api private
#
# source://rubocop//lib/rubocop/cli/command/init_dotfile.rb#9
RuboCop::CLI::Command::InitDotfile::DOTFILE = T.let(T.unsafe(nil), String)

# Shows the given cops, or all cops by default, and their configurations
# for the current directory.
#
# @api private
#
# source://rubocop//lib/rubocop/cli/command/show_cops.rb#9
class RuboCop::CLI::Command::ShowCops < ::RuboCop::CLI::Command::Base
  # @api private
  # @return [ShowCops] a new instance of ShowCops
  #
  # source://rubocop//lib/rubocop/cli/command/show_cops.rb#12
  def initialize(env); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/show_cops.rb#19
  def run; end

  private

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/show_cops.rb#67
  def config_lines(cop); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/show_cops.rb#63
  def cops_of_department(cops, department); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/show_cops.rb#25
  def print_available_cops; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/show_cops.rb#48
  def print_cop_details(cops); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/show_cops.rb#36
  def print_cops_of_department(registry, department, show_all); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/show_cops.rb#57
  def selected_cops_of_department(cops, department); end
end

# Prints out url to documentation of provided cops
# or documentation base url by default.
#
# @api private
#
# source://rubocop//lib/rubocop/cli/command/show_docs_url.rb#9
class RuboCop::CLI::Command::ShowDocsUrl < ::RuboCop::CLI::Command::Base
  # @api private
  # @return [ShowDocsUrl] a new instance of ShowDocsUrl
  #
  # source://rubocop//lib/rubocop/cli/command/show_docs_url.rb#12
  def initialize(env); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/show_docs_url.rb#18
  def run; end

  private

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/show_docs_url.rb#38
  def cops_array; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/show_docs_url.rb#24
  def print_documentation_url; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/show_docs_url.rb#42
  def registry_hash; end
end

# Suggest RuboCop extensions to install based on Gemfile dependencies.
# Only primary dependencies are evaluated, so if a dependency depends on a
# gem with an extension, it is not suggested. However, if an extension is
# a transitive dependency, it will not be suggested.
#
# @api private
#
# source://rubocop//lib/rubocop/cli/command/suggest_extensions.rb#11
class RuboCop::CLI::Command::SuggestExtensions < ::RuboCop::CLI::Command::Base
  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/suggest_extensions.rb#17
  def run; end

  private

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/suggest_extensions.rb#73
  def all_extensions; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/suggest_extensions.rb#69
  def current_formatter; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/suggest_extensions.rb#111
  def dependent_gems; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/suggest_extensions.rb#87
  def extensions; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/suggest_extensions.rb#103
  def installed_and_not_loaded_extensions; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/suggest_extensions.rb#91
  def installed_extensions; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/suggest_extensions.rb#115
  def installed_gems; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/suggest_extensions.rb#99
  def loaded_extensions; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/suggest_extensions.rb#107
  def lockfile; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/suggest_extensions.rb#95
  def not_installed_extensions; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/suggest_extensions.rb#41
  def print_install_suggestions; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/suggest_extensions.rb#51
  def print_load_suggestions; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/suggest_extensions.rb#60
  def print_opt_out_instruction; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/suggest_extensions.rb#119
  def puts(*args); end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cli/command/suggest_extensions.rb#30
  def skip?; end
end

# Combination of short and long formatter names.
#
# @api private
#
# source://rubocop//lib/rubocop/cli/command/suggest_extensions.rb#13
RuboCop::CLI::Command::SuggestExtensions::INCLUDED_FORMATTERS = T.let(T.unsafe(nil), Array)

# Display version.
#
# @api private
#
# source://rubocop//lib/rubocop/cli/command/version.rb#8
class RuboCop::CLI::Command::Version < ::RuboCop::CLI::Command::Base
  # @api private
  #
  # source://rubocop//lib/rubocop/cli/command/version.rb#11
  def run; end
end

# source://rubocop//lib/rubocop/cli.rb#13
RuboCop::CLI::DEFAULT_PARALLEL_OPTIONS = T.let(T.unsafe(nil), Array)

# Execution environment for a CLI command.
#
# @api private
#
# source://rubocop//lib/rubocop/cli/environment.rb#7
class RuboCop::CLI::Environment
  # @api private
  # @return [Environment] a new instance of Environment
  #
  # source://rubocop//lib/rubocop/cli/environment.rb#10
  def initialize(options, config_store, paths); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/environment.rb#8
  def config_store; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/environment.rb#8
  def options; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cli/environment.rb#8
  def paths; end

  # Run a command in this environment.
  #
  # @api private
  #
  # source://rubocop//lib/rubocop/cli/environment.rb#17
  def run(name); end
end

# source://rubocop//lib/rubocop/cli.rb#20
class RuboCop::CLI::Finished < ::StandardError; end

# source://rubocop//lib/rubocop/cli.rb#11
RuboCop::CLI::STATUS_ERROR = T.let(T.unsafe(nil), Integer)

# source://rubocop//lib/rubocop/cli.rb#12
RuboCop::CLI::STATUS_INTERRUPTED = T.let(T.unsafe(nil), Integer)

# source://rubocop//lib/rubocop/cli.rb#10
RuboCop::CLI::STATUS_OFFENSES = T.let(T.unsafe(nil), Integer)

# source://rubocop//lib/rubocop/cli.rb#9
RuboCop::CLI::STATUS_SUCCESS = T.let(T.unsafe(nil), Integer)

# This class represents the cache config of the caching RuboCop runs.
#
# @api private
#
# source://rubocop//lib/rubocop/cache_config.rb#6
class RuboCop::CacheConfig
  class << self
    # @api private
    #
    # source://rubocop//lib/rubocop/cache_config.rb#7
    def root_dir; end
  end
end

# Converts RuboCop objects to and from the serialization format JSON.
#
# @api private
#
# source://rubocop//lib/rubocop/cached_data.rb#8
class RuboCop::CachedData
  # @api private
  # @return [CachedData] a new instance of CachedData
  #
  # source://rubocop//lib/rubocop/cached_data.rb#9
  def initialize(filename); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cached_data.rb#13
  def from_json(text); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cached_data.rb#17
  def to_json(offenses); end

  private

  # Restore an offense object loaded from a JSON file.
  #
  # @api private
  #
  # source://rubocop//lib/rubocop/cached_data.rb#47
  def deserialize_offenses(offenses); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cached_data.rb#40
  def message(offense); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cached_data.rb#23
  def serialize_offense(offense); end
end

# and provides a way to check if each cop is enabled at arbitrary line.
#
# source://rubocop//lib/rubocop/comment_config.rb#6
class RuboCop::CommentConfig
  extend ::Forwardable

  # @return [CommentConfig] a new instance of CommentConfig
  #
  # source://rubocop//lib/rubocop/comment_config.rb#34
  def initialize(processed_source); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/comment_config.rb#63
  def comment_only_line?(line_number); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def config(*args, **_arg1, &block); end

  # source://rubocop//lib/rubocop/comment_config.rb#51
  def cop_disabled_line_ranges; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/comment_config.rb#39
  def cop_enabled_at_line?(cop, line_number); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/comment_config.rb#47
  def cop_opted_in?(cop); end

  # source://rubocop//lib/rubocop/comment_config.rb#55
  def extra_enabled_comments; end

  # Returns the value of attribute processed_source.
  #
  # source://rubocop//lib/rubocop/comment_config.rb#30
  def processed_source; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def registry(*args, **_arg1, &block); end

  private

  # source://rubocop//lib/rubocop/comment_config.rb#96
  def analyze; end

  # source://rubocop//lib/rubocop/comment_config.rb#124
  def analyze_cop(analysis, directive); end

  # source://rubocop//lib/rubocop/comment_config.rb#144
  def analyze_disabled(analysis, directive); end

  # source://rubocop//lib/rubocop/comment_config.rb#155
  def analyze_rest(analysis, directive); end

  # source://rubocop//lib/rubocop/comment_config.rb#135
  def analyze_single_line(analysis, directive); end

  # source://rubocop//lib/rubocop/comment_config.rb#164
  def cop_line_ranges(analysis); end

  # source://rubocop//lib/rubocop/comment_config.rb#170
  def each_directive; end

  # source://rubocop//lib/rubocop/comment_config.rb#69
  def extra_enabled_comments_with_names(extras:, names:); end

  # source://rubocop//lib/rubocop/comment_config.rb#190
  def handle_enable_all(directive, names, extras); end

  # Collect cops that have been disabled or enabled by name in a directive comment
  # so that `Lint/RedundantCopEnableDirective` can register offenses correctly.
  #
  # source://rubocop//lib/rubocop/comment_config.rb#204
  def handle_switch(directive, names, extras); end

  # source://rubocop//lib/rubocop/comment_config.rb#115
  def inject_disabled_cops_directives(analyses); end

  # source://rubocop//lib/rubocop/comment_config.rb#183
  def non_comment_token_line_numbers; end

  # source://rubocop//lib/rubocop/comment_config.rb#83
  def opt_in_cops; end

  # source://rubocop//lib/rubocop/comment_config.rb#179
  def qualified_cop_name(cop_name); end
end

# source://rubocop//lib/rubocop/comment_config.rb#9
RuboCop::CommentConfig::CONFIG_DISABLED_LINE_RANGE_MIN = T.let(T.unsafe(nil), Float)

# This class provides an API compatible with RuboCop::DirectiveComment
# to be used for cops that are disabled in the config file
#
# source://rubocop//lib/rubocop/comment_config.rb#13
class RuboCop::CommentConfig::ConfigDisabledCopDirectiveComment
  include ::RuboCop::Ext::Comment

  # @return [ConfigDisabledCopDirectiveComment] a new instance of ConfigDisabledCopDirectiveComment
  #
  # source://rubocop//lib/rubocop/comment_config.rb#21
  def initialize(cop_name); end

  # Returns the value of attribute line_number.
  #
  # source://rubocop//lib/rubocop/comment_config.rb#16
  def line_number; end

  # Returns the value of attribute loc.
  #
  # source://rubocop//lib/rubocop/comment_config.rb#16
  def loc; end

  # Returns the value of attribute text.
  #
  # source://rubocop//lib/rubocop/comment_config.rb#16
  def text; end
end

# source://rubocop//lib/rubocop/comment_config.rb#19
class RuboCop::CommentConfig::ConfigDisabledCopDirectiveComment::Expression < ::Struct
  # Returns the value of attribute line
  #
  # @return [Object] the current value of line
  def line; end

  # Sets the attribute line
  #
  # @param value [Object] the value to set the attribute line to.
  # @return [Object] the newly set value
  def line=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://rubocop//lib/rubocop/comment_config.rb#18
class RuboCop::CommentConfig::ConfigDisabledCopDirectiveComment::Loc < ::Struct
  # Returns the value of attribute expression
  #
  # @return [Object] the current value of expression
  def expression; end

  # Sets the attribute expression
  #
  # @param value [Object] the value to set the attribute expression to.
  # @return [Object] the newly set value
  def expression=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://rubocop//lib/rubocop/comment_config.rb#28
class RuboCop::CommentConfig::CopAnalysis < ::Struct
  # Returns the value of attribute line_ranges
  #
  # @return [Object] the current value of line_ranges
  def line_ranges; end

  # Sets the attribute line_ranges
  #
  # @param value [Object] the value to set the attribute line_ranges to.
  # @return [Object] the newly set value
  def line_ranges=(_); end

  # Returns the value of attribute start_line_number
  #
  # @return [Object] the current value of start_line_number
  def start_line_number; end

  # Sets the attribute start_line_number
  #
  # @param value [Object] the value to set the attribute start_line_number to.
  # @return [Object] the newly set value
  def start_line_number=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# This class represents the configuration of the RuboCop application
# and all its cops. A Config is associated with a YAML configuration
# file from which it was read. Several different Configs can be used
# during a run of the rubocop program, if files in several
# directories are inspected.
#
# source://rubocop//lib/rubocop/config.rb#14
class RuboCop::Config
  include ::RuboCop::PathUtil
  include ::RuboCop::FileFinder
  extend ::Forwardable

  # @return [Config] a new instance of Config
  #
  # source://rubocop//lib/rubocop/config.rb#32
  def initialize(hash = T.unsafe(nil), loaded_path = T.unsafe(nil)); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def [](*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def []=(*args, **_arg1, &block); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/config.rb#172
  def active_support_extensions_enabled?; end

  # source://rubocop//lib/rubocop/config.rb#98
  def add_excludes_from_higher_level(highest_config); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/config.rb#195
  def allowed_camel_case_file?(file); end

  # Paths specified in configuration files starting with .rubocop are
  # relative to the directory where that file is. Paths in other config files
  # are relative to the current directory. This is so that paths in
  # config/default.yml, for example, are not relative to RuboCop's config
  # directory since that wouldn't work.
  #
  # source://rubocop//lib/rubocop/config.rb#239
  def base_dir_for_path_parameters; end

  # source://rubocop//lib/rubocop/config.rb#264
  def bundler_lock_file_path; end

  # source://rubocop//lib/rubocop/config.rb#53
  def check; end

  # @api private
  # @return [Boolean] whether config for this badge has 'Include' or 'Exclude' keys
  #
  # source://rubocop//lib/rubocop/config.rb#144
  def clusivity_config_for_badge?(badge); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def delete(*args, **_arg1, &block); end

  # source://rubocop//lib/rubocop/config.rb#110
  def deprecation_check; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def dig(*args, **_arg1, &block); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/config.rb#164
  def disabled_new_cops?; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def each(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def each_key(*args, **_arg1, &block); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/config.rb#168
  def enabled_new_cops?; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def fetch(*args, **_arg1, &block); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/config.rb#217
  def file_to_exclude?(file); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/config.rb#176
  def file_to_include?(file); end

  # source://rubocop//lib/rubocop/config.rb#160
  def for_all_cops; end

  # Note: the 'Enabled' attribute is same as that returned by `for_cop`
  #
  # @return [Config] for the given cop merged with that of its department (if any)
  #
  # source://rubocop//lib/rubocop/config.rb#130
  def for_badge(badge); end

  # Note: the 'Enabled' attribute is calculated according to the department's
  # and 'AllCops' configuration; other attributes are not inherited.
  #
  # @return [Config] for the given cop / cop name.
  #
  # source://rubocop//lib/rubocop/config.rb#124
  def for_cop(cop); end

  # Note: the 'Enabled' attribute will be present only if specified
  # at the department's level
  #
  # @return [Config] for the given department name.
  #
  # source://rubocop//lib/rubocop/config.rb#155
  def for_department(department_name); end

  # True if this is a config file that is shipped with RuboCop
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/config.rb#78
  def internal?; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def key?(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def keys(*args, **_arg1, &block); end

  # source://rubocop//lib/rubocop/config.rb#49
  def loaded_features; end

  # Returns the value of attribute loaded_path.
  #
  # source://rubocop//lib/rubocop/config.rb#22
  def loaded_path; end

  # source://rubocop//lib/rubocop/config.rb#83
  def make_excludes_absolute; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def map(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def merge(*args, **_arg1, &block); end

  # source://rubocop//lib/rubocop/config.rb#230
  def path_relative_to_config(path); end

  # source://rubocop//lib/rubocop/config.rb#226
  def patterns_to_exclude; end

  # source://rubocop//lib/rubocop/config.rb#222
  def patterns_to_include; end

  # source://rubocop//lib/rubocop/config.rb#275
  def pending_cops; end

  # Returns true if there's a chance that an Include pattern matches hidden
  # files, false if that's definitely not possible.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/config.rb#209
  def possibly_include_hidden?; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def replace(*args, **_arg1, &block); end

  # source://rubocop//lib/rubocop/config.rb#73
  def signature; end

  # source://rubocop//lib/rubocop/config.rb#260
  def smart_loaded_path; end

  # source://rubocop//lib/rubocop/config.rb#249
  def target_rails_version; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def target_ruby_version(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def to_h(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def to_hash(*args, **_arg1, &block); end

  # source://rubocop//lib/rubocop/config.rb#69
  def to_s; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def transform_values(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def validate(*args, **_arg1, &block); end

  # source://rubocop//lib/rubocop/config.rb#60
  def validate_after_resolution; end

  private

  # source://rubocop//lib/rubocop/config.rb#318
  def department_of(qualified_cop_name); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/config.rb#306
  def enable_cop?(qualified_cop_name, cop_options); end

  # source://rubocop//lib/rubocop/config.rb#293
  def read_rails_version_from_bundler_lock_file; end

  # source://rubocop//lib/rubocop/config.rb#289
  def target_rails_version_from_bundler_lock_file; end

  class << self
    # source://rubocop//lib/rubocop/config.rb#24
    def create(hash, path, check: T.unsafe(nil)); end
  end
end

# source://rubocop//lib/rubocop/config.rb#19
class RuboCop::Config::CopConfig < ::Struct
  # Returns the value of attribute metadata
  #
  # @return [Object] the current value of metadata
  def metadata; end

  # Sets the attribute metadata
  #
  # @param value [Object] the value to set the attribute metadata to.
  # @return [Object] the newly set value
  def metadata=(_); end

  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  def name; end

  # Sets the attribute name
  #
  # @param value [Object] the value to set the attribute name to.
  # @return [Object] the newly set value
  def name=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://rubocop//lib/rubocop/config.rb#21
RuboCop::Config::DEFAULT_RAILS_VERSION = T.let(T.unsafe(nil), Float)

# This class has methods related to finding configuration path.
#
# @api private
#
# source://rubocop//lib/rubocop/config_finder.rb#8
class RuboCop::ConfigFinder
  extend ::RuboCop::FileFinder

  class << self
    # @api private
    #
    # source://rubocop//lib/rubocop/config_finder.rb#19
    def find_config_path(target_dir); end

    # Returns the path RuboCop inferred as the root of the project. No file
    # searches will go past this directory.
    #
    # @api private
    #
    # source://rubocop//lib/rubocop/config_finder.rb#26
    def project_root; end

    # @api private
    #
    # source://rubocop//lib/rubocop/config_finder.rb#17
    def project_root=(_arg0); end

    private

    # @api private
    #
    # source://rubocop//lib/rubocop/config_finder.rb#59
    def expand_path(path); end

    # @api private
    #
    # source://rubocop//lib/rubocop/config_finder.rb#40
    def find_project_dotfile(target_dir); end

    # @api private
    #
    # source://rubocop//lib/rubocop/config_finder.rb#32
    def find_project_root; end

    # @api private
    #
    # source://rubocop//lib/rubocop/config_finder.rb#44
    def find_user_dotfile; end

    # @api private
    #
    # source://rubocop//lib/rubocop/config_finder.rb#52
    def find_user_xdg_config; end
  end
end

# @api private
#
# source://rubocop//lib/rubocop/config_finder.rb#12
RuboCop::ConfigFinder::DEFAULT_FILE = T.let(T.unsafe(nil), String)

# @api private
#
# source://rubocop//lib/rubocop/config_finder.rb#9
RuboCop::ConfigFinder::DOTFILE = T.let(T.unsafe(nil), String)

# @api private
#
# source://rubocop//lib/rubocop/config_finder.rb#11
RuboCop::ConfigFinder::RUBOCOP_HOME = T.let(T.unsafe(nil), String)

# @api private
#
# source://rubocop//lib/rubocop/config_finder.rb#10
RuboCop::ConfigFinder::XDG_CONFIG = T.let(T.unsafe(nil), String)

# This class represents the configuration of the RuboCop application
# and all its cops. A Config is associated with a YAML configuration
# file from which it was read. Several different Configs can be used
# during a run of the rubocop program, if files in several
# directories are inspected.
#
# source://rubocop//lib/rubocop/config_loader.rb#18
class RuboCop::ConfigLoader
  extend ::RuboCop::FileFinder

  class << self
    # source://rubocop//lib/rubocop/config_loader.rb#130
    def add_excludes_from_files(config, config_file); end

    # Used to add features that were required inside a config or from
    # the CLI using `--require`.
    #
    # @api private
    #
    # source://rubocop//lib/rubocop/config_loader.rb#199
    def add_loaded_features(loaded_features); end

    # source://rubocop//lib/rubocop/config_loader.rb#73
    def add_missing_namespaces(path, hash); end

    # source://rubocop//lib/rubocop/config_loader.rb#34
    def clear_options; end

    # Returns the path of .rubocop.yml searching upwards in the
    # directory structure starting at the given directory where the
    # inspected file is. If no .rubocop.yml is found there, the
    # user's home directory is checked. If there's no .rubocop.yml
    # there either, the path to the default file is returned.
    #
    # source://rubocop//lib/rubocop/config_loader.rb#97
    def configuration_file_for(target_dir); end

    # source://rubocop//lib/rubocop/config_loader.rb#101
    def configuration_from_file(config_file, check: T.unsafe(nil)); end

    # Returns the value of attribute debug.
    #
    # source://rubocop//lib/rubocop/config_loader.rb#26
    def debug; end

    # Sets the attribute debug
    #
    # @param value the value to set the attribute debug to.
    #
    # source://rubocop//lib/rubocop/config_loader.rb#26
    def debug=(_arg0); end

    # Returns the value of attribute debug.
    #
    # source://rubocop//lib/rubocop/config_loader.rb#26
    def debug?; end

    # source://rubocop//lib/rubocop/config_loader.rb#140
    def default_configuration; end

    # Sets the attribute default_configuration
    #
    # @param value the value to set the attribute default_configuration to.
    #
    # source://rubocop//lib/rubocop/config_loader.rb#28
    def default_configuration=(_arg0); end

    # Returns the value of attribute disable_pending_cops.
    #
    # source://rubocop//lib/rubocop/config_loader.rb#26
    def disable_pending_cops; end

    # Sets the attribute disable_pending_cops
    #
    # @param value the value to set the attribute disable_pending_cops to.
    #
    # source://rubocop//lib/rubocop/config_loader.rb#26
    def disable_pending_cops=(_arg0); end

    # Returns the value of attribute enable_pending_cops.
    #
    # source://rubocop//lib/rubocop/config_loader.rb#26
    def enable_pending_cops; end

    # Sets the attribute enable_pending_cops
    #
    # @param value the value to set the attribute enable_pending_cops to.
    #
    # source://rubocop//lib/rubocop/config_loader.rb#26
    def enable_pending_cops=(_arg0); end

    # Returns the value of attribute ignore_parent_exclusion.
    #
    # source://rubocop//lib/rubocop/config_loader.rb#26
    def ignore_parent_exclusion; end

    # Sets the attribute ignore_parent_exclusion
    #
    # @param value the value to set the attribute ignore_parent_exclusion to.
    #
    # source://rubocop//lib/rubocop/config_loader.rb#26
    def ignore_parent_exclusion=(_arg0); end

    # Returns the value of attribute ignore_parent_exclusion.
    #
    # source://rubocop//lib/rubocop/config_loader.rb#26
    def ignore_parent_exclusion?; end

    # Returns the value of attribute ignore_unrecognized_cops.
    #
    # source://rubocop//lib/rubocop/config_loader.rb#26
    def ignore_unrecognized_cops; end

    # Sets the attribute ignore_unrecognized_cops
    #
    # @param value the value to set the attribute ignore_unrecognized_cops to.
    #
    # source://rubocop//lib/rubocop/config_loader.rb#26
    def ignore_unrecognized_cops=(_arg0); end

    # @api private
    #
    # source://rubocop//lib/rubocop/config_loader.rb#148
    def inject_defaults!(project_root); end

    # source://rubocop//lib/rubocop/config_loader.rb#40
    def load_file(file, check: T.unsafe(nil)); end

    # @raise [TypeError]
    #
    # source://rubocop//lib/rubocop/config_loader.rb#60
    def load_yaml_configuration(absolute_path); end

    # Returns the value of attribute loaded_features.
    #
    # source://rubocop//lib/rubocop/config_loader.rb#29
    def loaded_features; end

    # Return a recursive merge of two hashes. That is, a normal hash merge,
    # with the addition that any value that is a hash, and occurs in both
    # arguments, will also be merged. And so on.
    #
    # source://rubocop//lib/rubocop/config_loader.rb#88
    def merge(base_hash, derived_hash); end

    # Merges the given configuration with the default one.
    #
    # source://rubocop//lib/rubocop/config_loader.rb#192
    def merge_with_default(config, config_file, unset_nil: T.unsafe(nil)); end

    # source://rubocop//lib/rubocop/config_loader.rb#121
    def pending_cops_only_qualified(pending_cops); end

    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/config_loader.rb#125
    def possible_new_cops?(config); end

    # Returns the path RuboCop inferred as the root of the project. No file
    # searches will go past this directory.
    #
    # @deprecated Use `RuboCop::ConfigFinder.project_root` instead.
    #
    # source://rubocop//lib/rubocop/config_loader.rb#159
    def project_root; end

    # source://rubocop//lib/rubocop/config_loader.rb#176
    def warn_on_pending_cops(pending_cops); end

    # source://rubocop//lib/rubocop/config_loader.rb#184
    def warn_pending_cop(cop); end

    private

    # source://rubocop//lib/rubocop/config_loader.rb#213
    def check_duplication(yaml_code, absolute_path); end

    # source://rubocop//lib/rubocop/config_loader.rb#205
    def file_path(file); end

    # Read the specified file, or exit with a friendly, concise message on
    # stderr. Care is taken to use the standard OS exit code for a "file not
    # found" error.
    #
    # source://rubocop//lib/rubocop/config_loader.rb#233
    def read_file(absolute_path); end

    # source://rubocop//lib/rubocop/config_loader.rb#209
    def resolver; end

    # source://rubocop//lib/rubocop/config_loader.rb#239
    def yaml_safe_load(yaml_code, filename); end

    # source://rubocop//lib/rubocop/config_loader.rb#249
    def yaml_safe_load!(yaml_code, filename); end
  end
end

# source://rubocop//lib/rubocop/config_loader.rb#21
RuboCop::ConfigLoader::DEFAULT_FILE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/config_loader.rb#19
RuboCop::ConfigLoader::DOTFILE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/config_loader.rb#20
RuboCop::ConfigLoader::RUBOCOP_HOME = T.let(T.unsafe(nil), String)

# A help class for ConfigLoader that handles configuration resolution.
#
# @api private
#
# source://rubocop//lib/rubocop/config_loader_resolver.rb#9
class RuboCop::ConfigLoaderResolver
  # When one .rubocop.yml file inherits from another .rubocop.yml file, the Include paths in the
  # base configuration are relative to the directory where the base configuration file is. For the
  # derived configuration, we need to make those paths relative to where the derived configuration
  # file is.
  #
  # @api private
  #
  # source://rubocop//lib/rubocop/config_loader_resolver.rb#45
  def fix_include_paths(base_config_path, hash, key, value); end

  # Return a recursive merge of two hashes. That is, a normal hash merge,
  # with the addition that any value that is a hash, and occurs in both
  # arguments, will also be merged. And so on.
  #
  #
  # @api private
  #
  # source://rubocop//lib/rubocop/config_loader_resolver.rb#98
  def merge(base_hash, derived_hash, **opts); end

  # Merges the given configuration with the default one. If
  # AllCops:DisabledByDefault is true, it changes the Enabled params so that
  # only cops from user configuration are enabled. If
  # AllCops:EnabledByDefault is true, it changes the Enabled params so that
  # only cops explicitly disabled in user configuration are disabled.
  #
  # @api private
  #
  # source://rubocop//lib/rubocop/config_loader_resolver.rb#74
  def merge_with_default(config, config_file, unset_nil:); end

  # An `Enabled: true` setting in user configuration for a cop overrides an
  # `Enabled: false` setting for its department.
  #
  # @api private
  #
  # source://rubocop//lib/rubocop/config_loader_resolver.rb#118
  def override_department_setting_for_cops(base_hash, derived_hash); end

  # If a cop was previously explicitly enabled, but then superseded by the
  # department being disabled, disable it.
  #
  # @api private
  #
  # source://rubocop//lib/rubocop/config_loader_resolver.rb#135
  def override_enabled_for_disabled_departments(base_hash, derived_hash); end

  # @api private
  #
  # source://rubocop//lib/rubocop/config_loader_resolver.rb#19
  def resolve_inheritance(path, hash, file, debug); end

  # @api private
  #
  # source://rubocop//lib/rubocop/config_loader_resolver.rb#54
  def resolve_inheritance_from_gems(hash); end

  # @api private
  #
  # source://rubocop//lib/rubocop/config_loader_resolver.rb#10
  def resolve_requires(path, hash); end

  private

  # @api private
  #
  # source://rubocop//lib/rubocop/config_loader_resolver.rb#207
  def base_configs(path, inherit_from, file); end

  # @api private
  #
  # source://rubocop//lib/rubocop/config_loader_resolver.rb#175
  def determine_inherit_mode(hash, key); end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/config_loader_resolver.rb#151
  def disabled?(hash, department); end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/config_loader_resolver.rb#155
  def duplicate_setting?(base_hash, derived_hash, key, inherited_file); end

  # @api private
  #
  # source://rubocop//lib/rubocop/config_loader_resolver.rb#267
  def gem_config_path(gem_name, relative_config_path); end

  # @api private
  #
  # source://rubocop//lib/rubocop/config_loader_resolver.rb#245
  def handle_disabled_by_default(config, new_default_configuration); end

  # @api private
  #
  # source://rubocop//lib/rubocop/config_loader_resolver.rb#219
  def inherited_file(path, inherit_from, file); end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/config_loader_resolver.rb#203
  def merge_hashes?(base_hash, derived_hash, key); end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/config_loader_resolver.rb#240
  def remote_file?(uri); end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/config_loader_resolver.rb#195
  def should_merge?(mode, key); end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/config_loader_resolver.rb#199
  def should_override?(mode, key); end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/config_loader_resolver.rb#181
  def should_union?(derived_hash, base_hash, root_mode, key); end

  # @api private
  #
  # source://rubocop//lib/rubocop/config_loader_resolver.rb#263
  def transform(config, &block); end

  # @api private
  #
  # source://rubocop//lib/rubocop/config_loader_resolver.rb#164
  def warn_on_duplicate_setting(base_hash, derived_hash, key, **opts); end
end

# Raised when a RuboCop configuration file is not found.
#
# source://rubocop//lib/rubocop/config_loader.rb#10
class RuboCop::ConfigNotFoundError < ::RuboCop::Error; end

# This class handles obsolete configuration.
#
# @api private
#
# source://rubocop//lib/rubocop/config_obsoletion/rule.rb#4
class RuboCop::ConfigObsoletion
  # @api private
  # @return [ConfigObsoletion] a new instance of ConfigObsoletion
  #
  # source://rubocop//lib/rubocop/config_obsoletion.rb#33
  def initialize(config); end

  # @api private
  # @raise [ValidationError]
  #
  # source://rubocop//lib/rubocop/config_obsoletion.rb#39
  def reject_obsolete!; end

  # @api private
  #
  # source://rubocop//lib/rubocop/config_obsoletion.rb#19
  def rules; end

  # @api private
  #
  # source://rubocop//lib/rubocop/config_obsoletion.rb#19
  def warnings; end

  private

  # Cop rules are keyed by the name of the original cop
  #
  # @api private
  #
  # source://rubocop//lib/rubocop/config_obsoletion.rb#69
  def load_cop_rules(rules); end

  # Parameter rules may apply to multiple cops and multiple parameters
  # and are given as an array. Each combination is turned into a separate
  # rule object.
  #
  # @api private
  #
  # source://rubocop//lib/rubocop/config_obsoletion.rb#82
  def load_parameter_rules(rules); end

  # Default rules for obsoletions are in config/obsoletion.yml
  # Additional rules files can be added with `RuboCop::ConfigObsoletion.files << filename`
  #
  # @api private
  #
  # source://rubocop//lib/rubocop/config_obsoletion.rb#50
  def load_rules; end

  # @api private
  #
  # source://rubocop//lib/rubocop/config_obsoletion.rb#95
  def obsoletions; end

  class << self
    # @api private
    #
    # source://rubocop//lib/rubocop/config_obsoletion.rb#22
    def files; end

    # @api private
    #
    # source://rubocop//lib/rubocop/config_obsoletion.rb#22
    def files=(_arg0); end

    # @api private
    #
    # source://rubocop//lib/rubocop/config_obsoletion.rb#24
    def legacy_cop_names; end
  end
end

# @api private
#
# source://rubocop//lib/rubocop/config_obsoletion.rb#8
RuboCop::ConfigObsoletion::COP_RULE_CLASSES = T.let(T.unsafe(nil), Hash)

# Encapsulation of a ConfigObsoletion rule for changing a parameter
#
# @api private
#
# source://rubocop//lib/rubocop/config_obsoletion/changed_enforced_styles.rb#7
class RuboCop::ConfigObsoletion::ChangedEnforcedStyles < ::RuboCop::ConfigObsoletion::ParameterRule
  # @api private
  #
  # source://rubocop//lib/rubocop/config_obsoletion/changed_enforced_styles.rb#14
  def message; end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/config_obsoletion/changed_enforced_styles.rb#10
  def violated?; end

  private

  # @api private
  #
  # source://rubocop//lib/rubocop/config_obsoletion/changed_enforced_styles.rb#28
  def value; end
end

# @api private
#
# source://rubocop//lib/rubocop/config_obsoletion/changed_enforced_styles.rb#8
RuboCop::ConfigObsoletion::ChangedEnforcedStyles::BASE_MESSAGE = T.let(T.unsafe(nil), String)

# Encapsulation of a ConfigObsoletion rule for changing a parameter
#
# @api private
#
# source://rubocop//lib/rubocop/config_obsoletion/changed_parameter.rb#7
class RuboCop::ConfigObsoletion::ChangedParameter < ::RuboCop::ConfigObsoletion::ParameterRule
  # @api private
  #
  # source://rubocop//lib/rubocop/config_obsoletion/changed_parameter.rb#10
  def message; end
end

# @api private
#
# source://rubocop//lib/rubocop/config_obsoletion/changed_parameter.rb#8
RuboCop::ConfigObsoletion::ChangedParameter::BASE_MESSAGE = T.let(T.unsafe(nil), String)

# Base class for ConfigObsoletion rules relating to cops
#
# @api private
#
# source://rubocop//lib/rubocop/config_obsoletion/cop_rule.rb#7
class RuboCop::ConfigObsoletion::CopRule < ::RuboCop::ConfigObsoletion::Rule
  # @api private
  # @return [CopRule] a new instance of CopRule
  #
  # source://rubocop//lib/rubocop/config_obsoletion/cop_rule.rb#10
  def initialize(config, old_name); end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/config_obsoletion/cop_rule.rb#15
  def cop_rule?; end

  # @api private
  #
  # source://rubocop//lib/rubocop/config_obsoletion/cop_rule.rb#19
  def message; end

  # @api private
  #
  # source://rubocop//lib/rubocop/config_obsoletion/cop_rule.rb#8
  def old_name; end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/config_obsoletion/cop_rule.rb#28
  def violated?; end

  # Cop rules currently can only be failures, not warnings
  #
  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/config_obsoletion/cop_rule.rb#24
  def warning?; end
end

# @api private
#
# source://rubocop//lib/rubocop/config_obsoletion.rb#7
RuboCop::ConfigObsoletion::DEFAULT_RULES_FILE = T.let(T.unsafe(nil), String)

# Encapsulation of a ConfigObsoletion rule for splitting a cop's
# functionality into multiple new cops.
#
# @api private
#
# source://rubocop//lib/rubocop/config_obsoletion/extracted_cop.rb#8
class RuboCop::ConfigObsoletion::ExtractedCop < ::RuboCop::ConfigObsoletion::CopRule
  # @api private
  # @return [ExtractedCop] a new instance of ExtractedCop
  #
  # source://rubocop//lib/rubocop/config_obsoletion/extracted_cop.rb#11
  def initialize(config, old_name, gem); end

  # @api private
  #
  # source://rubocop//lib/rubocop/config_obsoletion/extracted_cop.rb#9
  def department; end

  # @api private
  #
  # source://rubocop//lib/rubocop/config_obsoletion/extracted_cop.rb#9
  def gem; end

  # @api private
  #
  # source://rubocop//lib/rubocop/config_obsoletion/extracted_cop.rb#23
  def rule_message; end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/config_obsoletion/extracted_cop.rb#17
  def violated?; end

  private

  # @api private
  #
  # source://rubocop//lib/rubocop/config_obsoletion/extracted_cop.rb#32
  def affected_cops; end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/config_obsoletion/extracted_cop.rb#41
  def feature_loaded?; end
end

# @api private
#
# source://rubocop//lib/rubocop/config_obsoletion.rb#14
RuboCop::ConfigObsoletion::PARAMETER_RULE_CLASSES = T.let(T.unsafe(nil), Hash)

# Base class for ConfigObsoletion rules relating to parameters
#
# @api private
#
# source://rubocop//lib/rubocop/config_obsoletion/parameter_rule.rb#7
class RuboCop::ConfigObsoletion::ParameterRule < ::RuboCop::ConfigObsoletion::Rule
  # @api private
  # @return [ParameterRule] a new instance of ParameterRule
  #
  # source://rubocop//lib/rubocop/config_obsoletion/parameter_rule.rb#10
  def initialize(config, cop, parameter, metadata); end

  # @api private
  #
  # source://rubocop//lib/rubocop/config_obsoletion/parameter_rule.rb#8
  def cop; end

  # @api private
  #
  # source://rubocop//lib/rubocop/config_obsoletion/parameter_rule.rb#8
  def metadata; end

  # @api private
  #
  # source://rubocop//lib/rubocop/config_obsoletion/parameter_rule.rb#8
  def parameter; end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/config_obsoletion/parameter_rule.rb#17
  def parameter_rule?; end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/config_obsoletion/parameter_rule.rb#21
  def violated?; end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/config_obsoletion/parameter_rule.rb#25
  def warning?; end

  private

  # @api private
  #
  # source://rubocop//lib/rubocop/config_obsoletion/parameter_rule.rb#31
  def alternative; end

  # @api private
  #
  # source://rubocop//lib/rubocop/config_obsoletion/parameter_rule.rb#35
  def alternatives; end

  # @api private
  #
  # source://rubocop//lib/rubocop/config_obsoletion/parameter_rule.rb#39
  def reason; end

  # @api private
  #
  # source://rubocop//lib/rubocop/config_obsoletion/parameter_rule.rb#43
  def severity; end
end

# Encapsulation of a ConfigObsoletion rule for removing
# a previously defined cop.
#
# @api private
#
# source://rubocop//lib/rubocop/config_obsoletion/removed_cop.rb#8
class RuboCop::ConfigObsoletion::RemovedCop < ::RuboCop::ConfigObsoletion::CopRule
  # @api private
  # @return [RemovedCop] a new instance of RemovedCop
  #
  # source://rubocop//lib/rubocop/config_obsoletion/removed_cop.rb#13
  def initialize(config, old_name, metadata); end

  # @api private
  #
  # source://rubocop//lib/rubocop/config_obsoletion/removed_cop.rb#9
  def metadata; end

  # @api private
  #
  # source://rubocop//lib/rubocop/config_obsoletion/removed_cop.rb#9
  def old_name; end

  # @api private
  #
  # source://rubocop//lib/rubocop/config_obsoletion/removed_cop.rb#18
  def rule_message; end

  private

  # @api private
  #
  # source://rubocop//lib/rubocop/config_obsoletion/removed_cop.rb#36
  def alternatives; end

  # @api private
  #
  # source://rubocop//lib/rubocop/config_obsoletion/removed_cop.rb#32
  def reason; end
end

# @api private
#
# source://rubocop//lib/rubocop/config_obsoletion/removed_cop.rb#11
RuboCop::ConfigObsoletion::RemovedCop::BASE_MESSAGE = T.let(T.unsafe(nil), String)

# Encapsulation of a ConfigObsoletion rule for renaming
# a cop or moving it to a new department.
#
# @api private
#
# source://rubocop//lib/rubocop/config_obsoletion/renamed_cop.rb#8
class RuboCop::ConfigObsoletion::RenamedCop < ::RuboCop::ConfigObsoletion::CopRule
  # @api private
  # @return [RenamedCop] a new instance of RenamedCop
  #
  # source://rubocop//lib/rubocop/config_obsoletion/renamed_cop.rb#11
  def initialize(config, old_name, new_name); end

  # @api private
  #
  # source://rubocop//lib/rubocop/config_obsoletion/renamed_cop.rb#9
  def new_name; end

  # @api private
  #
  # source://rubocop//lib/rubocop/config_obsoletion/renamed_cop.rb#16
  def rule_message; end

  private

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/config_obsoletion/renamed_cop.rb#22
  def moved?; end

  # @api private
  #
  # source://rubocop//lib/rubocop/config_obsoletion/renamed_cop.rb#29
  def verb; end
end

# Abstract base class for ConfigObsoletion rules
#
# @api private
#
# source://rubocop//lib/rubocop/config_obsoletion/rule.rb#7
class RuboCop::ConfigObsoletion::Rule
  # @api private
  # @return [Rule] a new instance of Rule
  #
  # source://rubocop//lib/rubocop/config_obsoletion/rule.rb#8
  def initialize(config); end

  # Does this rule relate to cops?
  #
  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/config_obsoletion/rule.rb#13
  def cop_rule?; end

  # Does this rule relate to parameters?
  #
  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/config_obsoletion/rule.rb#18
  def parameter_rule?; end

  # @api private
  # @raise [NotImplementedError]
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/config_obsoletion/rule.rb#22
  def violated?; end

  private

  # @api private
  #
  # source://rubocop//lib/rubocop/config_obsoletion/rule.rb#28
  def config; end

  # @api private
  #
  # source://rubocop//lib/rubocop/config_obsoletion/rule.rb#36
  def smart_loaded_path; end

  # @api private
  #
  # source://rubocop//lib/rubocop/config_obsoletion/rule.rb#30
  def to_sentence(collection, connector: T.unsafe(nil)); end
end

# Encapsulation of a ConfigObsoletion rule for splitting a cop's
# functionality into multiple new cops.
#
# @api private
#
# source://rubocop//lib/rubocop/config_obsoletion/split_cop.rb#8
class RuboCop::ConfigObsoletion::SplitCop < ::RuboCop::ConfigObsoletion::CopRule
  # @api private
  # @return [SplitCop] a new instance of SplitCop
  #
  # source://rubocop//lib/rubocop/config_obsoletion/split_cop.rb#11
  def initialize(config, old_name, metadata); end

  # @api private
  #
  # source://rubocop//lib/rubocop/config_obsoletion/split_cop.rb#9
  def metadata; end

  # @api private
  #
  # source://rubocop//lib/rubocop/config_obsoletion/split_cop.rb#16
  def rule_message; end

  private

  # @api private
  #
  # source://rubocop//lib/rubocop/config_obsoletion/split_cop.rb#22
  def alternatives; end
end

# This class handles collecting the options for regenerating a TODO file.
#
# @api private
#
# source://rubocop//lib/rubocop/config_regeneration.rb#6
class RuboCop::ConfigRegeneration
  # Get options from the comment in the TODO file, and parse them as options
  #
  # @api private
  #
  # source://rubocop//lib/rubocop/config_regeneration.rb#12
  def options; end

  private

  # @api private
  #
  # source://rubocop//lib/rubocop/config_regeneration.rb#29
  def generation_command; end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/config_regeneration.rb#25
  def todo_exists?; end
end

# @api private
#
# source://rubocop//lib/rubocop/config_regeneration.rb#7
RuboCop::ConfigRegeneration::AUTO_GENERATED_FILE = T.let(T.unsafe(nil), String)

# @api private
#
# source://rubocop//lib/rubocop/config_regeneration.rb#8
RuboCop::ConfigRegeneration::COMMAND_REGEX = T.let(T.unsafe(nil), Regexp)

# @api private
#
# source://rubocop//lib/rubocop/config_regeneration.rb#9
RuboCop::ConfigRegeneration::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

# Handles caching of configurations and association of inspected
# ruby files to configurations.
#
# source://rubocop//lib/rubocop/config_store.rb#6
class RuboCop::ConfigStore
  # @return [ConfigStore] a new instance of ConfigStore
  #
  # source://rubocop//lib/rubocop/config_store.rb#10
  def initialize; end

  # If type (file/dir) is known beforehand,
  # prefer using #for_file or #for_dir for improved performance
  #
  # source://rubocop//lib/rubocop/config_store.rb#52
  def for(file_or_dir); end

  # source://rubocop//lib/rubocop/config_store.rb#61
  def for_dir(dir); end

  # source://rubocop//lib/rubocop/config_store.rb#42
  def for_file(file); end

  # source://rubocop//lib/rubocop/config_store.rb#46
  def for_pwd; end

  # source://rubocop//lib/rubocop/config_store.rb#33
  def force_default_config!; end

  # source://rubocop//lib/rubocop/config_store.rb#28
  def options_config=(options_config); end

  # source://rubocop//lib/rubocop/config_store.rb#37
  def unvalidated; end

  # Returns the value of attribute validated.
  #
  # source://rubocop//lib/rubocop/config_store.rb#7
  def validated; end

  # Returns the value of attribute validated.
  #
  # source://rubocop//lib/rubocop/config_store.rb#7
  def validated?; end
end

# Handles validation of configuration, for example cop names, parameter
# names, and Ruby versions.
#
# source://rubocop//lib/rubocop/config_validator.rb#8
class RuboCop::ConfigValidator
  extend ::Forwardable

  # @return [ConfigValidator] a new instance of ConfigValidator
  #
  # source://rubocop//lib/rubocop/config_validator.rb#27
  def initialize(config); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def for_all_cops(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def smart_loaded_path(*args, **_arg1, &block); end

  # source://rubocop//lib/rubocop/config_validator.rb#63
  def target_ruby_version; end

  # source://rubocop//lib/rubocop/config_validator.rb#33
  def validate; end

  # Validations that should only be run after all config resolving has
  # taken place:
  # * The target ruby version is only checked once the entire inheritance
  # chain has been loaded so that only the final value is validated, and
  # any obsolete but overridden values are ignored.
  #
  # source://rubocop//lib/rubocop/config_validator.rb#59
  def validate_after_resolution; end

  # @raise [ValidationError]
  #
  # source://rubocop//lib/rubocop/config_validator.rb#67
  def validate_section_presence(name); end

  private

  # @raise [ValidationError]
  #
  # source://rubocop//lib/rubocop/config_validator.rb#104
  def alert_about_unrecognized_cops(invalid_cop_names); end

  # source://rubocop//lib/rubocop/config_validator.rb#253
  def check_cop_config_value(hash, parent = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/config_validator.rb#77
  def check_obsoletions; end

  # @raise [ValidationError]
  #
  # source://rubocop//lib/rubocop/config_validator.rb#84
  def check_target_ruby; end

  # source://rubocop//lib/rubocop/config_validator.rb#195
  def each_invalid_parameter(cop_name); end

  # source://rubocop//lib/rubocop/config_validator.rb#120
  def list_unknown_cops(invalid_cop_names); end

  # FIXME: Handling colors in exception messages like this is ugly.
  #
  # source://rubocop//lib/rubocop/config_validator.rb#266
  def msg_not_boolean(parent, key, value); end

  # source://rubocop//lib/rubocop/config_validator.rb#242
  def reject_conflicting_safe_settings; end

  # @raise [ValidationError]
  #
  # source://rubocop//lib/rubocop/config_validator.rb#233
  def reject_mutually_exclusive_defaults; end

  # source://rubocop//lib/rubocop/config_validator.rb#142
  def suggestion(name); end

  # Returns the value of attribute target_ruby.
  #
  # source://rubocop//lib/rubocop/config_validator.rb#75
  def target_ruby; end

  # source://rubocop//lib/rubocop/config_validator.rb#207
  def validate_enforced_styles(valid_cop_names); end

  # @raise [ValidationError]
  #
  # source://rubocop//lib/rubocop/config_validator.rb#169
  def validate_new_cops_parameter; end

  # source://rubocop//lib/rubocop/config_validator.rb#180
  def validate_parameter_names(valid_cop_names); end

  # source://rubocop//lib/rubocop/config_validator.rb#227
  def validate_support_and_has_list(name, formats, valid); end

  # @raise [ValidationError]
  #
  # source://rubocop//lib/rubocop/config_validator.rb#158
  def validate_syntax_cop; end
end

# @api private
#
# source://rubocop//lib/rubocop/config_validator.rb#12
RuboCop::ConfigValidator::COMMON_PARAMS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/config_validator.rb#22
RuboCop::ConfigValidator::CONFIG_CHECK_DEPARTMENTS = T.let(T.unsafe(nil), Array)

# @api private
#
# source://rubocop//lib/rubocop/config_validator.rb#21
RuboCop::ConfigValidator::CONFIG_CHECK_KEYS = T.let(T.unsafe(nil), Set)

# @api private
#
# source://rubocop//lib/rubocop/config_validator.rb#14
RuboCop::ConfigValidator::INTERNAL_PARAMS = T.let(T.unsafe(nil), Array)

# @api private
#
# source://rubocop//lib/rubocop/config_validator.rb#18
RuboCop::ConfigValidator::NEW_COPS_VALUES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/util.rb#4
module RuboCop::Cop; end

# This module checks for nodes that should be aligned to the left or right.
# This amount is determined by the instance variable @column_delta.
#
# source://rubocop//lib/rubocop/cop/mixin/alignment.rb#7
module RuboCop::Cop::Alignment
  private

  # source://rubocop//lib/rubocop/cop/mixin/alignment.rb#26
  def check_alignment(items, base_column = T.unsafe(nil)); end

  # Returns the value of attribute column_delta.
  #
  # source://rubocop//lib/rubocop/cop/mixin/alignment.rb#12
  def column_delta; end

  # source://rubocop//lib/rubocop/cop/mixin/alignment.rb#14
  def configured_indentation_width; end

  # @api public
  #
  # source://rubocop//lib/rubocop/cop/mixin/alignment.rb#58
  def display_column(range); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/mixin/alignment.rb#45
  def each_bad_alignment(items, base_column); end

  # @deprecated Use processed_source.comment_at_line(line)
  #
  # source://rubocop//lib/rubocop/cop/mixin/alignment.rb#69
  def end_of_line_comment(line); end

  # source://rubocop//lib/rubocop/cop/mixin/alignment.rb#18
  def indentation(node); end

  # source://rubocop//lib/rubocop/cop/mixin/alignment.rb#22
  def offset(node); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/mixin/alignment.rb#74
  def register_offense(offense_node, message_node); end

  # @api public
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/alignment.rb#64
  def within?(inner, outer); end
end

# source://rubocop//lib/rubocop/cop/mixin/alignment.rb#10
RuboCop::Cop::Alignment::SPACE = T.let(T.unsafe(nil), String)

# This class does autocorrection of nodes that should just be moved to
# the left or to the right, amount being determined by the instance
# variable column_delta.
#
# source://rubocop//lib/rubocop/cop/correctors/alignment_corrector.rb#8
class RuboCop::Cop::AlignmentCorrector
  extend ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::Alignment

  class << self
    # source://rubocop//lib/rubocop/cop/correctors/alignment_corrector.rb#29
    def align_end(corrector, processed_source, node, align_to); end

    # source://rubocop//lib/rubocop/cop/correctors/alignment_corrector.rb#15
    def correct(corrector, processed_source, node, column_delta); end

    # Returns the value of attribute processed_source.
    #
    # source://rubocop//lib/rubocop/cop/correctors/alignment_corrector.rb#13
    def processed_source; end

    private

    # source://rubocop//lib/rubocop/cop/correctors/alignment_corrector.rb#124
    def alignment_column(align_to); end

    # source://rubocop//lib/rubocop/cop/correctors/alignment_corrector.rb#40
    def autocorrect_line(corrector, line_begin_pos, expr, column_delta, taboo_ranges); end

    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/cop/correctors/alignment_corrector.rb#81
    def block_comment_within?(expr); end

    # source://rubocop//lib/rubocop/cop/correctors/alignment_corrector.rb#87
    def calculate_range(expr, line_begin_pos, column_delta); end

    # Some special kinds of string literals are not composed of literal
    # characters between two delimiters:
    # - The source map of `?a` responds to :begin and :end but its end is
    #   nil.
    # - The source map of `__FILE__` responds to neither :begin nor :end.
    #
    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/cop/correctors/alignment_corrector.rb#75
    def delimited_string_literal?(node); end

    # source://rubocop//lib/rubocop/cop/correctors/alignment_corrector.rb#110
    def each_line(expr); end

    # source://rubocop//lib/rubocop/cop/correctors/alignment_corrector.rb#60
    def inside_string_range(node); end

    # source://rubocop//lib/rubocop/cop/correctors/alignment_corrector.rb#54
    def inside_string_ranges(node); end

    # source://rubocop//lib/rubocop/cop/correctors/alignment_corrector.rb#99
    def remove(range, corrector); end

    # source://rubocop//lib/rubocop/cop/correctors/alignment_corrector.rb#118
    def whitespace_range(node); end
  end
end

# This module encapsulates the ability to allow certain identifiers in a cop.
#
# source://rubocop//lib/rubocop/cop/mixin/allowed_identifiers.rb#6
module RuboCop::Cop::AllowedIdentifiers
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/allowed_identifiers.rb#9
  def allowed_identifier?(name); end

  # source://rubocop//lib/rubocop/cop/mixin/allowed_identifiers.rb#13
  def allowed_identifiers; end
end

# if a variable starts with a sigil it will be removed
#
# source://rubocop//lib/rubocop/cop/mixin/allowed_identifiers.rb#7
RuboCop::Cop::AllowedIdentifiers::SIGILS = T.let(T.unsafe(nil), String)

# This module encapsulates the ability to allow certain methods when
# parsing. Even if the code is in offense, if it contains methods
# that are allowed. This module is equivalent to the IgnoredMethods module,
# which will be deprecated in RuboCop 2.0.
#
# source://rubocop//lib/rubocop/cop/mixin/allowed_methods.rb#9
module RuboCop::Cop::AllowedMethods
  private

  # @api public
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/allowed_methods.rb#13
  def allowed_method?(name); end

  # @api public
  #
  # source://rubocop//lib/rubocop/cop/mixin/allowed_methods.rb#21
  def allowed_methods; end

  # source://rubocop//lib/rubocop/cop/mixin/allowed_methods.rb#29
  def cop_config_allowed_methods; end

  # source://rubocop//lib/rubocop/cop/mixin/allowed_methods.rb#33
  def cop_config_deprecated_values; end

  # @api public
  # @deprecated Use allowed_method? instead
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/allowed_methods.rb#13
  def ignored_method?(name); end
end

# This module encapsulates the ability to ignore certain lines when
# parsing.
#
# source://rubocop//lib/rubocop/cop/mixin/allowed_pattern.rb#7
module RuboCop::Cop::AllowedPattern
  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/allowed_pattern.rb#10
  def allowed_line?(line); end

  # source://rubocop//lib/rubocop/cop/mixin/allowed_pattern.rb#30
  def allowed_patterns; end

  # source://rubocop//lib/rubocop/cop/mixin/allowed_pattern.rb#46
  def cop_config_deprecated_methods_values; end

  # source://rubocop//lib/rubocop/cop/mixin/allowed_pattern.rb#40
  def cop_config_patterns_values; end

  # @deprecated Use allowed_line? instead
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/allowed_pattern.rb#10
  def ignored_line?(line); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/allowed_pattern.rb#23
  def matches_allowed_pattern?(line); end

  # @deprecated Use matches_allowed_pattern?? instead
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/allowed_pattern.rb#23
  def matches_ignored_pattern?(line); end
end

# Error raised when an unqualified cop name is used that could
# refer to two or more cops under different departments
#
# source://rubocop//lib/rubocop/cop/registry.rb#7
class RuboCop::Cop::AmbiguousCopName < ::RuboCop::Error
  # @return [AmbiguousCopName] a new instance of AmbiguousCopName
  #
  # source://rubocop//lib/rubocop/cop/registry.rb#11
  def initialize(name, origin, badges); end
end

# source://rubocop//lib/rubocop/cop/registry.rb#8
RuboCop::Cop::AmbiguousCopName::MSG = T.let(T.unsafe(nil), String)

# Representation of an annotation comment in source code (eg. `# TODO: blah blah blah`).
#
# source://rubocop//lib/rubocop/cop/mixin/annotation_comment.rb#6
class RuboCop::Cop::AnnotationComment
  extend ::Forwardable

  # @param comment [Parser::Source::Comment]
  # @param keywords [Array<String>]
  # @return [AnnotationComment] a new instance of AnnotationComment
  #
  # source://rubocop//lib/rubocop/cop/mixin/annotation_comment.rb#13
  def initialize(comment, keywords); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/annotation_comment.rb#19
  def annotation?; end

  # Returns the range bounds for just the annotation
  #
  # source://rubocop//lib/rubocop/cop/mixin/annotation_comment.rb#31
  def bounds; end

  # Returns the value of attribute colon.
  #
  # source://rubocop//lib/rubocop/cop/mixin/annotation_comment.rb#9
  def colon; end

  # Returns the value of attribute comment.
  #
  # source://rubocop//lib/rubocop/cop/mixin/annotation_comment.rb#9
  def comment; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/annotation_comment.rb#23
  def correct?(colon:); end

  # Returns the value of attribute keyword.
  #
  # source://rubocop//lib/rubocop/cop/mixin/annotation_comment.rb#9
  def keyword; end

  # Returns the value of attribute margin.
  #
  # source://rubocop//lib/rubocop/cop/mixin/annotation_comment.rb#9
  def margin; end

  # Returns the value of attribute note.
  #
  # source://rubocop//lib/rubocop/cop/mixin/annotation_comment.rb#9
  def note; end

  # Returns the value of attribute space.
  #
  # source://rubocop//lib/rubocop/cop/mixin/annotation_comment.rb#9
  def space; end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/annotation_comment.rb#67
  def just_keyword_of_sentence?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/annotation_comment.rb#63
  def keyword_appearance?; end

  # Returns the value of attribute keywords.
  #
  # source://rubocop//lib/rubocop/cop/mixin/annotation_comment.rb#39
  def keywords; end

  # source://rubocop//lib/rubocop/cop/mixin/annotation_comment.rb#53
  def regex; end

  # source://rubocop//lib/rubocop/cop/mixin/annotation_comment.rb#41
  def split_comment(comment); end
end

# source://rubocop//lib/rubocop/cop/mixin/annotation_comment.rb#50
RuboCop::Cop::AnnotationComment::KEYWORDS_REGEX_CACHE = T.let(T.unsafe(nil), Hash)

# Handles the `MinSize` configuration option for array-based cops
# `Style/SymbolArray` and `Style/WordArray`, which check for use of the
# relevant percent literal syntax such as `%i[...]` and `%w[...]`
#
# source://rubocop//lib/rubocop/cop/mixin/array_min_size.rb#8
module RuboCop::Cop::ArrayMinSize
  private

  # source://rubocop//lib/rubocop/cop/mixin/array_min_size.rb#19
  def array_style_detected(style, ary_size); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/array_min_size.rb#11
  def below_array_length?(node); end

  # source://rubocop//lib/rubocop/cop/mixin/array_min_size.rb#38
  def largest_brackets_size(style, ary_size); end

  # source://rubocop//lib/rubocop/cop/mixin/array_min_size.rb#15
  def min_size_config; end

  # source://rubocop//lib/rubocop/cop/mixin/array_min_size.rb#48
  def smallest_percent_size(style, ary_size); end
end

# Common code for ordinary arrays with [] that can be written with %
# syntax.
#
# source://rubocop//lib/rubocop/cop/mixin/array_syntax.rb#7
module RuboCop::Cop::ArraySyntax
  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/array_syntax.rb#10
  def bracketed_array_of?(element_type, node); end
end

# extend this module to signal autocorrection support
#
# source://rubocop//lib/rubocop/cop/mixin/auto_corrector.rb#6
module RuboCop::Cop::AutoCorrector
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/auto_corrector.rb#7
  def support_autocorrect?; end
end

# This module encapsulates the logic for autocorrect behavior for a cop.
#
# source://rubocop//lib/rubocop/cop/autocorrect_logic.rb#6
module RuboCop::Cop::AutocorrectLogic
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/autocorrect_logic.rb#7
  def autocorrect?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/autocorrect_logic.rb#31
  def autocorrect_enabled?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/autocorrect_logic.rb#15
  def autocorrect_requested?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/autocorrect_logic.rb#11
  def autocorrect_with_disable_uncorrectable?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/autocorrect_logic.rb#19
  def correctable?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/autocorrect_logic.rb#23
  def disable_uncorrectable?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/autocorrect_logic.rb#27
  def safe_autocorrect?; end

  private

  # source://rubocop//lib/rubocop/cop/autocorrect_logic.rb#46
  def disable_offense(offense_range); end

  # source://rubocop//lib/rubocop/cop/autocorrect_logic.rb#111
  def disable_offense_at_end_of_line(range, eol_comment); end

  # source://rubocop//lib/rubocop/cop/autocorrect_logic.rb#115
  def disable_offense_before_and_after(range_by_lines); end

  # source://rubocop//lib/rubocop/cop/autocorrect_logic.rb#56
  def disable_offense_with_eol_or_surround_comment(range); end

  # source://rubocop//lib/rubocop/cop/autocorrect_logic.rb#107
  def max_line_length; end

  # Expand the given range to include all of any lines it covers. Does not
  # include newline at end of the last line.
  #
  # source://rubocop//lib/rubocop/cop/autocorrect_logic.rb#97
  def range_by_lines(range); end

  # source://rubocop//lib/rubocop/cop/autocorrect_logic.rb#88
  def range_of_first_line(range); end

  # source://rubocop//lib/rubocop/cop/autocorrect_logic.rb#67
  def surrounding_heredoc(offense_range); end

  # source://rubocop//lib/rubocop/cop/autocorrect_logic.rb#78
  def surrounding_percent_array(offense_range); end
end

# Identifier of all cops containing a department and cop name.
#
# All cops are identified by their badge. For example, the badge for
# `RuboCop::Cop::Layout::IndentationStyle` is `Layout/IndentationStyle`.
# Badges can be parsed as either `Department/CopName` or just `CopName` to
# allow for badge references in source files that omit the department for
# RuboCop to infer.
#
# source://rubocop//lib/rubocop/cop/badge.rb#12
class RuboCop::Cop::Badge
  # @return [Badge] a new instance of Badge
  #
  # source://rubocop//lib/rubocop/cop/badge.rb#34
  def initialize(class_name_parts); end

  # source://rubocop//lib/rubocop/cop/badge.rb#41
  def ==(other); end

  # Returns the value of attribute cop_name.
  #
  # source://rubocop//lib/rubocop/cop/badge.rb#13
  def cop_name; end

  # Returns the value of attribute department.
  #
  # source://rubocop//lib/rubocop/cop/badge.rb#13
  def department; end

  # Returns the value of attribute department_name.
  #
  # source://rubocop//lib/rubocop/cop/badge.rb#13
  def department_name; end

  # source://rubocop//lib/rubocop/cop/badge.rb#41
  def eql?(other); end

  # source://rubocop//lib/rubocop/cop/badge.rb#46
  def hash; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/badge.rb#51
  def match?(other); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/badge.rb#59
  def qualified?; end

  # source://rubocop//lib/rubocop/cop/badge.rb#55
  def to_s; end

  # source://rubocop//lib/rubocop/cop/badge.rb#63
  def with_department(department); end

  class << self
    # source://rubocop//lib/rubocop/cop/badge.rb#27
    def camel_case(name_part); end

    # source://rubocop//lib/rubocop/cop/badge.rb#15
    def for(class_name); end

    # source://rubocop//lib/rubocop/cop/badge.rb#23
    def parse(identifier); end
  end
end

# A scaffold for concrete cops.
#
# The Cop::Base class is meant to be extended.
#
# Cops track offenses and can autocorrect them on the fly.
#
# A commissioner object is responsible for traversing the AST and invoking
# the specific callbacks on each cop.
#
# First the callback `on_new_investigation` is called;
# if a cop needs to do its own processing of the AST or depends on
# something else.
#
# Then callbacks like `on_def`, `on_send` (see AST::Traversal) are called
# with their respective nodes.
#
# Finally the callback `on_investigation_end` is called.
#
# Within these callbacks, cops are meant to call `add_offense` or
# `add_global_offense`. Use the `processed_source` method to
# get the currently processed source being investigated.
#
# In case of invalid syntax / unparsable content,
# the callback `on_other_file` is called instead of all the other
# `on_...` callbacks.
#
# Private methods are not meant for custom cops consumption,
# nor are any instance variables.
#
# source://rubocop//lib/rubocop/cop/base.rb#34
class RuboCop::Cop::Base
  include ::RuboCop::AST::Sexp
  include ::RuboCop::PathUtil
  include ::RuboCop::Cop::Util
  include ::RuboCop::Cop::IgnoredNode
  include ::RuboCop::Cop::AutocorrectLogic
  extend ::RuboCop::AST::Sexp
  extend ::RuboCop::AST::NodePattern::Macros
  extend ::RuboCop::ExcludeLimit

  # @return [Base] a new instance of Base
  #
  # source://rubocop//lib/rubocop/cop/base.rb#129
  def initialize(config = T.unsafe(nil), options = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/base.rb#239
  def active_support_extensions_enabled?; end

  # Adds an offense that has no particular location.
  # No correction can be applied to global offenses
  #
  # source://rubocop//lib/rubocop/cop/base.rb#162
  def add_global_offense(message = T.unsafe(nil), severity: T.unsafe(nil)); end

  # Adds an offense on the specified range (or node with an expression)
  # Unless that offense is disabled for this range, a corrector will be yielded
  # to provide the cop the opportunity to autocorrect the offense.
  # If message is not specified, the method `message` will be called.
  #
  # source://rubocop//lib/rubocop/cop/base.rb#172
  def add_offense(node_or_range, message: T.unsafe(nil), severity: T.unsafe(nil), &block); end

  # Called before any investigation
  #
  # @api private
  #
  # source://rubocop//lib/rubocop/cop/base.rb#295
  def begin_investigation(processed_source, offset: T.unsafe(nil), original: T.unsafe(nil)); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/base.rb#280
  def callbacks_needed; end

  # Returns the value of attribute config.
  #
  # source://rubocop//lib/rubocop/cop/base.rb#43
  def config; end

  # source://rubocop//lib/rubocop/cop/base.rb#223
  def config_to_allow_offenses; end

  # source://rubocop//lib/rubocop/cop/base.rb#227
  def config_to_allow_offenses=(hash); end

  # Configuration Helpers
  #
  # source://rubocop//lib/rubocop/cop/base.rb#217
  def cop_config; end

  # source://rubocop//lib/rubocop/cop/base.rb#209
  def cop_name; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/base.rb#251
  def excluded_file?(file); end

  # This method should be overridden when a cop's behavior depends
  # on state that lives outside of these locations:
  #
  #   (1) the file under inspection
  #   (2) the cop's source code
  #   (3) the config (eg a .rubocop.yml file)
  #
  # For example, some cops may want to look at other parts of
  # the codebase being inspected to find violations. A cop may
  # use the presence or absence of file `foo.rb` to determine
  # whether a certain violation exists in `bar.rb`.
  #
  # Overriding this method allows the cop to indicate to RuboCop's
  # ResultCache system when those external dependencies change,
  # ie when the ResultCache should be invalidated.
  #
  # source://rubocop//lib/rubocop/cop/base.rb#205
  def external_dependency_checksum; end

  # Gets called if no message is specified when calling `add_offense` or
  # `add_global_offense`
  # Cops are discouraged to override this; instead pass your message directly
  #
  # source://rubocop//lib/rubocop/cop/base.rb#156
  def message(_range = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/base.rb#209
  def name; end

  # @deprecated Make potential errors with previous API more obvious
  #
  # source://rubocop//lib/rubocop/cop/base.rb#271
  def offenses; end

  # Called after all on_... have been called
  # When refining this method, always call `super`
  #
  # source://rubocop//lib/rubocop/cop/base.rb#143
  def on_investigation_end; end

  # Called before all on_... have been called
  # When refining this method, always call `super`
  #
  # source://rubocop//lib/rubocop/cop/base.rb#137
  def on_new_investigation; end

  # Called instead of all on_... callbacks for unrecognized files / syntax errors
  # When refining this method, always call `super`
  #
  # source://rubocop//lib/rubocop/cop/base.rb#149
  def on_other_file; end

  # There should be very limited reasons for a Cop to do it's own parsing
  #
  # source://rubocop//lib/rubocop/cop/base.rb#256
  def parse(source, path = T.unsafe(nil)); end

  # Returns the value of attribute processed_source.
  #
  # source://rubocop//lib/rubocop/cop/base.rb#43
  def processed_source; end

  # Called between investigations
  #
  # @api private
  #
  # source://rubocop//lib/rubocop/cop/base.rb#262
  def ready; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/base.rb#243
  def relevant_file?(file); end

  # source://rubocop//lib/rubocop/cop/base.rb#235
  def target_rails_version; end

  # source://rubocop//lib/rubocop/cop/base.rb#231
  def target_ruby_version; end

  private

  # source://rubocop//lib/rubocop/cop/base.rb#432
  def annotate(message); end

  # source://rubocop//lib/rubocop/cop/base.rb#316
  def apply_correction(corrector); end

  # @return [Symbol] offense status
  #
  # source://rubocop//lib/rubocop/cop/base.rb#396
  def attempt_correction(range, corrector); end

  # Reserved for Cop::Cop
  #
  # source://rubocop//lib/rubocop/cop/base.rb#312
  def callback_argument(range); end

  # Called to complete an investigation
  #
  # source://rubocop//lib/rubocop/cop/base.rb#345
  def complete_investigation; end

  # @return [Symbol, Corrector] offense status
  #
  # source://rubocop//lib/rubocop/cop/base.rb#370
  def correct(range); end

  # source://rubocop//lib/rubocop/cop/base.rb#330
  def current_corrector; end

  # Reserved for Commissioner:
  #
  # source://rubocop//lib/rubocop/cop/base.rb#322
  def current_offense_locations; end

  # source://rubocop//lib/rubocop/cop/base.rb#334
  def current_offenses; end

  # source://rubocop//lib/rubocop/cop/base.rb#326
  def currently_disabled_lines; end

  # source://rubocop//lib/rubocop/cop/base.rb#460
  def custom_severity; end

  # source://rubocop//lib/rubocop/cop/base.rb#456
  def default_severity; end

  # source://rubocop//lib/rubocop/cop/base.rb#410
  def disable_uncorrectable(range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/base.rb#446
  def enabled_line?(line_number); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/base.rb#438
  def file_name_matches_any?(file, parameter, default_result); end

  # source://rubocop//lib/rubocop/cop/base.rb#428
  def find_message(range, message); end

  # source://rubocop//lib/rubocop/cop/base.rb#452
  def find_severity(_range, severity); end

  # source://rubocop//lib/rubocop/cop/base.rb#473
  def range_for_original(range); end

  # source://rubocop//lib/rubocop/cop/base.rb#417
  def range_from_node_or_range(node_or_range); end

  # source://rubocop//lib/rubocop/cop/base.rb#365
  def reset_investigation; end

  # @return [Symbol] offense status
  #
  # source://rubocop//lib/rubocop/cop/base.rb#385
  def use_corrector(range, corrector); end

  class << self
    # List of cops that should not try to autocorrect at the same
    # time as this cop
    #
    # @api public
    # @return [Array<RuboCop::Cop::Cop>]
    #
    # source://rubocop//lib/rubocop/cop/base.rb#59
    def autocorrect_incompatible_with; end

    # Naming
    #
    # source://rubocop//lib/rubocop/cop/base.rb#89
    def badge; end

    # @api private
    #
    # source://rubocop//lib/rubocop/cop/base.rb#285
    def callbacks_needed; end

    # source://rubocop//lib/rubocop/cop/base.rb#93
    def cop_name; end

    # source://rubocop//lib/rubocop/cop/base.rb#97
    def department; end

    # Cops (other than builtin) are encouraged to implement this
    #
    # @api public
    # @return [String, nil]
    #
    # source://rubocop//lib/rubocop/cop/base.rb#67
    def documentation_url; end

    # Call for abstract Cop classes
    #
    # source://rubocop//lib/rubocop/cop/base.rb#77
    def exclude_from_registry; end

    # @private
    #
    # source://rubocop//lib/rubocop/cop/base.rb#71
    def inherited(subclass); end

    # Override and return the Force class(es) you need to join
    #
    # source://rubocop//lib/rubocop/cop/base.rb#114
    def joining_forces; end

    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/cop/base.rb#101
    def lint?; end

    # Returns true if the cop name or the cop namespace matches any of the
    # given names.
    #
    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/cop/base.rb#107
    def match?(given_names); end

    # Returns if class supports autocorrect.
    # It is recommended to extend AutoCorrector instead of overriding
    #
    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/cop/base.rb#83
    def support_autocorrect?; end

    # Override if your cop should be called repeatedly for multiple investigations
    # Between calls to `on_new_investigation` and `on_investigation_end`,
    # the result of `processed_source` will remain constant.
    # You should invalidate any caches that depend on the current `processed_source`
    # in the `on_new_investigation` callback.
    # If your cop does autocorrections, be aware that your instance may be called
    # multiple times with the same `processed_source.path` but different content.
    #
    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/cop/base.rb#125
    def support_multiple_source?; end

    private

    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/cop/base.rb#356
    def builtin?; end

    # source://rubocop//lib/rubocop/cop/base.rb#338
    def restrict_on_send; end
  end
end

# source://rubocop//lib/rubocop/cop/base.rb#342
RuboCop::Cop::Base::EMPTY_OFFENSES = T.let(T.unsafe(nil), Array)

# Reports of an investigation.
# Immutable
# Consider creation API private
#
# source://rubocop//lib/rubocop/cop/base.rb#48
class RuboCop::Cop::Base::InvestigationReport < ::Struct
  # Returns the value of attribute cop
  #
  # @return [Object] the current value of cop
  def cop; end

  # Sets the attribute cop
  #
  # @param value [Object] the value to set the attribute cop to.
  # @return [Object] the newly set value
  def cop=(_); end

  # Returns the value of attribute corrector
  #
  # @return [Object] the current value of corrector
  def corrector; end

  # Sets the attribute corrector
  #
  # @param value [Object] the value to set the attribute corrector to.
  # @return [Object] the newly set value
  def corrector=(_); end

  # Returns the value of attribute offenses
  #
  # @return [Object] the current value of offenses
  def offenses; end

  # Sets the attribute offenses
  #
  # @param value [Object] the value to set the attribute offenses to.
  # @return [Object] the newly set value
  def offenses=(_); end

  # Returns the value of attribute processed_source
  #
  # @return [Object] the current value of processed_source
  def processed_source; end

  # Sets the attribute processed_source
  #
  # @param value [Object] the value to set the attribute processed_source to.
  # @return [Object] the newly set value
  def processed_source=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# List of methods names to restrict calls for `on_send` / `on_csend`
#
# source://rubocop//lib/rubocop/cop/base.rb#51
RuboCop::Cop::Base::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Set)

# source://rubocop//lib/rubocop/cop/bundler/duplicated_gem.rb#5
module RuboCop::Cop::Bundler; end

# A Gem's requirements should be listed only once in a Gemfile.
#
# @example
#   # bad
#   gem 'rubocop'
#   gem 'rubocop'
#
#   # bad
#   group :development do
#   gem 'rubocop'
#   end
#
#   group :test do
#   gem 'rubocop'
#   end
#
#   # good
#   group :development, :test do
#   gem 'rubocop'
#   end
#
#   # good
#   gem 'rubocop', groups: [:development, :test]
#
#   # good - conditional declaration
#   if Dir.exist?(local)
#   gem 'rubocop', path: local
#   elsif ENV['RUBOCOP_VERSION'] == 'master'
#   gem 'rubocop', git: 'https://github.com/rubocop/rubocop.git'
#   else
#   gem 'rubocop', '~> 0.90.0'
#   end
#
# source://rubocop//lib/rubocop/cop/bundler/duplicated_gem.rb#38
class RuboCop::Cop::Bundler::DuplicatedGem < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/bundler/duplicated_gem.rb#57
  def gem_declarations(param0); end

  # source://rubocop//lib/rubocop/cop/bundler/duplicated_gem.rb#44
  def on_new_investigation; end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/bundler/duplicated_gem.rb#66
  def conditional_declaration?(nodes); end

  # source://rubocop//lib/rubocop/cop/bundler/duplicated_gem.rb#59
  def duplicated_gem_nodes; end

  # source://rubocop//lib/rubocop/cop/bundler/duplicated_gem.rb#80
  def register_offense(node, gem_name, line_of_first_occurrence); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/bundler/duplicated_gem.rb#74
  def within_conditional?(node, conditional_node); end
end

# source://rubocop//lib/rubocop/cop/bundler/duplicated_gem.rb#41
RuboCop::Cop::Bundler::DuplicatedGem::MSG = T.let(T.unsafe(nil), String)

# Each gem in the Gemfile should have a comment explaining
# its purpose in the project, or the reason for its version
# or source.
#
# The optional "OnlyFor" configuration array
# can be used to only register offenses when the gems
# use certain options or have version specifiers.
#
# When "version_specifiers" is included, a comment
# will be enforced if the gem has any version specifier.
#
# When "restrictive_version_specifiers" is included, a comment
# will be enforced if the gem has a version specifier that
# holds back the version of the gem.
#
# For any other value in the array, a comment will be enforced for
# a gem if an option by the same name is present.
# A useful use case is to enforce a comment when using
# options that change the source of a gem:
#
# - `bitbucket`
# - `gist`
# - `git`
# - `github`
# - `source`
#
# For a full list of options supported by bundler,
# see https://bundler.io/man/gemfile.5.html
# .
#
# @example OnlyFor: [] (default)
#   # bad
#
#   gem 'foo'
#
#   # good
#
#   # Helpers for the foo things.
#   gem 'foo'
# @example OnlyFor: ['version_specifiers']
#   # bad
#
#   gem 'foo', '< 2.1'
#
#   # good
#
#   # Version 2.1 introduces breaking change baz
#   gem 'foo', '< 2.1'
# @example OnlyFor: ['restrictive_version_specifiers']
#   # bad
#
#   gem 'foo', '< 2.1'
#
#   # good
#
#   gem 'foo', '>= 1.0'
#
#   # Version 2.1 introduces breaking change baz
#   gem 'foo', '< 2.1'
# @example OnlyFor: ['version_specifiers', 'github']
#   # bad
#
#   gem 'foo', github: 'some_account/some_fork_of_foo'
#
#   gem 'bar', '< 2.1'
#
#   # good
#
#   # Using this fork because baz
#   gem 'foo', github: 'some_account/some_fork_of_foo'
#
#   # Version 2.1 introduces breaking change baz
#   gem 'bar', '< 2.1'
#
# source://rubocop//lib/rubocop/cop/bundler/gem_comment.rb#83
class RuboCop::Cop::Bundler::GemComment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::VisibilityHelp
  include ::RuboCop::Cop::DefNode
  include ::RuboCop::Cop::GemDeclaration

  # source://rubocop//lib/rubocop/cop/bundler/gem_comment.rb#94
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/bundler/gem_comment.rb#135
  def checked_options_present?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/bundler/gem_comment.rb#109
  def commented?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/bundler/gem_comment.rb#105
  def commented_any_descendant?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/bundler/gem_comment.rb#159
  def contains_checked_options?(node); end

  # source://rubocop//lib/rubocop/cop/bundler/gem_comment.rb#163
  def gem_options(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/bundler/gem_comment.rb#130
  def ignored_gem?(node); end

  # The args node1 & node2 may represent a RuboCop::AST::Node
  # or a Parser::Source::Comment. Both respond to #loc.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/bundler/gem_comment.rb#116
  def precede?(node1, node2); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/bundler/gem_comment.rb#126
  def preceding_comment?(node1, node2); end

  # source://rubocop//lib/rubocop/cop/bundler/gem_comment.rb#120
  def preceding_lines(node); end

  # Version specifications that restrict all updates going forward. This excludes versions
  # like ">= 1.0" or "!= 2.0.3".
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/bundler/gem_comment.rb#152
  def restrictive_version_specified_gem?(node); end

  # Besides the gem name, all other *positional* arguments to `gem` are version specifiers,
  # as long as it has one we know there's at least one version specifier.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/bundler/gem_comment.rb#145
  def version_specified_gem?(node); end
end

# source://rubocop//lib/rubocop/cop/bundler/gem_comment.rb#88
RuboCop::Cop::Bundler::GemComment::CHECKED_OPTIONS_CONFIG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/bundler/gem_comment.rb#87
RuboCop::Cop::Bundler::GemComment::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/bundler/gem_comment.rb#91
RuboCop::Cop::Bundler::GemComment::RESTRICTIVE_VERSION_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/bundler/gem_comment.rb#90
RuboCop::Cop::Bundler::GemComment::RESTRICTIVE_VERSION_SPECIFIERS_OPTION = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/bundler/gem_comment.rb#92
RuboCop::Cop::Bundler::GemComment::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/bundler/gem_comment.rb#89
RuboCop::Cop::Bundler::GemComment::VERSION_SPECIFIERS_OPTION = T.let(T.unsafe(nil), String)

# Verifies that a project contains Gemfile or gems.rb file and correct
# associated lock file based on the configuration.
#
# @example EnforcedStyle: Gemfile (default)
#   # bad
#   Project contains gems.rb and gems.locked files
#
#   # bad
#   Project contains Gemfile and gems.locked file
#
#   # good
#   Project contains Gemfile and Gemfile.lock
# @example EnforcedStyle: gems.rb
#   # bad
#   Project contains Gemfile and Gemfile.lock files
#
#   # bad
#   Project contains gems.rb and Gemfile.lock file
#
#   # good
#   Project contains gems.rb and gems.locked files
#
# source://rubocop//lib/rubocop/cop/bundler/gem_filename.rb#28
class RuboCop::Cop::Bundler::GemFilename < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/bundler/gem_filename.rb#43
  def on_new_investigation; end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/bundler/gem_filename.rb#88
  def expected_gemfile?(basename); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/bundler/gem_filename.rb#80
  def gemfile_offense?(basename); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/bundler/gem_filename.rb#93
  def gemfile_required?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/bundler/gem_filename.rb#84
  def gems_rb_offense?(basename); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/bundler/gem_filename.rb#97
  def gems_rb_required?; end

  # source://rubocop//lib/rubocop/cop/bundler/gem_filename.rb#58
  def register_gemfile_offense(file_path, basename); end

  # source://rubocop//lib/rubocop/cop/bundler/gem_filename.rb#69
  def register_gems_rb_offense(file_path, basename); end

  # source://rubocop//lib/rubocop/cop/bundler/gem_filename.rb#53
  def register_offense(file_path, basename); end
end

# source://rubocop//lib/rubocop/cop/bundler/gem_filename.rb#40
RuboCop::Cop::Bundler::GemFilename::GEMFILE_FILES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/bundler/gem_filename.rb#41
RuboCop::Cop::Bundler::GemFilename::GEMS_RB_FILES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/bundler/gem_filename.rb#36
RuboCop::Cop::Bundler::GemFilename::MSG_GEMFILE_MISMATCHED = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/bundler/gem_filename.rb#32
RuboCop::Cop::Bundler::GemFilename::MSG_GEMFILE_REQUIRED = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/bundler/gem_filename.rb#38
RuboCop::Cop::Bundler::GemFilename::MSG_GEMS_RB_MISMATCHED = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/bundler/gem_filename.rb#34
RuboCop::Cop::Bundler::GemFilename::MSG_GEMS_RB_REQUIRED = T.let(T.unsafe(nil), String)

# Enforce that Gem version specifications or a commit reference (branch,
# ref, or tag) are either required or forbidden.
#
# @example EnforcedStyle: required (default)
#   # bad
#   gem 'rubocop'
#
#   # good
#   gem 'rubocop', '~> 1.12'
#
#   # good
#   gem 'rubocop', '>= 1.10.0'
#
#   # good
#   gem 'rubocop', '>= 1.5.0', '< 1.10.0'
#
#   # good
#   gem 'rubocop', branch: 'feature-branch'
#
#   # good
#   gem 'rubocop', ref: '74b5bfbb2c4b6fd6cdbbc7254bd7084b36e0c85b'
#
#   # good
#   gem 'rubocop', tag: 'v1.17.0'
# @example EnforcedStyle: forbidden
#   # good
#   gem 'rubocop'
#
#   # bad
#   gem 'rubocop', '~> 1.12'
#
#   # bad
#   gem 'rubocop', '>= 1.10.0'
#
#   # bad
#   gem 'rubocop', '>= 1.5.0', '< 1.10.0'
#
#   # bad
#   gem 'rubocop', branch: 'feature-branch'
#
#   # bad
#   gem 'rubocop', ref: '74b5bfbb2c4b6fd6cdbbc7254bd7084b36e0c85b'
#
#   # bad
#   gem 'rubocop', tag: 'v1.17.0'
#
# source://rubocop//lib/rubocop/cop/bundler/gem_version.rb#53
class RuboCop::Cop::Bundler::GemVersion < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::GemDeclaration

  # source://rubocop//lib/rubocop/cop/bundler/gem_version.rb#67
  def includes_commit_reference?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/bundler/gem_version.rb#62
  def includes_version_specification?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/bundler/gem_version.rb#71
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/bundler/gem_version.rb#85
  def allowed_gem?(node); end

  # source://rubocop//lib/rubocop/cop/bundler/gem_version.rb#89
  def allowed_gems; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/bundler/gem_version.rb#113
  def forbidden_offense?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/bundler/gem_version.rb#119
  def forbidden_style?; end

  # source://rubocop//lib/rubocop/cop/bundler/gem_version.rb#93
  def message(range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/bundler/gem_version.rb#103
  def offense?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/bundler/gem_version.rb#107
  def required_offense?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/bundler/gem_version.rb#123
  def required_style?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/bundler/gem_version.rb#127
  def version_specification?(expression); end
end

# source://rubocop//lib/rubocop/cop/bundler/gem_version.rb#58
RuboCop::Cop::Bundler::GemVersion::FORBIDDEN_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/bundler/gem_version.rb#57
RuboCop::Cop::Bundler::GemVersion::REQUIRED_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/bundler/gem_version.rb#59
RuboCop::Cop::Bundler::GemVersion::VERSION_SPECIFICATION_REGEX = T.let(T.unsafe(nil), Regexp)

# Passing symbol arguments to `source` (e.g. `source :rubygems`) is
# deprecated because they default to using HTTP requests. Instead, specify
# `'https://rubygems.org'` if possible, or `'http://rubygems.org'` if not.
#
# When autocorrecting, this cop will replace symbol arguments with
# `'https://rubygems.org'`.
#
# This cop will not replace existing sources that use `http://`. This may
# be necessary where HTTPS is not available. For example, where using an
# internal gem server via an intranet, or where HTTPS is prohibited.
# However, you should strongly prefer `https://` where possible, as it is
# more secure.
#
# If you don't allow `http://`, please set `false` to `AllowHttpProtocol`.
# This option is `true` by default for safe autocorrection.
#
# @example
#   # bad
#   source :gemcutter
#   source :rubygems
#   source :rubyforge
#
#   # good
#   source 'https://rubygems.org' # strongly recommended
# @example AllowHttpProtocol: true (default)
#
#   # good
#   source 'http://rubygems.org' # use only if HTTPS is unavailable
# @example AllowHttpProtocol: false
#
#   # bad
#   source 'http://rubygems.org'
#
# source://rubocop//lib/rubocop/cop/bundler/insecure_protocol_source.rb#41
class RuboCop::Cop::Bundler::InsecureProtocolSource < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/bundler/insecure_protocol_source.rb#54
  def insecure_protocol_source?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/bundler/insecure_protocol_source.rb#59
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/bundler/insecure_protocol_source.rb#80
  def allow_http_protocol?; end
end

# source://rubocop//lib/rubocop/cop/bundler/insecure_protocol_source.rb#45
RuboCop::Cop::Bundler::InsecureProtocolSource::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/bundler/insecure_protocol_source.rb#49
RuboCop::Cop::Bundler::InsecureProtocolSource::MSG_HTTP_PROTOCOL = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/bundler/insecure_protocol_source.rb#51
RuboCop::Cop::Bundler::InsecureProtocolSource::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Gems should be alphabetically sorted within groups.
#
# @example
#   # bad
#   gem 'rubocop'
#   gem 'rspec'
#
#   # good
#   gem 'rspec'
#   gem 'rubocop'
#
#   # good
#   gem 'rubocop'
#
#   gem 'rspec'
#
#   # good only if TreatCommentsAsGroupSeparators is true
#   # For code quality
#   gem 'rubocop'
#   # For tests
#   gem 'rspec'
#
# source://rubocop//lib/rubocop/cop/bundler/ordered_gems.rb#27
class RuboCop::Cop::Bundler::OrderedGems < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::OrderedGemNode
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/bundler/ordered_gems.rb#56
  def gem_declarations(param0); end

  # source://rubocop//lib/rubocop/cop/bundler/ordered_gems.rb#35
  def on_new_investigation; end

  private

  # source://rubocop//lib/rubocop/cop/bundler/ordered_gems.rb#49
  def previous_declaration(node); end
end

# source://rubocop//lib/rubocop/cop/bundler/ordered_gems.rb#31
RuboCop::Cop::Bundler::OrderedGems::MSG = T.let(T.unsafe(nil), String)

# Common functionality for checking assignment nodes.
#
# source://rubocop//lib/rubocop/cop/mixin/check_assignment.rb#6
module RuboCop::Cop::CheckAssignment
  # source://rubocop//lib/rubocop/cop/mixin/check_assignment.rb#7
  def on_and_asgn(node); end

  # source://rubocop//lib/rubocop/cop/mixin/check_assignment.rb#7
  def on_casgn(node); end

  # source://rubocop//lib/rubocop/cop/mixin/check_assignment.rb#7
  def on_cvasgn(node); end

  # source://rubocop//lib/rubocop/cop/mixin/check_assignment.rb#7
  def on_gvasgn(node); end

  # source://rubocop//lib/rubocop/cop/mixin/check_assignment.rb#7
  def on_ivasgn(node); end

  # source://rubocop//lib/rubocop/cop/mixin/check_assignment.rb#7
  def on_lvasgn(node); end

  # source://rubocop//lib/rubocop/cop/mixin/check_assignment.rb#7
  def on_masgn(node); end

  # source://rubocop//lib/rubocop/cop/mixin/check_assignment.rb#7
  def on_op_asgn(node); end

  # source://rubocop//lib/rubocop/cop/mixin/check_assignment.rb#7
  def on_or_asgn(node); end

  # source://rubocop//lib/rubocop/cop/mixin/check_assignment.rb#19
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/mixin/check_assignment.rb#29
  def extract_rhs(node); end

  class << self
    # source://rubocop//lib/rubocop/cop/mixin/check_assignment.rb#29
    def extract_rhs(node); end
  end
end

# This mixin detects collections that are safe to "break"
# by inserting new lines. This is useful for breaking
# up long lines.
#
# Let's look at hashes as an example:
#
# We know hash keys are safe to break across lines. We can add
# linebreaks into hashes on lines longer than the specified maximum.
# Then in further passes cops can clean up the multi-line hash.
# For example, say the maximum line length is as indicated below:
#
#                                         |
#                                         v
# {foo: "0000000000", bar: "0000000000", baz: "0000000000"}
#
# In a LineLength autocorrection pass, a line is added before
# the first key that exceeds the column limit:
#
# {foo: "0000000000", bar: "0000000000",
# baz: "0000000000"}
#
# In a MultilineHashKeyLineBreaks pass, lines are inserted
# before all keys:
#
# {foo: "0000000000",
# bar: "0000000000",
# baz: "0000000000"}
#
# Then in future passes FirstHashElementLineBreak,
# MultilineHashBraceLayout, and TrailingCommaInHashLiteral will
# manipulate as well until we get:
#
# {
#   foo: "0000000000",
#   bar: "0000000000",
#   baz: "0000000000",
# }
#
# (Note: Passes may not happen exactly in this sequence.)
#
# source://rubocop//lib/rubocop/cop/mixin/check_line_breakable.rb#44
module RuboCop::Cop::CheckLineBreakable
  # source://rubocop//lib/rubocop/cop/mixin/check_line_breakable.rb#45
  def extract_breakable_node(node, max); end

  private

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/check_line_breakable.rb#200
  def all_on_same_line?(nodes); end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/check_line_breakable.rb#220
  def already_on_multiple_lines?(node); end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/check_line_breakable.rb#133
  def breakable_collection?(node, elements); end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/check_line_breakable.rb#187
  def children_could_be_broken_up?(children); end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/check_line_breakable.rb#150
  def contained_by_breakable_collection_on_same_line?(node); end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/check_line_breakable.rb#170
  def contained_by_multiline_collection_that_could_be_broken_up?(node); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/mixin/check_line_breakable.rb#60
  def extract_breakable_node_from_elements(node, elements, max); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/mixin/check_line_breakable.rb#72
  def extract_first_element_over_column_limit(node, elements, max); end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/check_line_breakable.rb#92
  def first_argument_is_heredoc?(node); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/mixin/check_line_breakable.rb#207
  def process_args(args); end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/check_line_breakable.rb#117
  def safe_to_ignore?(node); end

  # If a send node contains a heredoc argument, splitting cannot happen
  # after the heredoc or else it will cause a syntax error.
  #
  # @api private
  #
  # source://rubocop//lib/rubocop/cop/mixin/check_line_breakable.rb#101
  def shift_elements_for_heredoc_arg(node, elements, index); end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/check_line_breakable.rb#112
  def within_column_limit?(element, max, line); end
end

# Common functionality for checking length of code segments.
#
# source://rubocop//lib/rubocop/cop/mixin/code_length.rb#6
module RuboCop::Cop::CodeLength
  extend ::RuboCop::ExcludeLimit

  # source://rubocop//lib/rubocop/cop/exclude_limit.rb#11
  def max=(value); end

  private

  # source://rubocop//lib/rubocop/cop/mixin/code_length.rb#49
  def build_code_length_calculator(node); end

  # source://rubocop//lib/rubocop/cop/mixin/code_length.rb#31
  def check_code_length(node); end

  # source://rubocop//lib/rubocop/cop/mixin/code_length.rb#27
  def count_as_one; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/code_length.rb#23
  def count_comments?; end

  # Returns true for lines that shall not be included in the count.
  #
  # source://rubocop//lib/rubocop/cop/mixin/code_length.rb#45
  def irrelevant_line(source_line); end

  # source://rubocop//lib/rubocop/cop/mixin/code_length.rb#19
  def max_length; end

  # source://rubocop//lib/rubocop/cop/mixin/code_length.rb#15
  def message(length, max_length); end
end

# source://rubocop//lib/rubocop/cop/mixin/code_length.rb#9
RuboCop::Cop::CodeLength::MSG = T.let(T.unsafe(nil), String)

# Help methods for working with nodes containing comments.
#
# source://rubocop//lib/rubocop/cop/mixin/comments_help.rb#6
module RuboCop::Cop::CommentsHelp
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/comments_help.rb#25
  def comments_contain_disables?(node, cop_name); end

  # source://rubocop//lib/rubocop/cop/mixin/comments_help.rb#18
  def comments_in_range(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/comments_help.rb#14
  def contains_comments?(node); end

  # source://rubocop//lib/rubocop/cop/mixin/comments_help.rb#7
  def source_range_with_comment(node); end

  private

  # source://rubocop//lib/rubocop/cop/mixin/comments_help.rb#44
  def begin_pos_with_comment(node); end

  # source://rubocop//lib/rubocop/cop/mixin/comments_help.rb#58
  def buffer; end

  # source://rubocop//lib/rubocop/cop/mixin/comments_help.rb#39
  def end_position_for(node); end

  # Returns the end line of a node, which might be a comment and not part of the AST
  # End line is considered either the line at which another node starts, or
  # the line at which the parent node ends.
  #
  # source://rubocop//lib/rubocop/cop/mixin/comments_help.rb#66
  def find_end_line(node); end

  # source://rubocop//lib/rubocop/cop/mixin/comments_help.rb#54
  def start_line_position(node); end
end

# Commissioner class is responsible for processing the AST and delegating
# work to the specified cops.
#
# source://rubocop//lib/rubocop/cop/commissioner.rb#7
class RuboCop::Cop::Commissioner
  include ::RuboCop::AST::Traversal

  # @return [Commissioner] a new instance of Commissioner
  #
  # source://rubocop//lib/rubocop/cop/commissioner.rb#44
  def initialize(cops, forces = T.unsafe(nil), options = T.unsafe(nil)); end

  # Returns the value of attribute errors.
  #
  # source://rubocop//lib/rubocop/cop/commissioner.rb#42
  def errors; end

  # @return [InvestigationReport]
  #
  # source://rubocop//lib/rubocop/cop/commissioner.rb#79
  def investigate(processed_source, offset: T.unsafe(nil), original: T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on___ENCODING__(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on___FILE__(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on___LINE__(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_alias(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_and(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_and_asgn(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_arg(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_arg_expr(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_args(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_array(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_array_pattern(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_array_pattern_with_tail(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_back_ref(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_begin(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_block_pass(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_blockarg(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_break(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_case(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_case_match(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_casgn(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_cbase(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_class(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_complex(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_const(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_const_pattern(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_cvar(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_cvasgn(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_defined?(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_defs(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_dstr(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_dsym(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_eflipflop(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_empty_else(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_ensure(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_erange(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_false(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_find_pattern(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_float(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_for(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_forward_arg(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_forward_args(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_forwarded_args(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_forwarded_kwrestarg(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_forwarded_restarg(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_gvar(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_gvasgn(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_hash(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_hash_pattern(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_if(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_if_guard(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_iflipflop(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_in_match(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_in_pattern(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_index(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_indexasgn(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_int(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_irange(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_ivar(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_ivasgn(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_kwarg(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_kwargs(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_kwbegin(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_kwnilarg(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_kwoptarg(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_kwrestarg(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_kwsplat(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_lambda(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_lvar(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_lvasgn(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_masgn(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_match_alt(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_match_as(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_match_current_line(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_match_nil_pattern(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_match_pattern(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_match_pattern_p(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_match_rest(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_match_var(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_match_with_lvasgn(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_match_with_trailing_comma(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_mlhs(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_module(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_next(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_nil(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_not(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_nth_ref(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_numblock(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_op_asgn(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_optarg(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_or(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_or_asgn(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_pair(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_pin(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_postexe(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_preexe(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_procarg0(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_rational(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_redo(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_regexp(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_regopt(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_resbody(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_rescue(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_restarg(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_retry(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_return(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_sclass(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_self(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_shadowarg(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_splat(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_str(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_super(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_sym(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_true(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_undef(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_unless_guard(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_until(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_until_post(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_when(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_while(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_while_post(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_xstr(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_yield(node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#68
  def on_zsuper(node); end

  private

  # source://rubocop//lib/rubocop/cop/commissioner.rb#98
  def begin_investigation(processed_source, offset:, original:); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#121
  def build_callbacks(cops); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#116
  def initialize_callbacks; end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#159
  def invoke(callback, cops); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#163
  def invoke_with_argument(callback, cops, arg); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#112
  def reset; end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#131
  def restrict_callbacks(callbacks); end

  # NOTE: mutates `callbacks` in place
  #
  # source://rubocop//lib/rubocop/cop/commissioner.rb#149
  def restricted_map(callbacks); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#104
  def trigger_responding_cops(callback, node); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#139
  def trigger_restricted_cops(event, node); end

  # Allow blind rescues here, since we're absorbing and packaging or
  # re-raising exceptions that can be raised from within the individual
  # cops' `#investigate` methods.
  #
  # source://rubocop//lib/rubocop/cop/commissioner.rb#170
  def with_cop_error_handling(cop, node = T.unsafe(nil)); end
end

# How a Commissioner returns the results of the investigation
# as a list of Cop::InvestigationReport and any errors caught
# during the investigation.
# Immutable
# Consider creation API private
#
# source://rubocop//lib/rubocop/cop/commissioner.rb#18
class RuboCop::Cop::Commissioner::InvestigationReport < ::Struct
  # Returns the value of attribute cop_reports
  #
  # @return [Object] the current value of cop_reports
  def cop_reports; end

  # Sets the attribute cop_reports
  #
  # @param value [Object] the value to set the attribute cop_reports to.
  # @return [Object] the newly set value
  def cop_reports=(_); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#19
  def cops; end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#27
  def correctors; end

  # Returns the value of attribute errors
  #
  # @return [Object] the current value of errors
  def errors; end

  # Sets the attribute errors
  #
  # @param value [Object] the value to set the attribute errors to.
  # @return [Object] the newly set value
  def errors=(_); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#35
  def merge(investigation); end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#31
  def offenses; end

  # source://rubocop//lib/rubocop/cop/commissioner.rb#23
  def offenses_per_cop; end

  # Returns the value of attribute processed_source
  #
  # @return [Object] the current value of processed_source
  def processed_source; end

  # Sets the attribute processed_source
  #
  # @param value [Object] the value to set the attribute processed_source to.
  # @return [Object] the newly set value
  def processed_source=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://rubocop//lib/rubocop/cop/commissioner.rb#10
RuboCop::Cop::Commissioner::RESTRICTED_CALLBACKS = T.let(T.unsafe(nil), Array)

# This class does condition autocorrection
#
# source://rubocop//lib/rubocop/cop/correctors/condition_corrector.rb#6
class RuboCop::Cop::ConditionCorrector
  class << self
    # source://rubocop//lib/rubocop/cop/correctors/condition_corrector.rb#8
    def correct_negative_condition(corrector, node); end

    private

    # source://rubocop//lib/rubocop/cop/correctors/condition_corrector.rb#17
    def negated_condition(node); end
  end
end

# Handles `EnforcedStyle` configuration parameters.
#
# source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#6
module RuboCop::Cop::ConfigurableEnforcedStyle
  # source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#88
  def alternative_style; end

  # source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#96
  def alternative_styles; end

  # source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#19
  def ambiguous_style_detected(*possibilities); end

  # source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#60
  def conflicting_styles_detected; end

  # source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#11
  def correct_style_detected; end

  # source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#64
  def detected_style; end

  # source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#68
  def detected_style=(style); end

  # source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#60
  def no_acceptable_style!; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#56
  def no_acceptable_style?; end

  # source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#7
  def opposite_style_detected; end

  # source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#79
  def style; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#75
  def style_configured?; end

  # source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#29
  def style_detected(detected); end

  # source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#107
  def style_parameter_name; end

  # source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#100
  def supported_styles; end

  # source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#15
  def unexpected_style_detected(unexpected); end

  # source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#60
  def unrecognized_style_detected; end
end

# source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#23
RuboCop::Cop::ConfigurableEnforcedStyle::SYMBOL_TO_STRING_CACHE = T.let(T.unsafe(nil), Hash)

# Shared functionality between mixins that enforce naming conventions
#
# source://rubocop//lib/rubocop/cop/mixin/configurable_formatting.rb#6
module RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop//lib/rubocop/cop/mixin/configurable_formatting.rb#9
  def check_name(node, name, name_range); end

  # A class emitter method is a singleton method in a class/module, where
  # the method has the same name as a class defined in the class/module.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/configurable_formatting.rb#29
  def class_emitter_method?(node, name); end

  # source://rubocop//lib/rubocop/cop/mixin/configurable_formatting.rb#17
  def report_opposing_styles(node, name); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/configurable_formatting.rb#23
  def valid_name?(node, name, given_style = T.unsafe(nil)); end
end

# Handles `Max` configuration parameters, especially setting them to an
# appropriate value with --auto-gen-config.
#
# @deprecated Use `exclude_limit ParameterName` instead.
#
# source://rubocop//lib/rubocop/cop/mixin/configurable_max.rb#8
module RuboCop::Cop::ConfigurableMax
  private

  # source://rubocop//lib/rubocop/cop/mixin/configurable_max.rb#11
  def max=(value); end

  # source://rubocop//lib/rubocop/cop/mixin/configurable_max.rb#19
  def max_parameter_name; end
end

# This module provides functionality for checking if names match the
# configured EnforcedStyle.
#
# source://rubocop//lib/rubocop/cop/mixin/configurable_naming.rb#7
module RuboCop::Cop::ConfigurableNaming
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::ConfigurableFormatting
end

# source://rubocop//lib/rubocop/cop/mixin/configurable_naming.rb#10
RuboCop::Cop::ConfigurableNaming::FORMATS = T.let(T.unsafe(nil), Hash)

# This module provides functionality for checking if numbering match the
# configured EnforcedStyle.
#
# source://rubocop//lib/rubocop/cop/mixin/configurable_numbering.rb#7
module RuboCop::Cop::ConfigurableNumbering
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::ConfigurableFormatting
end

# source://rubocop//lib/rubocop/cop/mixin/configurable_numbering.rb#11
RuboCop::Cop::ConfigurableNumbering::FORMATS = T.let(T.unsafe(nil), Hash)

# Monkey-patch Cop for tests to provide easy access to messages and
# highlights.
#
# source://rubocop//lib/rubocop/cop/cop.rb#11
class RuboCop::Cop::Cop < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/cop.rb#53
  def add_offense(node_or_range, location: T.unsafe(nil), message: T.unsafe(nil), severity: T.unsafe(nil), &block); end

  # Called before any investigation
  #
  # @api private
  #
  # source://rubocop//lib/rubocop/cop/cop.rb#103
  def begin_investigation(processed_source, offset: T.unsafe(nil), original: T.unsafe(nil)); end

  # @deprecated
  #
  # source://rubocop//lib/rubocop/cop/cop.rb#82
  def corrections; end

  # source://rubocop//lib/rubocop/cop/cop.rb#70
  def find_location(node, loc); end

  # Returns the value of attribute offenses.
  #
  # source://rubocop//lib/rubocop/cop/cop.rb#12
  def offenses; end

  # Called after all on_... have been called
  #
  # source://rubocop//lib/rubocop/cop/cop.rb#96
  def on_investigation_end; end

  # Called before all on_... have been called
  #
  # source://rubocop//lib/rubocop/cop/cop.rb#90
  def on_new_investigation; end

  # @deprecated Use class method
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/cop.rb#76
  def support_autocorrect?; end

  private

  # source://rubocop//lib/rubocop/cop/cop.rb#121
  def apply_correction(corrector); end

  # Override Base
  #
  # source://rubocop//lib/rubocop/cop/cop.rb#117
  def callback_argument(_range); end

  # source://rubocop//lib/rubocop/cop/cop.rb#138
  def correction_lambda; end

  # source://rubocop//lib/rubocop/cop/cop.rb#144
  def dedupe_on_node(node); end

  # Just for legacy
  #
  # @yield [corrector]
  #
  # source://rubocop//lib/rubocop/cop/cop.rb#126
  def emulate_v0_callsequence(corrector); end

  # source://rubocop//lib/rubocop/cop/cop.rb#157
  def range_for_original(range); end

  # source://rubocop//lib/rubocop/cop/cop.rb#151
  def suppress_clobbering; end

  class << self
    # @deprecated Use Registry.all
    #
    # source://rubocop//lib/rubocop/cop/cop.rb#44
    def all; end

    # source://rubocop//lib/rubocop/cop/cop.rb#29
    def joining_forces; end

    # @deprecated Use Registry.qualified_cop_name
    #
    # source://rubocop//lib/rubocop/cop/cop.rb#49
    def qualified_cop_name(name, origin); end

    # @deprecated Use Registry.global
    #
    # source://rubocop//lib/rubocop/cop/cop.rb#39
    def registry; end

    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/cop/cop.rb#25
    def support_autocorrect?; end
  end
end

# @deprecated
#
# source://rubocop//lib/rubocop/cop/cop.rb#17
class RuboCop::Cop::Cop::Correction < ::Struct
  # source://rubocop//lib/rubocop/cop/cop.rb#18
  def call(corrector); end

  # Returns the value of attribute cop
  #
  # @return [Object] the current value of cop
  def cop; end

  # Sets the attribute cop
  #
  # @param value [Object] the value to set the attribute cop to.
  # @return [Object] the newly set value
  def cop=(_); end

  # Returns the value of attribute lambda
  #
  # @return [Object] the current value of lambda
  def lambda; end

  # Sets the attribute lambda
  #
  # @param value [Object] the value to set the attribute lambda to.
  # @return [Object] the newly set value
  def lambda=(_); end

  # Returns the value of attribute node
  #
  # @return [Object] the current value of node
  def node; end

  # Sets the attribute node
  #
  # @param value [Object] the value to set the attribute node to.
  # @return [Object] the newly set value
  def node=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# This class takes a source buffer and rewrite its source
# based on the different correction rules supplied.
#
# Important!
# The nodes modified by the corrections should be part of the
# AST of the source_buffer.
#
# source://rubocop//lib/rubocop/cop/corrector.rb#11
class RuboCop::Cop::Corrector < ::Parser::Source::TreeRewriter
  # corrector = Corrector.new(cop)
  #
  # @param source [Parser::Source::Buffer, or anything
  # leading to one via `(processed_source.)buffer`]
  # @return [Corrector] a new instance of Corrector
  #
  # source://rubocop//lib/rubocop/cop/corrector.rb#32
  def initialize(source); end

  # Removes `size` characters from the beginning of the given range.
  # If `size` is greater than the size of `range`, the removed region can
  # overrun the end of `range`.
  #
  # @param range [Parser::Source::Range, RuboCop::AST::Node] or node
  # @param size [Integer]
  #
  # source://rubocop//lib/rubocop/cop/corrector.rb#63
  def remove_leading(node_or_range, size); end

  # Removes `size` characters prior to the source range.
  #
  # @param range [Parser::Source::Range, RuboCop::AST::Node] or node
  # @param size [Integer]
  #
  # source://rubocop//lib/rubocop/cop/corrector.rb#51
  def remove_preceding(node_or_range, size); end

  # Removes `size` characters from the end of the given range.
  # If `size` is greater than the size of `range`, the removed region can
  # overrun the beginning of `range`.
  #
  # @param range [Parser::Source::Range, RuboCop::AST::Node] or node
  # @param size [Integer]
  #
  # source://rubocop//lib/rubocop/cop/corrector.rb#75
  def remove_trailing(node_or_range, size); end

  # Legacy
  #
  # source://parser/3.2.2.0/lib/parser/source/tree_rewriter.rb#252
  def rewrite; end

  # Swaps sources at the given ranges.
  #
  # @param node_or_range1 [Parser::Source::Range, RuboCop::AST::Node]
  # @param node_or_range2 [Parser::Source::Range, RuboCop::AST::Node]
  #
  # source://rubocop//lib/rubocop/cop/corrector.rb#85
  def swap(node_or_range1, node_or_range2); end

  private

  # source://rubocop//lib/rubocop/cop/corrector.rb#119
  def check_range_validity(node_or_range); end

  # source://rubocop//lib/rubocop/cop/corrector.rb#104
  def to_range(node_or_range); end

  # source://rubocop//lib/rubocop/cop/corrector.rb#123
  def validate_buffer(buffer); end

  class << self
    # Duck typing for get to a ::Parser::Source::Buffer
    #
    # source://rubocop//lib/rubocop/cop/corrector.rb#15
    def source_buffer(source); end
  end
end

# noop
#
# source://rubocop//lib/rubocop/cop/corrector.rb#12
RuboCop::Cop::Corrector::NOOP_CONSUMER = T.let(T.unsafe(nil), Proc)

# Common functionality for checking def nodes.
#
# source://rubocop//lib/rubocop/cop/mixin/def_node.rb#6
module RuboCop::Cop::DefNode
  include ::RuboCop::Cop::VisibilityHelp
  extend ::RuboCop::AST::NodePattern::Macros

  # source://rubocop//lib/rubocop/cop/mixin/def_node.rb#21
  def non_public_modifier?(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/def_node.rb#12
  def non_public?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/def_node.rb#16
  def preceding_non_public_modifier?(node); end
end

# Helpers for builtin documentation
#
# source://rubocop//lib/rubocop/cop/documentation.rb#6
module RuboCop::Cop::Documentation
  private

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/documentation.rb#24
  def base_url_for(cop_class, config); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/documentation.rb#34
  def default_base_url; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/documentation.rb#10
  def department_to_basename(department); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/documentation.rb#15
  def url_for(cop_class, config = T.unsafe(nil)); end

  class << self
    # @api private
    #
    # source://rubocop//lib/rubocop/cop/documentation.rb#24
    def base_url_for(cop_class, config); end

    # @api private
    #
    # source://rubocop//lib/rubocop/cop/documentation.rb#34
    def default_base_url; end

    # @api private
    #
    # source://rubocop//lib/rubocop/cop/documentation.rb#10
    def department_to_basename(department); end

    # @api private
    #
    # source://rubocop//lib/rubocop/cop/documentation.rb#15
    def url_for(cop_class, config = T.unsafe(nil)); end
  end
end

# Common functionality for checking documentation.
#
# source://rubocop//lib/rubocop/cop/mixin/documentation_comment.rb#6
module RuboCop::Cop::DocumentationComment
  extend ::RuboCop::AST::NodePattern::Macros

  private

  # source://rubocop//lib/rubocop/cop/mixin/documentation_comment.rb#47
  def annotation_keywords; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/documentation_comment.rb#11
  def documentation_comment?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/documentation_comment.rb#39
  def interpreter_directive_comment?(comment); end

  # The args node1 & node2 may represent a RuboCop::AST::Node
  # or a Parser::Source::Comment. Both respond to #loc.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/documentation_comment.rb#31
  def precede?(node1, node2); end

  # The args node1 & node2 may represent a RuboCop::AST::Node
  # or a Parser::Source::Comment. Both respond to #loc.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/documentation_comment.rb#25
  def preceding_comment?(node1, node2); end

  # source://rubocop//lib/rubocop/cop/mixin/documentation_comment.rb#35
  def preceding_lines(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/documentation_comment.rb#43
  def rubocop_directive_comment?(comment); end
end

# Common functionality for dealing with duplication.
#
# source://rubocop//lib/rubocop/cop/mixin/duplication.rb#6
module RuboCop::Cop::Duplication
  private

  # Returns the consecutive duplicates, leaving out the first instance of
  # the duplicated elements.
  #
  # @param collection [Array] an array to return consecutive duplicates for
  # @return [Array] the consecutive duplicates
  #
  # source://rubocop//lib/rubocop/cop/mixin/duplication.rb#31
  def consecutive_duplicates(collection); end

  # Returns all duplicates, including the first instance of the duplicated
  # elements.
  #
  # @param collection [Array] an array to return duplicates for
  # @return [Array] all the duplicates
  #
  # source://rubocop//lib/rubocop/cop/mixin/duplication.rb#22
  def duplicates(collection); end

  # Whether the `collection` contains any duplicates.
  #
  # @param collection [Array] an array to check for duplicates
  # @return [Boolean] whether the array contains any duplicates
  #
  # source://rubocop//lib/rubocop/cop/mixin/duplication.rb#13
  def duplicates?(collection); end

  # Returns a hash of grouped duplicates. The key will be the first
  # instance of the element, and  the value an `array` of the initial
  # element and all duplicate instances.
  #
  # @param collection [Array] an array to group duplicates for
  # @return [Array] the grouped duplicates
  #
  # source://rubocop//lib/rubocop/cop/mixin/duplication.rb#41
  def grouped_duplicates(collection); end
end

# This class autocorrects `#each` enumeration to `for` iteration.
#
# source://rubocop//lib/rubocop/cop/correctors/each_to_for_corrector.rb#6
class RuboCop::Cop::EachToForCorrector
  extend ::RuboCop::AST::NodePattern::Macros

  # @return [EachToForCorrector] a new instance of EachToForCorrector
  #
  # source://rubocop//lib/rubocop/cop/correctors/each_to_for_corrector.rb#12
  def initialize(block_node); end

  # source://rubocop//lib/rubocop/cop/correctors/each_to_for_corrector.rb#18
  def call(corrector); end

  private

  # Returns the value of attribute argument_node.
  #
  # source://rubocop//lib/rubocop/cop/correctors/each_to_for_corrector.rb#24
  def argument_node; end

  # Returns the value of attribute block_node.
  #
  # source://rubocop//lib/rubocop/cop/correctors/each_to_for_corrector.rb#24
  def block_node; end

  # Returns the value of attribute collection_node.
  #
  # source://rubocop//lib/rubocop/cop/correctors/each_to_for_corrector.rb#24
  def collection_node; end

  # source://rubocop//lib/rubocop/cop/correctors/each_to_for_corrector.rb#26
  def correction; end

  # source://rubocop//lib/rubocop/cop/correctors/each_to_for_corrector.rb#36
  def offending_range; end

  # source://rubocop//lib/rubocop/cop/correctors/each_to_for_corrector.rb#44
  def replacement_range(end_pos); end
end

# source://rubocop//lib/rubocop/cop/correctors/each_to_for_corrector.rb#10
RuboCop::Cop::EachToForCorrector::CORRECTION_WITHOUT_ARGUMENTS = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/correctors/each_to_for_corrector.rb#9
RuboCop::Cop::EachToForCorrector::CORRECTION_WITH_ARGUMENTS = T.let(T.unsafe(nil), String)

# This class does empty line autocorrection
#
# source://rubocop//lib/rubocop/cop/correctors/empty_line_corrector.rb#6
class RuboCop::Cop::EmptyLineCorrector
  class << self
    # source://rubocop//lib/rubocop/cop/correctors/empty_line_corrector.rb#8
    def correct(corrector, node); end

    # source://rubocop//lib/rubocop/cop/correctors/empty_line_corrector.rb#19
    def insert_before(corrector, node); end
  end
end

# Common code for empty parameter cops.
#
# source://rubocop//lib/rubocop/cop/mixin/empty_parameter.rb#6
module RuboCop::Cop::EmptyParameter
  extend ::RuboCop::AST::NodePattern::Macros

  # source://rubocop//lib/rubocop/cop/mixin/empty_parameter.rb#12
  def empty_arguments?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/mixin/empty_parameter.rb#16
  def check(node); end
end

# Functions for checking the alignment of the `end` keyword.
#
# source://rubocop//lib/rubocop/cop/mixin/end_keyword_alignment.rb#6
module RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/end_keyword_alignment.rb#60
  def accept_end_kw_alignment?(end_loc); end

  # source://rubocop//lib/rubocop/cop/mixin/end_keyword_alignment.rb#50
  def add_offense_for_misalignment(node, align_with); end

  # source://rubocop//lib/rubocop/cop/mixin/end_keyword_alignment.rb#19
  def check_end_kw_alignment(node, align_ranges); end

  # source://rubocop//lib/rubocop/cop/mixin/end_keyword_alignment.rb#15
  def check_end_kw_in_node(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/end_keyword_alignment.rb#75
  def line_break_before_keyword?(whole_expression, rhs); end

  # source://rubocop//lib/rubocop/cop/mixin/end_keyword_alignment.rb#35
  def matching_ranges(end_loc, align_ranges); end

  # source://rubocop//lib/rubocop/cop/mixin/end_keyword_alignment.rb#41
  def start_line_range(node); end

  # source://rubocop//lib/rubocop/cop/mixin/end_keyword_alignment.rb#65
  def style_parameter_name; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/end_keyword_alignment.rb#69
  def variable_alignment?(whole_expression, rhs, end_alignment_style); end
end

# source://rubocop//lib/rubocop/cop/mixin/end_keyword_alignment.rb#10
RuboCop::Cop::EndKeywordAlignment::MSG = T.let(T.unsafe(nil), String)

# Common functionality for enforcing a specific superclass.
#
# IMPORTANT: RuboCop core depended on this module when it supported Rails department.
# Rails department has been extracted to RuboCop Rails gem.
#
# It will not be updated to `RuboCop::Cop::Base` v1 API to maintain compatibility
# with existing RuboCop Rails 2.8 or lower.
#
# @api private
# @deprecated This module is deprecated and will be removed by RuboCop 2.0.
#
# source://rubocop//lib/rubocop/cop/mixin/enforce_superclass.rb#15
module RuboCop::Cop::EnforceSuperclass
  # @api private
  #
  # source://rubocop//lib/rubocop/cop/mixin/enforce_superclass.rb#35
  def on_class(node); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/mixin/enforce_superclass.rb#39
  def on_send(node); end

  class << self
    # @api private
    # @private
    #
    # source://rubocop//lib/rubocop/cop/mixin/enforce_superclass.rb#16
    def included(base); end
  end
end

# Common functionality for checking for a line break before the first
# element in a multi-line collection.
#
# source://rubocop//lib/rubocop/cop/mixin/first_element_line_break.rb#7
module RuboCop::Cop::FirstElementLineBreak
  private

  # source://rubocop//lib/rubocop/cop/mixin/first_element_line_break.rb#23
  def check_children_line_break(node, children, start = T.unsafe(nil), ignore_last: T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/mixin/first_element_line_break.rb#10
  def check_method_line_break(node, children, ignore_last: T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/mixin/first_element_line_break.rb#37
  def first_by_line(nodes); end

  # source://rubocop//lib/rubocop/cop/mixin/first_element_line_break.rb#41
  def last_line(nodes, ignore_last:); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/first_element_line_break.rb#18
  def method_uses_parens?(node, limit); end
end

# This class autocorrects `for` iteration to `#each` enumeration.
#
# source://rubocop//lib/rubocop/cop/correctors/for_to_each_corrector.rb#6
class RuboCop::Cop::ForToEachCorrector
  extend ::RuboCop::AST::NodePattern::Macros

  # @return [ForToEachCorrector] a new instance of ForToEachCorrector
  #
  # source://rubocop//lib/rubocop/cop/correctors/for_to_each_corrector.rb#11
  def initialize(for_node); end

  # source://rubocop//lib/rubocop/cop/correctors/for_to_each_corrector.rb#17
  def call(corrector); end

  private

  # source://rubocop//lib/rubocop/cop/correctors/for_to_each_corrector.rb#55
  def collection_end; end

  # Returns the value of attribute collection_node.
  #
  # source://rubocop//lib/rubocop/cop/correctors/for_to_each_corrector.rb#23
  def collection_node; end

  # source://rubocop//lib/rubocop/cop/correctors/for_to_each_corrector.rb#29
  def collection_source; end

  # source://rubocop//lib/rubocop/cop/correctors/for_to_each_corrector.rb#25
  def correction; end

  # source://rubocop//lib/rubocop/cop/correctors/for_to_each_corrector.rb#43
  def end_position; end

  # Returns the value of attribute for_node.
  #
  # source://rubocop//lib/rubocop/cop/correctors/for_to_each_corrector.rb#23
  def for_node; end

  # source://rubocop//lib/rubocop/cop/correctors/for_to_each_corrector.rb#51
  def keyword_begin; end

  # source://rubocop//lib/rubocop/cop/correctors/for_to_each_corrector.rb#63
  def offending_range; end

  # source://rubocop//lib/rubocop/cop/correctors/for_to_each_corrector.rb#67
  def replacement_range(end_pos); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/correctors/for_to_each_corrector.rb#37
  def requires_parentheses?; end

  # Returns the value of attribute variable_node.
  #
  # source://rubocop//lib/rubocop/cop/correctors/for_to_each_corrector.rb#23
  def variable_node; end
end

# source://rubocop//lib/rubocop/cop/correctors/for_to_each_corrector.rb#9
RuboCop::Cop::ForToEachCorrector::CORRECTION = T.let(T.unsafe(nil), String)

# A scaffold for concrete forces.
#
# source://rubocop//lib/rubocop/cop/force.rb#6
class RuboCop::Cop::Force
  # @return [Force] a new instance of Force
  #
  # source://rubocop//lib/rubocop/cop/force.rb#22
  def initialize(cops); end

  # Returns the value of attribute cops.
  #
  # source://rubocop//lib/rubocop/cop/force.rb#7
  def cops; end

  # source://rubocop//lib/rubocop/cop/force.rb#38
  def investigate(_processed_source); end

  # source://rubocop//lib/rubocop/cop/force.rb#26
  def name; end

  # source://rubocop//lib/rubocop/cop/force.rb#30
  def run_hook(method_name, *args); end

  class << self
    # source://rubocop//lib/rubocop/cop/force.rb#9
    def all; end

    # source://rubocop//lib/rubocop/cop/force.rb#18
    def force_name; end

    # @private
    #
    # source://rubocop//lib/rubocop/cop/force.rb#13
    def inherited(subclass); end
  end
end

# Common functionality for dealing with frozen string literals.
#
# source://rubocop//lib/rubocop/cop/mixin/frozen_string_literal.rb#6
module RuboCop::Cop::FrozenStringLiteral
  private

  # source://rubocop//lib/rubocop/cop/mixin/frozen_string_literal.rb#35
  def frozen_heredoc?(node); end

  # source://rubocop//lib/rubocop/cop/mixin/frozen_string_literal.rb#21
  def frozen_string_literal?(node); end

  # source://rubocop//lib/rubocop/cop/mixin/frozen_string_literal.rb#15
  def frozen_string_literal_comment_exists?; end

  # source://rubocop//lib/rubocop/cop/mixin/frozen_string_literal.rb#66
  def frozen_string_literal_specified?; end

  # source://rubocop//lib/rubocop/cop/mixin/frozen_string_literal.rb#60
  def frozen_string_literals_disabled?; end

  # source://rubocop//lib/rubocop/cop/mixin/frozen_string_literal.rb#41
  def frozen_string_literals_enabled?; end

  # source://rubocop//lib/rubocop/cop/mixin/frozen_string_literal.rb#76
  def leading_comment_lines; end

  # source://rubocop//lib/rubocop/cop/mixin/frozen_string_literal.rb#72
  def leading_magic_comments; end

  # source://rubocop//lib/rubocop/cop/mixin/frozen_string_literal.rb#31
  def uninterpolated_string?(node); end

  class << self
    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/cop/mixin/frozen_string_literal.rb#15
    def frozen_string_literal_comment_exists?; end
  end
end

# source://rubocop//lib/rubocop/cop/mixin/frozen_string_literal.rb#9
RuboCop::Cop::FrozenStringLiteral::FROZEN_STRING_LITERAL = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/mixin/frozen_string_literal.rb#10
RuboCop::Cop::FrozenStringLiteral::FROZEN_STRING_LITERAL_ENABLED = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/mixin/frozen_string_literal.rb#11
RuboCop::Cop::FrozenStringLiteral::FROZEN_STRING_LITERAL_TYPES_RUBY27 = T.let(T.unsafe(nil), Array)

# Common functionality for checking gem declarations.
#
# source://rubocop//lib/rubocop/cop/mixin/gem_declaration.rb#6
module RuboCop::Cop::GemDeclaration
  extend ::RuboCop::AST::NodePattern::Macros

  # source://rubocop//lib/rubocop/cop/mixin/gem_declaration.rb#10
  def gem_declaration?(param0 = T.unsafe(nil)); end
end

# source://rubocop//lib/rubocop/cop/gemspec/dependency_version.rb#5
module RuboCop::Cop::Gemspec; end

# Enforce that gem dependency version specifications or a commit reference (branch,
# ref, or tag) are either required or forbidden.
#
# @example EnforcedStyle: required (default)
#
#   # bad
#   Gem::Specification.new do |spec|
#   spec.add_dependency 'parser'
#   end
#
#   # bad
#   Gem::Specification.new do |spec|
#   spec.add_development_dependency 'parser'
#   end
#
#   # good
#   Gem::Specification.new do |spec|
#   spec.add_dependency 'parser', '>= 2.3.3.1', '< 3.0'
#   end
#
#   # good
#   Gem::Specification.new do |spec|
#   spec.add_development_dependency 'parser', '>= 2.3.3.1', '< 3.0'
#   end
# @example EnforcedStyle: forbidden
#
#   # bad
#   Gem::Specification.new do |spec|
#   spec.add_dependency 'parser', '>= 2.3.3.1', '< 3.0'
#   end
#
#   # bad
#   Gem::Specification.new do |spec|
#   spec.add_development_dependency 'parser', '>= 2.3.3.1', '< 3.0'
#   end
#
#   # good
#   Gem::Specification.new do |spec|
#   spec.add_dependency 'parser'
#   end
#
#   # good
#   Gem::Specification.new do |spec|
#   spec.add_development_dependency 'parser'
#   end
#
# source://rubocop//lib/rubocop/cop/gemspec/dependency_version.rb#53
class RuboCop::Cop::Gemspec::DependencyVersion < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::GemspecHelp

  # source://rubocop//lib/rubocop/cop/gemspec/dependency_version.rb#67
  def add_dependency_method_declaration?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/gemspec/dependency_version.rb#78
  def includes_commit_reference?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/gemspec/dependency_version.rb#73
  def includes_version_specification?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/gemspec/dependency_version.rb#82
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/gemspec/dependency_version.rb#120
  def add_dependency_method?(method_name); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/gemspec/dependency_version.rb#96
  def allowed_gem?(node); end

  # source://rubocop//lib/rubocop/cop/gemspec/dependency_version.rb#100
  def allowed_gems; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/gemspec/dependency_version.rb#134
  def forbidden_offense?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/gemspec/dependency_version.rb#140
  def forbidden_style?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/gemspec/dependency_version.rb#114
  def match_block_variable_name?(receiver_name); end

  # source://rubocop//lib/rubocop/cop/gemspec/dependency_version.rb#104
  def message(range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/gemspec/dependency_version.rb#124
  def offense?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/gemspec/dependency_version.rb#128
  def required_offense?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/gemspec/dependency_version.rb#144
  def required_style?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/gemspec/dependency_version.rb#148
  def version_specification?(expression); end
end

# source://rubocop//lib/rubocop/cop/gemspec/dependency_version.rb#61
RuboCop::Cop::Gemspec::DependencyVersion::ADD_DEPENDENCY_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/gemspec/dependency_version.rb#58
RuboCop::Cop::Gemspec::DependencyVersion::FORBIDDEN_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/gemspec/dependency_version.rb#57
RuboCop::Cop::Gemspec::DependencyVersion::REQUIRED_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/gemspec/dependency_version.rb#64
RuboCop::Cop::Gemspec::DependencyVersion::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/gemspec/dependency_version.rb#59
RuboCop::Cop::Gemspec::DependencyVersion::VERSION_SPECIFICATION_REGEX = T.let(T.unsafe(nil), Regexp)

# Checks that deprecated attribute attributes are not set in a gemspec file.
# Removing deprecated attributes allows the user to receive smaller packed gems.
#
# @example
#
#   # bad
#   Gem::Specification.new do |spec|
#   spec.name = 'your_cool_gem_name'
#   spec.test_files = Dir.glob('test/**/*')
#   end
#
#   # bad
#   Gem::Specification.new do |spec|
#   spec.name = 'your_cool_gem_name'
#   spec.test_files += Dir.glob('test/**/*')
#   end
#
#   # good
#   Gem::Specification.new do |spec|
#   spec.name = 'your_cool_gem_name'
#   end
#
# source://rubocop//lib/rubocop/cop/gemspec/deprecated_attribute_assignment.rb#28
class RuboCop::Cop::Gemspec::DeprecatedAttributeAssignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/gemspec/deprecated_attribute_assignment.rb#35
  def gem_specification(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/gemspec/deprecated_attribute_assignment.rb#43
  def on_block(block_node); end

  private

  # source://rubocop//lib/rubocop/cop/gemspec/deprecated_attribute_assignment.rb#86
  def format_message_from; end

  # source://rubocop//lib/rubocop/cop/gemspec/deprecated_attribute_assignment.rb#63
  def node_and_method_name(node, attribute); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/gemspec/deprecated_attribute_assignment.rb#72
  def use_deprecated_attributes?(node, block_parameter); end
end

# source://rubocop//lib/rubocop/cop/gemspec/deprecated_attribute_assignment.rb#32
RuboCop::Cop::Gemspec::DeprecatedAttributeAssignment::MSG = T.let(T.unsafe(nil), String)

# Enforce that development dependencies for a gem are specified in
# `Gemfile`, rather than in the `gemspec` using
# `add_development_dependency`. Alternatively, using `EnforcedStyle:
# gemspec`, enforce that all dependencies are specified in `gemspec`,
# rather than in `Gemfile`.
#
# @example EnforcedStyle: Gemfile (default)
#   # Specify runtime dependencies in your gemspec,
#   # but all other dependencies in your Gemfile.
#
#   # bad
#   # example.gemspec
#   s.add_development_dependency "foo"
#
#   # good
#   # Gemfile
#   gem "foo"
#
#   # good
#   # gems.rb
#   gem "foo"
#
#   # good (with AllowedGems: ["bar"])
#   # example.gemspec
#   s.add_development_dependency "bar"
# @example EnforcedStyle: gems.rb
#   # Specify runtime dependencies in your gemspec,
#   # but all other dependencies in your Gemfile.
#   #
#   # Identical to `EnforcedStyle: Gemfile`, but with a different error message.
#   # Rely on Bundler/GemFilename to enforce the use of `Gemfile` vs `gems.rb`.
#
#   # bad
#   # example.gemspec
#   s.add_development_dependency "foo"
#
#   # good
#   # Gemfile
#   gem "foo"
#
#   # good
#   # gems.rb
#   gem "foo"
#
#   # good (with AllowedGems: ["bar"])
#   # example.gemspec
#   s.add_development_dependency "bar"
# @example EnforcedStyle: gemspec
#   # Specify all dependencies in your gemspec.
#
#   # bad
#   # Gemfile
#   gem "foo"
#
#   # good
#   # example.gemspec
#   s.add_development_dependency "foo"
#
#   # good (with AllowedGems: ["bar"])
#   # Gemfile
#   gem "bar"
#
# source://rubocop//lib/rubocop/cop/gemspec/development_dependencies.rb#70
class RuboCop::Cop::Gemspec::DevelopmentDependencies < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop//lib/rubocop/cop/gemspec/development_dependencies.rb#77
  def add_development_dependency?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/gemspec/development_dependencies.rb#82
  def gem?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/gemspec/development_dependencies.rb#86
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/gemspec/development_dependencies.rb#97
  def forbidden_gem?(gem_name); end

  # source://rubocop//lib/rubocop/cop/gemspec/development_dependencies.rb#101
  def message(_range); end
end

# source://rubocop//lib/rubocop/cop/gemspec/development_dependencies.rb#73
RuboCop::Cop::Gemspec::DevelopmentDependencies::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/gemspec/development_dependencies.rb#74
RuboCop::Cop::Gemspec::DevelopmentDependencies::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# An attribute assignment method calls should be listed only once
# in a gemspec.
#
# Assigning to an attribute with the same name using `spec.foo =` will be
# an unintended usage. On the other hand, duplication of methods such
# as `spec.requirements`, `spec.add_runtime_dependency`, and others are
# permitted because it is the intended use of appending values.
#
# @example
#   # bad
#   Gem::Specification.new do |spec|
#   spec.name = 'rubocop'
#   spec.name = 'rubocop2'
#   end
#
#   # good
#   Gem::Specification.new do |spec|
#   spec.name = 'rubocop'
#   end
#
#   # good
#   Gem::Specification.new do |spec|
#   spec.requirements << 'libmagick, v6.0'
#   spec.requirements << 'A good graphics card'
#   end
#
#   # good
#   Gem::Specification.new do |spec|
#   spec.add_runtime_dependency('parallel', '~> 1.10')
#   spec.add_runtime_dependency('parser', '>= 2.3.3.1', '< 3.0')
#   end
#
# source://rubocop//lib/rubocop/cop/gemspec/duplicated_assignment.rb#37
class RuboCop::Cop::Gemspec::DuplicatedAssignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::GemspecHelp

  # source://rubocop//lib/rubocop/cop/gemspec/duplicated_assignment.rb#45
  def assignment_method_declarations(param0); end

  # source://rubocop//lib/rubocop/cop/gemspec/duplicated_assignment.rb#50
  def on_new_investigation; end

  private

  # source://rubocop//lib/rubocop/cop/gemspec/duplicated_assignment.rb#68
  def duplicated_assignment_method_nodes; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/gemspec/duplicated_assignment.rb#62
  def match_block_variable_name?(receiver_name); end

  # source://rubocop//lib/rubocop/cop/gemspec/duplicated_assignment.rb#76
  def register_offense(node, assignment, line_of_first_occurrence); end
end

# source://rubocop//lib/rubocop/cop/gemspec/duplicated_assignment.rb#41
RuboCop::Cop::Gemspec::DuplicatedAssignment::MSG = T.let(T.unsafe(nil), String)

# Dependencies in the gemspec should be alphabetically sorted.
#
# @example
#   # bad
#   spec.add_dependency 'rubocop'
#   spec.add_dependency 'rspec'
#
#   # good
#   spec.add_dependency 'rspec'
#   spec.add_dependency 'rubocop'
#
#   # good
#   spec.add_dependency 'rubocop'
#
#   spec.add_dependency 'rspec'
#
#   # bad
#   spec.add_development_dependency 'rubocop'
#   spec.add_development_dependency 'rspec'
#
#   # good
#   spec.add_development_dependency 'rspec'
#   spec.add_development_dependency 'rubocop'
#
#   # good
#   spec.add_development_dependency 'rubocop'
#
#   spec.add_development_dependency 'rspec'
#
#   # bad
#   spec.add_runtime_dependency 'rubocop'
#   spec.add_runtime_dependency 'rspec'
#
#   # good
#   spec.add_runtime_dependency 'rspec'
#   spec.add_runtime_dependency 'rubocop'
#
#   # good
#   spec.add_runtime_dependency 'rubocop'
#
#   spec.add_runtime_dependency 'rspec'
#
#   # good only if TreatCommentsAsGroupSeparators is true
#   # For code quality
#   spec.add_dependency 'rubocop'
#   # For tests
#   spec.add_dependency 'rspec'
#
# source://rubocop//lib/rubocop/cop/gemspec/ordered_dependencies.rb#53
class RuboCop::Cop::Gemspec::OrderedDependencies < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::OrderedGemNode
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/gemspec/ordered_dependencies.rb#87
  def dependency_declarations(param0); end

  # source://rubocop//lib/rubocop/cop/gemspec/ordered_dependencies.rb#61
  def on_new_investigation; end

  private

  # source://rubocop//lib/rubocop/cop/gemspec/ordered_dependencies.rb#82
  def get_dependency_name(node); end

  # source://rubocop//lib/rubocop/cop/gemspec/ordered_dependencies.rb#76
  def previous_declaration(node); end
end

# source://rubocop//lib/rubocop/cop/gemspec/ordered_dependencies.rb#57
RuboCop::Cop::Gemspec::OrderedDependencies::MSG = T.let(T.unsafe(nil), String)

# Requires a gemspec to have `rubygems_mfa_required` metadata set.
#
# This setting tells RubyGems that MFA (Multi-Factor Authentication) is
# required for accounts to be able perform privileged operations, such as
# (see RubyGems' documentation for the full list of privileged
# operations):
#
# * `gem push`
# * `gem yank`
# * `gem owner --add/remove`
# * adding or removing owners using gem ownership page
#
# This helps make your gem more secure, as users can be more
# confident that gem updates were pushed by maintainers.
#
# @example
#   # bad
#   Gem::Specification.new do |spec|
#   # no `rubygems_mfa_required` metadata specified
#   end
#
#   # good
#   Gem::Specification.new do |spec|
#   spec.metadata = {
#   'rubygems_mfa_required' => 'true'
#   }
#   end
#
#   # good
#   Gem::Specification.new do |spec|
#   spec.metadata['rubygems_mfa_required'] = 'true'
#   end
#
#   # bad
#   Gem::Specification.new do |spec|
#   spec.metadata = {
#   'rubygems_mfa_required' => 'false'
#   }
#   end
#
#   # good
#   Gem::Specification.new do |spec|
#   spec.metadata = {
#   'rubygems_mfa_required' => 'true'
#   }
#   end
#
#   # bad
#   Gem::Specification.new do |spec|
#   spec.metadata['rubygems_mfa_required'] = 'false'
#   end
#
#   # good
#   Gem::Specification.new do |spec|
#   spec.metadata['rubygems_mfa_required'] = 'true'
#   end
#
# source://rubocop//lib/rubocop/cop/gemspec/require_mfa.rb#63
class RuboCop::Cop::Gemspec::RequireMFA < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::GemspecHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/gemspec/require_mfa.rb#70
  def metadata(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/gemspec/require_mfa.rb#87
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/gemspec/require_mfa.rb#78
  def rubygems_mfa_required(param0); end

  # source://rubocop//lib/rubocop/cop/gemspec/require_mfa.rb#83
  def true_string?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/gemspec/require_mfa.rb#115
  def autocorrect(corrector, node, block_var, metadata); end

  # source://rubocop//lib/rubocop/cop/gemspec/require_mfa.rb#139
  def change_value(corrector, value); end

  # source://rubocop//lib/rubocop/cop/gemspec/require_mfa.rb#125
  def correct_metadata(corrector, metadata); end

  # source://rubocop//lib/rubocop/cop/gemspec/require_mfa.rb#133
  def insert_mfa_required(corrector, node, block_var); end

  # source://rubocop//lib/rubocop/cop/gemspec/require_mfa.rb#108
  def mfa_value(metadata_value); end
end

# source://rubocop//lib/rubocop/cop/gemspec/require_mfa.rb#67
RuboCop::Cop::Gemspec::RequireMFA::MSG = T.let(T.unsafe(nil), String)

# Checks that `required_ruby_version` in a gemspec file is set to a valid
# value (non-blank) and matches `TargetRubyVersion` as set in RuboCop's
# configuration for the gem.
#
# This ensures that RuboCop is using the same Ruby version as the gem.
#
# @example
#   # When `TargetRubyVersion` of .rubocop.yml is `2.5`.
#
#   # bad
#   Gem::Specification.new do |spec|
#   # no `required_ruby_version` specified
#   end
#
#   # bad
#   Gem::Specification.new do |spec|
#   spec.required_ruby_version = '>= 2.4.0'
#   end
#
#   # bad
#   Gem::Specification.new do |spec|
#   spec.required_ruby_version = '>= 2.6.0'
#   end
#
#   # bad
#   Gem::Specification.new do |spec|
#   spec.required_ruby_version = ''
#   end
#
#   # good
#   Gem::Specification.new do |spec|
#   spec.required_ruby_version = '>= 2.5.0'
#   end
#
#   # good
#   Gem::Specification.new do |spec|
#   spec.required_ruby_version = '>= 2.5'
#   end
#
#   # accepted but not recommended
#   Gem::Specification.new do |spec|
#   spec.required_ruby_version = ['>= 2.5.0', '< 2.7.0']
#   end
#
#   # accepted but not recommended, since
#   # Ruby does not really follow semantic versioning
#   Gem::Specification.new do |spec|
#   spec.required_ruby_version = '~> 2.5'
#   end
#
# source://rubocop//lib/rubocop/cop/gemspec/required_ruby_version.rb#55
class RuboCop::Cop::Gemspec::RequiredRubyVersion < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/gemspec/required_ruby_version.rb#70
  def defined_ruby_version(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/gemspec/required_ruby_version.rb#78
  def on_new_investigation; end

  # source://rubocop//lib/rubocop/cop/gemspec/required_ruby_version.rb#82
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/gemspec/required_ruby_version.rb#65
  def required_ruby_version?(param0); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/gemspec/required_ruby_version.rb#94
  def dynamic_version?(node); end

  # source://rubocop//lib/rubocop/cop/gemspec/required_ruby_version.rb#100
  def extract_ruby_version(required_ruby_version); end

  # source://rubocop//lib/rubocop/cop/gemspec/required_ruby_version.rb#116
  def not_equal_message(required_ruby_version, target_ruby_version); end
end

# source://rubocop//lib/rubocop/cop/gemspec/required_ruby_version.rb#62
RuboCop::Cop::Gemspec::RequiredRubyVersion::MISSING_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/gemspec/required_ruby_version.rb#59
RuboCop::Cop::Gemspec::RequiredRubyVersion::NOT_EQUAL_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/gemspec/required_ruby_version.rb#58
RuboCop::Cop::Gemspec::RequiredRubyVersion::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks that `RUBY_VERSION` constant is not used in gemspec.
# Using `RUBY_VERSION` is dangerous because value of the
# constant is determined by `rake release`.
# It's possible to have dependency based on ruby version used
# to execute `rake release` and not user's ruby version.
#
# @example
#
#   # bad
#   Gem::Specification.new do |spec|
#   if RUBY_VERSION >= '3.0'
#   spec.add_runtime_dependency 'gem_a'
#   else
#   spec.add_runtime_dependency 'gem_b'
#   end
#   end
#
#   # good
#   Gem::Specification.new do |spec|
#   spec.add_runtime_dependency 'gem_a'
#   end
#
# source://rubocop//lib/rubocop/cop/gemspec/ruby_version_globals_usage.rb#28
class RuboCop::Cop::Gemspec::RubyVersionGlobalsUsage < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::GemspecHelp

  # source://rubocop//lib/rubocop/cop/gemspec/ruby_version_globals_usage.rb#36
  def on_const(node); end

  # source://rubocop//lib/rubocop/cop/gemspec/ruby_version_globals_usage.rb#34
  def ruby_version?(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/gemspec/ruby_version_globals_usage.rb#44
  def gem_spec_with_ruby_version?(node); end
end

# source://rubocop//lib/rubocop/cop/gemspec/ruby_version_globals_usage.rb#31
RuboCop::Cop::Gemspec::RubyVersionGlobalsUsage::MSG = T.let(T.unsafe(nil), String)

# Common functionality for checking gem declarations.
#
# source://rubocop//lib/rubocop/cop/mixin/gemspec_help.rb#6
module RuboCop::Cop::GemspecHelp
  extend ::RuboCop::AST::NodePattern::Macros

  # source://rubocop//lib/rubocop/cop/mixin/gemspec_help.rb#20
  def gem_specification(param0); end

  # source://rubocop//lib/rubocop/cop/mixin/gemspec_help.rb#10
  def gem_specification?(param0 = T.unsafe(nil)); end
end

# Source and spec generator for new cops
#
# This generator will take a cop name and generate a source file
# and spec file when given a valid qualified cop name.
#
# @api private
#
# source://rubocop//lib/rubocop/cop/generator.rb#10
class RuboCop::Cop::Generator
  # @api private
  # @raise [ArgumentError]
  # @return [Generator] a new instance of Generator
  #
  # source://rubocop//lib/rubocop/cop/generator.rb#113
  def initialize(name, output: T.unsafe(nil)); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/generator.rb#133
  def inject_config(config_file_path: T.unsafe(nil), version_added: T.unsafe(nil)); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/generator.rb#129
  def inject_require(root_file_path: T.unsafe(nil)); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/generator.rb#146
  def todo; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/generator.rb#121
  def write_source; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/generator.rb#125
  def write_spec; end

  private

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/generator.rb#160
  def badge; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/generator.rb#183
  def generate(template); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/generator.rb#175
  def generated_source; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/generator.rb#179
  def generated_spec; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/generator.rb#160
  def output; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/generator.rb#208
  def snake_case(camel_case_string); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/generator.rb#198
  def source_path; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/generator.rb#188
  def spec_path; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/generator.rb#162
  def write_unless_file_exists(path, contents); end
end

# @api private
#
# source://rubocop//lib/rubocop/cop/generator.rb#109
RuboCop::Cop::Generator::CONFIGURATION_ADDED_MESSAGE = T.let(T.unsafe(nil), String)

# A class that injects a require directive into the root RuboCop file.
# It looks for other directives that require files in the same (cop)
# namespace and injects the provided one in alpha
#
# source://rubocop//lib/rubocop/cop/generator/configuration_injector.rb#9
class RuboCop::Cop::Generator::ConfigurationInjector
  # @return [ConfigurationInjector] a new instance of ConfigurationInjector
  #
  # source://rubocop//lib/rubocop/cop/generator/configuration_injector.rb#17
  def initialize(configuration_file_path:, badge:, version_added: T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/generator/configuration_injector.rb#24
  def inject; end

  private

  # Returns the value of attribute badge.
  #
  # source://rubocop//lib/rubocop/cop/generator/configuration_injector.rb#39
  def badge; end

  # source://rubocop//lib/rubocop/cop/generator/configuration_injector.rb#41
  def configuration_entries; end

  # Returns the value of attribute configuration_file_path.
  #
  # source://rubocop//lib/rubocop/cop/generator/configuration_injector.rb#39
  def configuration_file_path; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/generator/configuration_injector.rb#59
  def cop_name_line?(yaml); end

  # source://rubocop//lib/rubocop/cop/generator/configuration_injector.rb#49
  def find_target_line; end

  # source://rubocop//lib/rubocop/cop/generator/configuration_injector.rb#45
  def new_configuration_entry; end

  # Returns the value of attribute output.
  #
  # source://rubocop//lib/rubocop/cop/generator/configuration_injector.rb#39
  def output; end

  # Returns the value of attribute version_added.
  #
  # source://rubocop//lib/rubocop/cop/generator/configuration_injector.rb#39
  def version_added; end
end

# source://rubocop//lib/rubocop/cop/generator/configuration_injector.rb#10
RuboCop::Cop::Generator::ConfigurationInjector::TEMPLATE = T.let(T.unsafe(nil), String)

# A class that injects a require directive into the root RuboCop file.
# It looks for other directives that require files in the same (cop)
# namespace and injects the provided one in alpha
#
# source://rubocop//lib/rubocop/cop/generator/require_file_injector.rb#9
class RuboCop::Cop::Generator::RequireFileInjector
  # @return [RequireFileInjector] a new instance of RequireFileInjector
  #
  # source://rubocop//lib/rubocop/cop/generator/require_file_injector.rb#12
  def initialize(source_path:, root_file_path:, output: T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/generator/require_file_injector.rb#19
  def inject; end

  private

  # source://rubocop//lib/rubocop/cop/generator/require_file_injector.rb#64
  def injectable_require_directive; end

  # Returns the value of attribute output.
  #
  # source://rubocop//lib/rubocop/cop/generator/require_file_injector.rb#29
  def output; end

  # Returns the value of attribute require_entries.
  #
  # source://rubocop//lib/rubocop/cop/generator/require_file_injector.rb#29
  def require_entries; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/generator/require_file_injector.rb#31
  def require_exists?; end

  # source://rubocop//lib/rubocop/cop/generator/require_file_injector.rb#68
  def require_path; end

  # source://rubocop//lib/rubocop/cop/generator/require_file_injector.rb#58
  def require_path_fragments(require_directive); end

  # Returns the value of attribute root_file_path.
  #
  # source://rubocop//lib/rubocop/cop/generator/require_file_injector.rb#29
  def root_file_path; end

  # Returns the value of attribute source_path.
  #
  # source://rubocop//lib/rubocop/cop/generator/require_file_injector.rb#29
  def source_path; end

  # source://rubocop//lib/rubocop/cop/generator/require_file_injector.rb#39
  def target_line; end

  # source://rubocop//lib/rubocop/cop/generator/require_file_injector.rb#35
  def updated_directives; end
end

# source://rubocop//lib/rubocop/cop/generator/require_file_injector.rb#10
RuboCop::Cop::Generator::RequireFileInjector::REQUIRE_PATH = T.let(T.unsafe(nil), Regexp)

# @api private
#
# source://rubocop//lib/rubocop/cop/generator.rb#11
RuboCop::Cop::Generator::SOURCE_TEMPLATE = T.let(T.unsafe(nil), String)

# @api private
#
# source://rubocop//lib/rubocop/cop/generator.rb#85
RuboCop::Cop::Generator::SPEC_TEMPLATE = T.let(T.unsafe(nil), String)

# Common functionality for checking hash alignment.
#
# source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#6
module RuboCop::Cop::HashAlignmentStyles; end

# Handles calculation of deltas when the enforced style is 'key'.
#
# source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#8
class RuboCop::Cop::HashAlignmentStyles::KeyAlignment
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#9
  def checkable_layout?(_node); end

  # source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#20
  def deltas(first_pair, current_pair); end

  # source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#13
  def deltas_for_first_pair(first_pair, _node); end

  private

  # source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#34
  def separator_delta(pair); end

  # source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#45
  def value_delta(pair); end
end

# Handles calculation of deltas for `kwsplat` nodes.
# This is a special case that just ensures the kwsplat is aligned with the rest of the hash
# since a `kwsplat` does not have a key, separator or value.
#
# source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#145
class RuboCop::Cop::HashAlignmentStyles::KeywordSplatAlignment
  # source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#146
  def deltas(first_pair, current_pair); end
end

# Handles calculation of deltas when the enforced style is 'separator'.
#
# source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#120
class RuboCop::Cop::HashAlignmentStyles::SeparatorAlignment
  include ::RuboCop::Cop::HashAlignmentStyles::ValueAlignment

  # source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#123
  def deltas_for_first_pair(*_nodes); end

  private

  # source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#133
  def hash_rocket_delta(first_pair, current_pair); end

  # source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#129
  def key_delta(first_pair, current_pair); end

  # source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#137
  def value_delta(first_pair, current_pair); end
end

# Handles calculation of deltas when the enforced style is 'table'.
#
# source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#81
class RuboCop::Cop::HashAlignmentStyles::TableAlignment
  include ::RuboCop::Cop::HashAlignmentStyles::ValueAlignment

  # @return [TableAlignment] a new instance of TableAlignment
  #
  # source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#84
  def initialize; end

  # source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#88
  def deltas_for_first_pair(first_pair, node); end

  private

  # source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#106
  def hash_rocket_delta(first_pair, current_pair); end

  # source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#102
  def key_delta(first_pair, current_pair); end

  # Returns the value of attribute max_key_width.
  #
  # source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#100
  def max_key_width; end

  # Sets the attribute max_key_width
  #
  # @param value the value to set the attribute max_key_width to.
  #
  # source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#100
  def max_key_width=(_arg0); end

  # source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#110
  def value_delta(first_pair, current_pair); end
end

# Common functionality for checking alignment of hash values.
#
# source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#56
module RuboCop::Cop::HashAlignmentStyles::ValueAlignment
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#57
  def checkable_layout?(node); end

  # source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#61
  def deltas(first_pair, current_pair); end

  private

  # source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#71
  def separator_delta(first_pair, current_pair, key_delta); end
end

# This module checks for Ruby 3.1's hash value omission syntax.
#
# source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#7
module RuboCop::Cop::HashShorthandSyntax
  # source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#14
  def on_hash_for_mixed_shorthand(hash_node); end

  # source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#26
  def on_pair(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#122
  def brackets?(method_dispatch_node); end

  # source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#152
  def breakdown_value_types_of_hash(hash_node); end

  # source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#99
  def def_node_that_require_parentheses(node); end

  # source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#176
  def each_omittable_value_pair(hash_value_type_breakdown, &block); end

  # source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#172
  def each_omitted_value_pair(hash_value_type_breakdown, &block); end

  # source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#77
  def enforced_shorthand_syntax; end

  # source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#114
  def find_ancestor_method_dispatch_node(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#164
  def hash_with_mixed_shorthand_syntax?(hash_value_type_breakdown); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#168
  def hash_with_values_that_cant_be_omitted?(hash_value_type_breakdown); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#71
  def ignore_hash_shorthand_syntax?(pair_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#66
  def ignore_mixed_hash_shorthand_syntax?(hash_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#137
  def last_expression?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#145
  def method_dispatch_as_argument?(method_dispatch_node); end

  # source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#180
  def mixed_shorthand_syntax_check(hash_value_type_breakdown); end

  # source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#196
  def no_mixed_shorthand_syntax_check(hash_value_type_breakdown); end

  # source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#49
  def register_offense(node, message, replacement); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#81
  def require_hash_value?(hash_key_source, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#90
  def require_hash_value_for_around_hash_literal?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#126
  def use_element_of_hash_literal_as_receiver?(ancestor, parent); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#131
  def use_modifier_form_without_parenthesized_method_call?(ancestor); end
end

# source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#12
RuboCop::Cop::HashShorthandSyntax::DO_NOT_MIX_EXPLICIT_VALUE_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#10
RuboCop::Cop::HashShorthandSyntax::DO_NOT_MIX_MSG_PREFIX = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#11
RuboCop::Cop::HashShorthandSyntax::DO_NOT_MIX_OMIT_VALUE_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#206
class RuboCop::Cop::HashShorthandSyntax::DefNode < ::Struct
  # source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#215
  def first_argument; end

  # source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#219
  def last_argument; end

  # Returns the value of attribute node
  #
  # @return [Object] the current value of node
  def node; end

  # Sets the attribute node
  #
  # @param value [Object] the value to set the attribute node to.
  # @return [Object] the newly set value
  def node=(_); end

  # source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#207
  def selector; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#9
RuboCop::Cop::HashShorthandSyntax::EXPLICIT_HASH_VALUE_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#8
RuboCop::Cop::HashShorthandSyntax::OMIT_HASH_VALUE_MSG = T.let(T.unsafe(nil), String)

# Common functionality for Style/HashTransformKeys and
# Style/HashTransformValues
#
# source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#7
module RuboCop::Cop::HashTransformMethod
  extend ::RuboCop::AST::NodePattern::Macros

  # source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#13
  def array_receiver?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#17
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#34
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#27
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#108
  def execute_correction(corrector, node, correction); end

  # @abstract
  # @raise [NotImplementedError]
  # @return [Captures]
  #
  # source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#83
  def extract_captures(_match); end

  # source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#60
  def handle_possible_offense(node, match, match_desc); end

  # @abstract
  # @raise [NotImplementedError]
  # @return [String]
  #
  # source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#90
  def new_method_name; end

  # @abstract Implemented with `def_node_matcher`
  # @raise [NotImplementedError]
  #
  # source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#41
  def on_bad_each_with_object(_node); end

  # @abstract Implemented with `def_node_matcher`
  # @raise [NotImplementedError]
  #
  # source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#46
  def on_bad_hash_brackets_map(_node); end

  # @abstract Implemented with `def_node_matcher`
  # @raise [NotImplementedError]
  #
  # source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#51
  def on_bad_map_to_h(_node); end

  # @abstract Implemented with `def_node_matcher`
  # @raise [NotImplementedError]
  #
  # source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#56
  def on_bad_to_h(_node); end

  # source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#94
  def prepare_correction(node); end
end

# Internal helper class to hold autocorrect data
#
# source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#136
class RuboCop::Cop::HashTransformMethod::Autocorrection < ::Struct
  # Returns the value of attribute block_node
  #
  # @return [Object] the current value of block_node
  def block_node; end

  # Sets the attribute block_node
  #
  # @param value [Object] the value to set the attribute block_node to.
  # @return [Object] the newly set value
  def block_node=(_); end

  # Returns the value of attribute leading
  #
  # @return [Object] the current value of leading
  def leading; end

  # Sets the attribute leading
  #
  # @param value [Object] the value to set the attribute leading to.
  # @return [Object] the newly set value
  def leading=(_); end

  # Returns the value of attribute match
  #
  # @return [Object] the current value of match
  def match; end

  # Sets the attribute match
  #
  # @param value [Object] the value to set the attribute match to.
  # @return [Object] the newly set value
  def match=(_); end

  # source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#177
  def set_new_arg_name(transformed_argname, corrector); end

  # source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#181
  def set_new_body_expression(transforming_body_expr, corrector); end

  # source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#167
  def set_new_method_name(new_method_name, corrector); end

  # source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#161
  def strip_prefix_and_suffix(node, corrector); end

  # Returns the value of attribute trailing
  #
  # @return [Object] the current value of trailing
  def trailing; end

  # Sets the attribute trailing
  #
  # @param value [Object] the value to set the attribute trailing to.
  # @return [Object] the newly set value
  def trailing=(_); end

  class << self
    def [](*_arg0); end

    # source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#137
    def from_each_with_object(node, match); end

    # source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#141
    def from_hash_brackets_map(node, match); end

    # source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#145
    def from_map_to_h(node, match); end

    # source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#157
    def from_to_h(node, match); end

    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# Internal helper class to hold match data
#
# source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#118
class RuboCop::Cop::HashTransformMethod::Captures < ::Struct
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#119
  def noop_transformation?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#124
  def transformation_uses_both_args?; end

  # Returns the value of attribute transformed_argname
  #
  # @return [Object] the current value of transformed_argname
  def transformed_argname; end

  # Sets the attribute transformed_argname
  #
  # @param value [Object] the value to set the attribute transformed_argname to.
  # @return [Object] the newly set value
  def transformed_argname=(_); end

  # Returns the value of attribute transforming_body_expr
  #
  # @return [Object] the current value of transforming_body_expr
  def transforming_body_expr; end

  # Sets the attribute transforming_body_expr
  #
  # @param value [Object] the value to set the attribute transforming_body_expr to.
  # @return [Object] the newly set value
  def transforming_body_expr=(_); end

  # Returns the value of attribute unchanged_body_expr
  #
  # @return [Object] the current value of unchanged_body_expr
  def unchanged_body_expr; end

  # Sets the attribute unchanged_body_expr
  #
  # @param value [Object] the value to set the attribute unchanged_body_expr to.
  # @return [Object] the newly set value
  def unchanged_body_expr=(_); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#128
  def use_transformed_argname?; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#10
RuboCop::Cop::HashTransformMethod::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Common functionality for working with heredoc strings.
#
# source://rubocop//lib/rubocop/cop/mixin/heredoc.rb#6
module RuboCop::Cop::Heredoc
  # source://rubocop//lib/rubocop/cop/mixin/heredoc.rb#9
  def on_dstr(node); end

  # @raise [NotImplementedError]
  #
  # source://rubocop//lib/rubocop/cop/mixin/heredoc.rb#17
  def on_heredoc(_node); end

  # source://rubocop//lib/rubocop/cop/mixin/heredoc.rb#9
  def on_str(node); end

  # source://rubocop//lib/rubocop/cop/mixin/heredoc.rb#9
  def on_xstr(node); end

  private

  # source://rubocop//lib/rubocop/cop/mixin/heredoc.rb#28
  def delimiter_string(node); end

  # source://rubocop//lib/rubocop/cop/mixin/heredoc.rb#32
  def heredoc_type(node); end

  # source://rubocop//lib/rubocop/cop/mixin/heredoc.rb#23
  def indent_level(str); end
end

# source://rubocop//lib/rubocop/cop/mixin/heredoc.rb#7
RuboCop::Cop::Heredoc::OPENING_DELIMITER = T.let(T.unsafe(nil), Regexp)

# This class autocorrects `if...then` structures to a multiline `if` statement
#
# source://rubocop//lib/rubocop/cop/correctors/if_then_corrector.rb#6
class RuboCop::Cop::IfThenCorrector
  # @return [IfThenCorrector] a new instance of IfThenCorrector
  #
  # source://rubocop//lib/rubocop/cop/correctors/if_then_corrector.rb#9
  def initialize(if_node, indentation: T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/correctors/if_then_corrector.rb#14
  def call(corrector); end

  private

  # source://rubocop//lib/rubocop/cop/correctors/if_then_corrector.rb#50
  def branch_body_indentation; end

  # Returns the value of attribute if_node.
  #
  # source://rubocop//lib/rubocop/cop/correctors/if_then_corrector.rb#20
  def if_node; end

  # Returns the value of attribute indentation.
  #
  # source://rubocop//lib/rubocop/cop/correctors/if_then_corrector.rb#20
  def indentation; end

  # source://rubocop//lib/rubocop/cop/correctors/if_then_corrector.rb#22
  def replacement(node = T.unsafe(nil), indentation = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/correctors/if_then_corrector.rb#36
  def rewrite_else_branch(else_branch, indentation); end
end

# source://rubocop//lib/rubocop/cop/correctors/if_then_corrector.rb#7
RuboCop::Cop::IfThenCorrector::DEFAULT_INDENTATION_WIDTH = T.let(T.unsafe(nil), Integer)

# @deprecated IgnoredMethods class has been replaced with AllowedMethods.
#
# source://rubocop//lib/rubocop/cop/mixin/allowed_methods.rb#40
RuboCop::Cop::IgnoredMethods = RuboCop::Cop::AllowedMethods

# Handles adding and checking ignored nodes.
#
# source://rubocop//lib/rubocop/cop/ignored_node.rb#6
module RuboCop::Cop::IgnoredNode
  # source://rubocop//lib/rubocop/cop/ignored_node.rb#7
  def ignore_node(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/ignored_node.rb#24
  def ignored_node?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/ignored_node.rb#11
  def part_of_ignored_node?(node); end

  private

  # source://rubocop//lib/rubocop/cop/ignored_node.rb#31
  def ignored_nodes; end
end

# @deprecated IgnoredPattern class has been replaced with AllowedPattern.
#
# source://rubocop//lib/rubocop/cop/mixin/allowed_pattern.rb#54
RuboCop::Cop::IgnoredPattern = RuboCop::Cop::AllowedPattern

# Common functionality for checking integer nodes.
#
# source://rubocop//lib/rubocop/cop/mixin/integer_node.rb#6
module RuboCop::Cop::IntegerNode
  private

  # source://rubocop//lib/rubocop/cop/mixin/integer_node.rb#9
  def integer_part(node); end
end

# Common functionality for working with string interpolations.
#
# @abstract Subclasses are expected to implement {#on_interpolation}.
#
# source://rubocop//lib/rubocop/cop/mixin/interpolation.rb#8
module RuboCop::Cop::Interpolation
  # source://rubocop//lib/rubocop/cop/mixin/interpolation.rb#9
  def on_dstr(node); end

  # source://rubocop//lib/rubocop/cop/mixin/interpolation.rb#9
  def on_dsym(node); end

  # source://rubocop//lib/rubocop/cop/mixin/interpolation.rb#17
  def on_node_with_interpolations(node); end

  # source://rubocop//lib/rubocop/cop/mixin/interpolation.rb#9
  def on_regexp(node); end

  # source://rubocop//lib/rubocop/cop/mixin/interpolation.rb#9
  def on_xstr(node); end
end

# This class autocorrects lambda literal to method notation.
#
# source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#6
class RuboCop::Cop::LambdaLiteralToMethodCorrector
  # @return [LambdaLiteralToMethodCorrector] a new instance of LambdaLiteralToMethodCorrector
  #
  # source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#7
  def initialize(block_node); end

  # source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#13
  def call(corrector); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#115
  def arg_to_unparenthesized_call?; end

  # Returns the value of attribute arguments.
  #
  # source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#31
  def arguments; end

  # source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#99
  def arguments_begin_pos; end

  # source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#95
  def arguments_end_pos; end

  # source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#107
  def block_begin; end

  # source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#103
  def block_end; end

  # Returns the value of attribute block_node.
  #
  # source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#31
  def block_node; end

  # source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#56
  def insert_arguments(corrector); end

  # source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#40
  def insert_separating_space(corrector); end

  # source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#85
  def lambda_arg_string; end

  # Returns the value of attribute method.
  #
  # source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#31
  def method; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#89
  def needs_separating_space?; end

  # source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#50
  def remove_arguments(corrector); end

  # source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#63
  def remove_leading_whitespace(corrector); end

  # source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#71
  def remove_trailing_whitespace(corrector); end

  # source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#33
  def remove_unparenthesized_whitespace(corrector); end

  # source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#76
  def replace_delimiters(corrector); end

  # source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#46
  def replace_selector(corrector); end

  # source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#111
  def selector_end; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#131
  def separating_space?; end
end

# source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#5
module RuboCop::Cop::Layout; end

# Bare access modifiers (those not applying to specific methods) should be
# indented as deep as method definitions, or as deep as the class/module
# keyword, depending on configuration.
#
# @example EnforcedStyle: indent (default)
#   # bad
#   class Plumbus
#   private
#   def smooth; end
#   end
#
#   # good
#   class Plumbus
#   private
#   def smooth; end
#   end
# @example EnforcedStyle: outdent
#   # bad
#   class Plumbus
#   private
#   def smooth; end
#   end
#
#   # good
#   class Plumbus
#   private
#   def smooth; end
#   end
#
# source://rubocop//lib/rubocop/cop/layout/access_modifier_indentation.rb#35
class RuboCop::Cop::Layout::AccessModifierIndentation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/access_modifier_indentation.rb#43
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/layout/access_modifier_indentation.rb#43
  def on_class(node); end

  # source://rubocop//lib/rubocop/cop/layout/access_modifier_indentation.rb#43
  def on_module(node); end

  # source://rubocop//lib/rubocop/cop/layout/access_modifier_indentation.rb#43
  def on_sclass(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/access_modifier_indentation.rb#54
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/layout/access_modifier_indentation.rb#58
  def check_body(body, node); end

  # source://rubocop//lib/rubocop/cop/layout/access_modifier_indentation.rb#65
  def check_modifier(send_node, end_range); end

  # source://rubocop//lib/rubocop/cop/layout/access_modifier_indentation.rb#88
  def expected_indent_offset; end

  # source://rubocop//lib/rubocop/cop/layout/access_modifier_indentation.rb#84
  def message(range); end

  # An offset that is not expected, but correct if the configuration is
  # changed.
  #
  # source://rubocop//lib/rubocop/cop/layout/access_modifier_indentation.rb#94
  def unexpected_indent_offset; end
end

# source://rubocop//lib/rubocop/cop/layout/access_modifier_indentation.rb#41
RuboCop::Cop::Layout::AccessModifierIndentation::MSG = T.let(T.unsafe(nil), String)

# Here we check if the arguments on a multi-line method
# definition are aligned.
#
# @example EnforcedStyle: with_first_argument (default)
#   # good
#
#   foo :bar,
#   :baz,
#   key: value
#
#   foo(
#   :bar,
#   :baz,
#   key: value
#   )
#
#   # bad
#
#   foo :bar,
#   :baz,
#   key: value
#
#   foo(
#   :bar,
#   :baz,
#   key: value
#   )
# @example EnforcedStyle: with_fixed_indentation
#   # good
#
#   foo :bar,
#   :baz,
#   key: value
#
#   # bad
#
#   foo :bar,
#   :baz,
#   key: value
#
# source://rubocop//lib/rubocop/cop/layout/argument_alignment.rb#46
class RuboCop::Cop::Layout::ArgumentAlignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/argument_alignment.rb#55
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/layout/argument_alignment.rb#55
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/argument_alignment.rb#92
  def arguments_or_first_arg_pairs(node); end

  # source://rubocop//lib/rubocop/cop/layout/argument_alignment.rb#80
  def arguments_with_last_arg_pairs(node); end

  # source://rubocop//lib/rubocop/cop/layout/argument_alignment.rb#108
  def autocorrect(corrector, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/argument_alignment.rb#68
  def autocorrect_incompatible_with_other_cops?; end

  # source://rubocop//lib/rubocop/cop/layout/argument_alignment.rb#124
  def base_column(node, first_argument); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/argument_alignment.rb#144
  def enforce_hash_argument_with_separator?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/argument_alignment.rb#116
  def fixed_indentation?; end

  # source://rubocop//lib/rubocop/cop/layout/argument_alignment.rb#72
  def flattened_arguments(node); end

  # source://rubocop//lib/rubocop/cop/layout/argument_alignment.rb#152
  def hash_argument_config; end

  # source://rubocop//lib/rubocop/cop/layout/argument_alignment.rb#112
  def message(_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/argument_alignment.rb#101
  def multiple_arguments?(node); end

  # source://rubocop//lib/rubocop/cop/layout/argument_alignment.rb#135
  def target_method_lineno(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/argument_alignment.rb#120
  def with_first_argument_style?; end
end

# source://rubocop//lib/rubocop/cop/layout/argument_alignment.rb#50
RuboCop::Cop::Layout::ArgumentAlignment::ALIGN_PARAMS_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/argument_alignment.rb#52
RuboCop::Cop::Layout::ArgumentAlignment::FIXED_INDENT_MSG = T.let(T.unsafe(nil), String)

# Here we check if the elements of a multi-line array literal are
# aligned.
#
# @example EnforcedStyle: with_first_element (default)
#   # good
#
#   array = [1, 2, 3,
#   4, 5, 6]
#   array = ['run',
#   'forrest',
#   'run']
#
#   # bad
#
#   array = [1, 2, 3,
#   4, 5, 6]
#   array = ['run',
#   'forrest',
#   'run']
# @example EnforcedStyle: with_fixed_indentation
#   # good
#
#   array = [1, 2, 3,
#   4, 5, 6]
#
#   # bad
#
#   array = [1, 2, 3,
#   4, 5, 6]
#
# source://rubocop//lib/rubocop/cop/layout/array_alignment.rb#36
class RuboCop::Cop::Layout::ArrayAlignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/array_alignment.rb#46
  def on_array(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/array_alignment.rb#55
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/layout/array_alignment.rb#67
  def base_column(node, args); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/array_alignment.rb#63
  def fixed_indentation?; end

  # source://rubocop//lib/rubocop/cop/layout/array_alignment.rb#59
  def message(_range); end

  # source://rubocop//lib/rubocop/cop/layout/array_alignment.rb#78
  def target_method_lineno(node); end
end

# source://rubocop//lib/rubocop/cop/layout/array_alignment.rb#40
RuboCop::Cop::Layout::ArrayAlignment::ALIGN_ELEMENTS_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/array_alignment.rb#43
RuboCop::Cop::Layout::ArrayAlignment::FIXED_INDENT_MSG = T.let(T.unsafe(nil), String)

# Checks the indentation of the first line of the
# right-hand-side of a multi-line assignment.
#
# The indentation of the remaining lines can be corrected with
# other cops such as `IndentationConsistency` and `EndAlignment`.
#
# @example
#   # bad
#   value =
#   if foo
#   'bar'
#   end
#
#   # good
#   value =
#   if foo
#   'bar'
#   end
#
# source://rubocop//lib/rubocop/cop/layout/assignment_indentation.rb#24
class RuboCop::Cop::Layout::AssignmentIndentation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::Alignment
  extend ::RuboCop::Cop::AutoCorrector

  private

  # source://rubocop//lib/rubocop/cop/layout/assignment_indentation.rb#42
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/layout/assignment_indentation.rb#33
  def check_assignment(node, rhs); end

  # source://rubocop//lib/rubocop/cop/layout/assignment_indentation.rb#46
  def leftmost_multiple_assignment(node); end
end

# source://rubocop//lib/rubocop/cop/layout/assignment_indentation.rb#29
RuboCop::Cop::Layout::AssignmentIndentation::MSG = T.let(T.unsafe(nil), String)

# Checks whether the end keyword of `begin` is aligned properly.
#
# Two modes are supported through the `EnforcedStyleAlignWith` configuration
# parameter. If it's set to `start_of_line` (which is the default), the
# `end` shall be aligned with the start of the line where the `begin`
# keyword is. If it's set to `begin`, the `end` shall be aligned with the
# `begin` keyword.
#
# `Layout/EndAlignment` cop aligns with keywords (e.g. `if`, `while`, `case`)
# by default. On the other hand, `||= begin` that this cop targets tends to
# align with the start of the line, it defaults to `EnforcedStyleAlignWith: start_of_line`.
# These style can be configured by each cop.
#
# @example EnforcedStyleAlignWith: start_of_line (default)
#   # bad
#   foo ||= begin
#   do_something
#   end
#
#   # good
#   foo ||= begin
#   do_something
#   end
# @example EnforcedStyleAlignWith: begin
#   # bad
#   foo ||= begin
#   do_something
#   end
#
#   # good
#   foo ||= begin
#   do_something
#   end
#
# source://rubocop//lib/rubocop/cop/layout/begin_end_alignment.rb#41
class RuboCop::Cop::Layout::BeginEndAlignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::EndKeywordAlignment
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/begin_end_alignment.rb#48
  def on_kwbegin(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/begin_end_alignment.rb#63
  def alignment_node(node); end

  # source://rubocop//lib/rubocop/cop/layout/begin_end_alignment.rb#59
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/layout/begin_end_alignment.rb#54
  def check_begin_alignment(node); end
end

# source://rubocop//lib/rubocop/cop/layout/begin_end_alignment.rb#46
RuboCop::Cop::Layout::BeginEndAlignment::MSG = T.let(T.unsafe(nil), String)

# Checks whether the end keywords are aligned properly for do
# end blocks.
#
# Three modes are supported through the `EnforcedStyleAlignWith`
# configuration parameter:
#
# `start_of_block` : the `end` shall be aligned with the
# start of the line where the `do` appeared.
#
# `start_of_line` : the `end` shall be aligned with the
# start of the line where the expression started.
#
# `either` (which is the default) : the `end` is allowed to be in either
# location. The autofixer will default to `start_of_line`.
#
# @example EnforcedStyleAlignWith: either (default)
#   # bad
#
#   foo.bar
#   .each do
#   baz
#   end
#
#   # good
#
#   foo.bar
#   .each do
#   baz
#   end
# @example EnforcedStyleAlignWith: start_of_block
#   # bad
#
#   foo.bar
#   .each do
#   baz
#   end
#
#   # good
#
#   foo.bar
#   .each do
#   baz
#   end
# @example EnforcedStyleAlignWith: start_of_line
#   # bad
#
#   foo.bar
#   .each do
#   baz
#   end
#
#   # good
#
#   foo.bar
#   .each do
#   baz
#   end
#
# source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#66
class RuboCop::Cop::Layout::BlockAlignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#74
  def block_end_align_target?(param0 = T.unsafe(nil), param1); end

  # source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#83
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#83
  def on_numblock(node); end

  # source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#89
  def style_parameter_name; end

  private

  # source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#228
  def add_space_before(corrector, loc, delta); end

  # source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#205
  def alt_start_msg(start_loc, source_line_column); end

  # source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#155
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#105
  def block_end_align_target(node); end

  # source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#123
  def check_block_alignment(start_node, block_node); end

  # source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#178
  def compute_do_source_line_column(node, end_loc); end

  # source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#220
  def compute_start_col(ancestor_node, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#119
  def disqualified_parent?(parent, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#115
  def end_align_target?(node, parent); end

  # source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#168
  def format_message(start_loc, end_loc, do_source_line_column, error_source_line_column); end

  # source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#215
  def format_source_line_column(source_line_column); end

  # source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#197
  def loc_to_source_line_column(loc); end

  # source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#136
  def register_offense(block_node, start_loc, end_loc, do_source_line_column); end

  # source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#232
  def remove_space_before(corrector, end_pos, delta); end

  # source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#95
  def start_for_block_node(block_node); end
end

# source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#71
RuboCop::Cop::Layout::BlockAlignment::MSG = T.let(T.unsafe(nil), String)

# Checks whether the end statement of a do..end block
# is on its own line.
#
# @example
#   # bad
#   blah do |i|
#   foo(i) end
#
#   # good
#   blah do |i|
#   foo(i)
#   end
#
#   # bad
#   blah { |i|
#   foo(i) }
#
#   # good
#   blah { |i|
#   foo(i)
#   }
#
# source://rubocop//lib/rubocop/cop/layout/block_end_newline.rb#27
class RuboCop::Cop::Layout::BlockEndNewline < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/block_end_newline.rb#33
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/layout/block_end_newline.rb#33
  def on_numblock(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/block_end_newline.rb#66
  def last_heredoc_argument(node); end

  # source://rubocop//lib/rubocop/cop/layout/block_end_newline.rb#62
  def message(node); end

  # source://rubocop//lib/rubocop/cop/layout/block_end_newline.rb#76
  def offense_range(node); end

  # source://rubocop//lib/rubocop/cop/layout/block_end_newline.rb#49
  def register_offense(node, offense_range); end
end

# source://rubocop//lib/rubocop/cop/layout/block_end_newline.rb#31
RuboCop::Cop::Layout::BlockEndNewline::MSG = T.let(T.unsafe(nil), String)

# Checks how the `when` and ``in``s of a `case` expression
# are indented in relation to its `case` or `end` keyword.
#
# It will register a separate offense for each misaligned `when` and `in`.
#
# @example
#   # If Layout/EndAlignment is set to keyword style (default)
#   # *case* and *end* should always be aligned to same depth,
#   # and therefore *when* should always be aligned to both -
#   # regardless of configuration.
#
#   # bad for all styles
#   case n
#   when 0
#   x * 2
#   else
#   y / 3
#   end
#
#   case n
#   in pattern
#   x * 2
#   else
#   y / 3
#   end
#
#   # good for all styles
#   case n
#   when 0
#   x * 2
#   else
#   y / 3
#   end
#
#   case n
#   in pattern
#   x * 2
#   else
#   y / 3
#   end
# @example EnforcedStyle: case (default)
#   # if EndAlignment is set to other style such as
#   # start_of_line (as shown below), then *when* alignment
#   # configuration does have an effect.
#
#   # bad
#   a = case n
#   when 0
#   x * 2
#   else
#   y / 3
#   end
#
#   a = case n
#   in pattern
#   x * 2
#   else
#   y / 3
#   end
#
#   # good
#   a = case n
#   when 0
#   x * 2
#   else
#   y / 3
#   end
#
#   a = case n
#   in pattern
#   x * 2
#   else
#   y / 3
#   end
# @example EnforcedStyle: end
#   # bad
#   a = case n
#   when 0
#   x * 2
#   else
#   y / 3
#   end
#
#   a = case n
#   in pattern
#   x * 2
#   else
#   y / 3
#   end
#
#   # good
#   a = case n
#   when 0
#   x * 2
#   else
#   y / 3
#   end
#
#   a = case n
#   in pattern
#   x * 2
#   else
#   y / 3
#   end
#
# source://rubocop//lib/rubocop/cop/layout/case_indentation.rb#112
class RuboCop::Cop::Layout::CaseIndentation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/case_indentation.rb#120
  def on_case(case_node); end

  # source://rubocop//lib/rubocop/cop/layout/case_indentation.rb#127
  def on_case_match(case_match_node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/case_indentation.rb#193
  def base_column(case_node, base); end

  # source://rubocop//lib/rubocop/cop/layout/case_indentation.rb#150
  def check_when(when_node, branch_type); end

  # source://rubocop//lib/rubocop/cop/layout/case_indentation.rb#182
  def detect_incorrect_style(when_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/case_indentation.rb#136
  def end_and_last_conditional_same_line?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/case_indentation.rb#146
  def enforced_style_end?; end

  # source://rubocop//lib/rubocop/cop/layout/case_indentation.rb#169
  def incorrect_style(when_node, branch_type); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/case_indentation.rb#161
  def indent_one_step?; end

  # source://rubocop//lib/rubocop/cop/layout/case_indentation.rb#165
  def indentation_width; end

  # source://rubocop//lib/rubocop/cop/layout/case_indentation.rb#207
  def replacement(node); end

  # source://rubocop//lib/rubocop/cop/layout/case_indentation.rb#200
  def whitespace_range(node); end
end

# source://rubocop//lib/rubocop/cop/layout/case_indentation.rb#118
RuboCop::Cop::Layout::CaseIndentation::MSG = T.let(T.unsafe(nil), String)

# Checks if the code style follows the ExpectedOrder configuration:
#
# `Categories` allows us to map macro names into a category.
#
# Consider an example of code style that covers the following order:
#
# * Module inclusion (include, prepend, extend)
# * Constants
# * Associations (has_one, has_many)
# * Public attribute macros (attr_accessor, attr_writer, attr_reader)
# * Other macros (validates, validate)
# * Public class methods
# * Initializer
# * Public instance methods
# * Protected attribute macros (attr_accessor, attr_writer, attr_reader)
# * Protected instance methods
# * Private attribute macros (attr_accessor, attr_writer, attr_reader)
# * Private instance methods
#
# You can configure the following order:
#
# [source,yaml]
# ----
#  Layout/ClassStructure:
#    ExpectedOrder:
#      - module_inclusion
#      - constants
#      - association
#      - public_attribute_macros
#      - public_delegate
#      - macros
#      - public_class_methods
#      - initializer
#      - public_methods
#      - protected_attribute_macros
#      - protected_methods
#      - private_attribute_macros
#      - private_delegate
#      - private_methods
# ----
#
# Instead of putting all literals in the expected order, is also
# possible to group categories of macros. Visibility levels are handled
# automatically.
#
# [source,yaml]
# ----
#  Layout/ClassStructure:
#    Categories:
#      association:
#        - has_many
#        - has_one
#      attribute_macros:
#        - attr_accessor
#        - attr_reader
#        - attr_writer
#      macros:
#        - validates
#        - validate
#      module_inclusion:
#        - include
#        - prepend
#        - extend
# ----
#
# @example
#   # bad
#   # Expect extend be before constant
#   class Person < ApplicationRecord
#   has_many :orders
#   ANSWER = 42
#
#   extend SomeModule
#   include AnotherModule
#   end
#
#   # good
#   class Person
#   # extend and include go first
#   extend SomeModule
#   include AnotherModule
#
#   # inner classes
#   CustomError = Class.new(StandardError)
#
#   # constants are next
#   SOME_CONSTANT = 20
#
#   # afterwards we have public attribute macros
#   attr_reader :name
#
#   # followed by other macros (if any)
#   validates :name
#
#   # then we have public delegate macros
#   delegate :to_s, to: :name
#
#   # public class methods are next in line
#   def self.some_method
#   end
#
#   # initialization goes between class methods and instance methods
#   def initialize
#   end
#
#   # followed by other public instance methods
#   def some_method
#   end
#
#   # protected attribute macros and methods go next
#   protected
#
#   attr_reader :protected_name
#
#   def some_protected_method
#   end
#
#   # private attribute macros, delegate macros and methods
#   # are grouped near the end
#   private
#
#   attr_reader :private_name
#
#   delegate :some_private_delegate, to: :name
#
#   def some_private_method
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/layout/class_structure.rb#135
class RuboCop::Cop::Layout::ClassStructure < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::VisibilityHelp
  include ::RuboCop::Cop::CommentsHelp
  extend ::RuboCop::Cop::AutoCorrector

  # Validates code style on class declaration.
  # Add offense when find a node out of expected order.
  #
  # source://rubocop//lib/rubocop/cop/layout/class_structure.rb#151
  def on_class(class_node); end

  private

  # Autocorrect by swapping between two nodes autocorrecting them
  #
  # source://rubocop//lib/rubocop/cop/layout/class_structure.rb#166
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/layout/class_structure.rb#297
  def begin_pos_with_comment(node); end

  # source://rubocop//lib/rubocop/cop/layout/class_structure.rb#320
  def buffer; end

  # Setting categories hash allow you to group methods in group to match
  # in the {expected_order}.
  #
  # source://rubocop//lib/rubocop/cop/layout/class_structure.rb#332
  def categories; end

  # source://rubocop//lib/rubocop/cop/layout/class_structure.rb#226
  def class_elements(class_node); end

  # Classifies a node to match with something in the {expected_order}
  #
  # @param node to be analysed
  # @return String when the node type is a `:block` then
  #   {classify} recursively with the first children
  # @return String when the node type is a `:send` then {find_category}
  #   by method name
  # @return String otherwise trying to {humanize_node} of the current node
  #
  # source://rubocop//lib/rubocop/cop/layout/class_structure.rb#186
  def classify(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/class_structure.rb#263
  def dynamic_constant?(node); end

  # source://rubocop//lib/rubocop/cop/layout/class_structure.rb#287
  def end_position_for(node); end

  # Load expected order from `ExpectedOrder` config.
  # Define new terms in the expected order by adding new {categories}.
  #
  # source://rubocop//lib/rubocop/cop/layout/class_structure.rb#326
  def expected_order; end

  # Categorize a node according to the {expected_order}
  # Try to match {categories} values against the node's method_name given
  # also its visibility.
  #
  # @param node to be analysed.
  # @return [String] with the key category or the `method_name` as string
  #
  # source://rubocop//lib/rubocop/cop/layout/class_structure.rb#204
  def find_category(node); end

  # source://rubocop//lib/rubocop/cop/layout/class_structure.rb#316
  def find_heredoc(node); end

  # source://rubocop//lib/rubocop/cop/layout/class_structure.rb#254
  def humanize_node(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/class_structure.rb#238
  def ignore?(node, classification); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/class_structure.rb#245
  def ignore_for_autocorrect?(node, sibling); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/class_structure.rb#281
  def marked_as_private_constant?(node, name); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/class_structure.rb#271
  def private_constant?(node); end

  # source://rubocop//lib/rubocop/cop/layout/class_structure.rb#312
  def start_line_position(node); end

  # source://rubocop//lib/rubocop/cop/layout/class_structure.rb#217
  def walk_over_nested_class_definition(class_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/class_structure.rb#308
  def whole_line_comment_at_line?(line); end
end

# source://rubocop//lib/rubocop/cop/layout/class_structure.rb#140
RuboCop::Cop::Layout::ClassStructure::HUMANIZED_NODE_TYPE = T.let(T.unsafe(nil), Hash)

# source://rubocop//lib/rubocop/cop/layout/class_structure.rb#147
RuboCop::Cop::Layout::ClassStructure::MSG = T.let(T.unsafe(nil), String)

# Checks the indentation of here document closings.
#
# @example
#
#   # bad
#   class Foo
#   def bar
#   <<~SQL
#   'Hi'
#   SQL
#   end
#   end
#
#   # good
#   class Foo
#   def bar
#   <<~SQL
#   'Hi'
#   SQL
#   end
#   end
#
#   # bad
#
#   # heredoc contents is before closing heredoc.
#   foo arg,
#   <<~EOS
#   Hi
#   EOS
#
#   # good
#   foo arg,
#   <<~EOS
#   Hi
#   EOS
#
#   # good
#   foo arg,
#   <<~EOS
#   Hi
#   EOS
#
# source://rubocop//lib/rubocop/cop/layout/closing_heredoc_indentation.rb#49
class RuboCop::Cop::Layout::ClosingHeredocIndentation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Heredoc
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/closing_heredoc_indentation.rb#58
  def on_heredoc(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/closing_heredoc_indentation.rb#75
  def argument_indentation_correct?(node); end

  # source://rubocop//lib/rubocop/cop/layout/closing_heredoc_indentation.rb#83
  def closing_indentation(node); end

  # source://rubocop//lib/rubocop/cop/layout/closing_heredoc_indentation.rb#102
  def find_node_used_heredoc_argument(node); end

  # source://rubocop//lib/rubocop/cop/layout/closing_heredoc_indentation.rb#91
  def heredoc_closing(node); end

  # source://rubocop//lib/rubocop/cop/layout/closing_heredoc_indentation.rb#87
  def heredoc_opening(node); end

  # source://rubocop//lib/rubocop/cop/layout/closing_heredoc_indentation.rb#118
  def indent_level(source_line); end

  # source://rubocop//lib/rubocop/cop/layout/closing_heredoc_indentation.rb#95
  def indented_end(node); end

  # source://rubocop//lib/rubocop/cop/layout/closing_heredoc_indentation.rb#110
  def message(node); end

  # source://rubocop//lib/rubocop/cop/layout/closing_heredoc_indentation.rb#71
  def opening_indentation(node); end
end

# source://rubocop//lib/rubocop/cop/layout/closing_heredoc_indentation.rb#54
RuboCop::Cop::Layout::ClosingHeredocIndentation::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/closing_heredoc_indentation.rb#55
RuboCop::Cop::Layout::ClosingHeredocIndentation::MSG_ARG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/closing_heredoc_indentation.rb#53
RuboCop::Cop::Layout::ClosingHeredocIndentation::SIMPLE_HEREDOC = T.let(T.unsafe(nil), String)

# Checks the indentation of hanging closing parentheses in
# method calls, method definitions, and grouped expressions. A hanging
# closing parenthesis means `)` preceded by a line break.
#
# @example
#
#   # bad
#   some_method(
#   a,
#   b
#   )
#
#   some_method(
#   a, b
#   )
#
#   some_method(a, b, c
#   )
#
#   some_method(a,
#   b,
#   c
#   )
#
#   some_method(a,
#   x: 1,
#   y: 2
#   )
#
#   # Scenario 1: When First Parameter Is On Its Own Line
#
#   # good: when first param is on a new line, right paren is *always*
#   #       outdented by IndentationWidth
#   some_method(
#   a,
#   b
#   )
#
#   # good
#   some_method(
#   a, b
#   )
#
#   # Scenario 2: When First Parameter Is On The Same Line
#
#   # good: when all other params are also on the same line, outdent
#   #       right paren by IndentationWidth
#   some_method(a, b, c
#   )
#
#   # good: when all other params are on multiple lines, but are lined
#   #       up, align right paren with left paren
#   some_method(a,
#   b,
#   c
#   )
#
#   # good: when other params are not lined up on multiple lines, outdent
#   #       right paren by IndentationWidth
#   some_method(a,
#   x: 1,
#   y: 2
#   )
#
# source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#71
class RuboCop::Cop::Layout::ClosingParenthesisIndentation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#84
  def on_begin(node); end

  # source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#79
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#88
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#88
  def on_defs(node); end

  # source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#79
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#157
  def all_elements_aligned?(elements); end

  # source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#95
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#99
  def check(node, elements); end

  # source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#107
  def check_for_elements(node, elements); end

  # source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#125
  def check_for_no_elements(node); end

  # source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#171
  def correct_column_candidates(node, left_paren); end

  # source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#144
  def expected_column(left_paren, elements); end

  # source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#167
  def first_argument_line(elements); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#187
  def line_break_after_left_paren?(left_paren, elements); end

  # source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#179
  def message(correct_column, left_paren, right_paren); end
end

# source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#77
RuboCop::Cop::Layout::ClosingParenthesisIndentation::MSG_ALIGN = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#75
RuboCop::Cop::Layout::ClosingParenthesisIndentation::MSG_INDENT = T.let(T.unsafe(nil), String)

# Checks the indentation of comments.
#
# @example
#   # bad
#   # comment here
#   def method_name
#   end
#
#   # comment here
#   a = 'hello'
#
#   # yet another comment
#   if true
#   true
#   end
#
#   # good
#   # comment here
#   def method_name
#   end
#
#   # comment here
#   a = 'hello'
#
#   # yet another comment
#   if true
#   true
#   end
# @example AllowForAlignment: false (default)
#   # bad
#   a = 1 # A really long comment
#   # spanning two lines.
#
#   # good
#   # A really long comment spanning one line.
#   a = 1
# @example AllowForAlignment: true
#   # good
#   a = 1 # A really long comment
#   # spanning two lines.
#
# source://rubocop//lib/rubocop/cop/layout/comment_indentation.rb#48
class RuboCop::Cop::Layout::CommentIndentation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/comment_indentation.rb#55
  def on_new_investigation; end

  private

  # source://rubocop//lib/rubocop/cop/layout/comment_indentation.rb#61
  def autocorrect(corrector, comment); end

  # source://rubocop//lib/rubocop/cop/layout/comment_indentation.rb#88
  def autocorrect_one(corrector, comment); end

  # Corrects all comment lines that occur immediately before the given
  # comment and have the same indentation. This is to avoid a long chain
  # of correcting, saving the file, parsing and inspecting again, and
  # then correcting one more line, and so on.
  #
  # source://rubocop//lib/rubocop/cop/layout/comment_indentation.rb#71
  def autocorrect_preceding_comments(corrector, comment); end

  # source://rubocop//lib/rubocop/cop/layout/comment_indentation.rb#92
  def check(comment, comment_index); end

  # source://rubocop//lib/rubocop/cop/layout/comment_indentation.rb#145
  def correct_indentation(next_line); end

  # Returns true if:
  # a) the cop is configured to allow extra indentation for alignment, and
  # b) the currently inspected comment is aligned with the nearest preceding end-of-line
  #    comment.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/comment_indentation.rb#121
  def correctly_aligned_with_preceding_comment?(comment_index, column); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/comment_indentation.rb#156
  def less_indented?(line); end

  # source://rubocop//lib/rubocop/cop/layout/comment_indentation.rb#140
  def line_after_comment(comment); end

  # source://rubocop//lib/rubocop/cop/layout/comment_indentation.rb#131
  def message(column, correct_comment_indentation); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/comment_indentation.rb#135
  def own_line_comment?(comment); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/comment_indentation.rb#82
  def should_correct?(preceding_comment, reference_comment); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/comment_indentation.rb#162
  def two_alternatives?(line); end
end

# source://rubocop//lib/rubocop/cop/layout/comment_indentation.rb#52
RuboCop::Cop::Layout::CommentIndentation::MSG = T.let(T.unsafe(nil), String)

# Checks for conditions that are not on the same line as
# if/while/until.
#
# @example
#
#   # bad
#
#   if
#   some_condition
#   do_something
#   end
# @example
#
#   # good
#
#   if some_condition
#   do_something
#   end
#
# source://rubocop//lib/rubocop/cop/layout/condition_position.rb#25
class RuboCop::Cop::Layout::ConditionPosition < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/condition_position.rb#31
  def on_if(node); end

  # source://rubocop//lib/rubocop/cop/layout/condition_position.rb#37
  def on_until(node); end

  # source://rubocop//lib/rubocop/cop/layout/condition_position.rb#37
  def on_while(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/condition_position.rb#44
  def check(node); end

  # source://rubocop//lib/rubocop/cop/layout/condition_position.rb#58
  def message(condition); end
end

# source://rubocop//lib/rubocop/cop/layout/condition_position.rb#29
RuboCop::Cop::Layout::ConditionPosition::MSG = T.let(T.unsafe(nil), String)

# Checks whether the end keywords of method definitions are
# aligned properly.
#
# Two modes are supported through the EnforcedStyleAlignWith configuration
# parameter. If it's set to `start_of_line` (which is the default), the
# `end` shall be aligned with the start of the line where the `def`
# keyword is. If it's set to `def`, the `end` shall be aligned with the
# `def` keyword.
#
# @example EnforcedStyleAlignWith: start_of_line (default)
#   # bad
#
#   private def foo
#   end
#
#   # good
#
#   private def foo
#   end
# @example EnforcedStyleAlignWith: def
#   # bad
#
#   private def foo
#   end
#
#   # good
#
#   private def foo
#   end
#
# source://rubocop//lib/rubocop/cop/layout/def_end_alignment.rb#36
class RuboCop::Cop::Layout::DefEndAlignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::EndKeywordAlignment
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/def_end_alignment.rb#43
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/layout/def_end_alignment.rb#43
  def on_defs(node); end

  # source://rubocop//lib/rubocop/cop/layout/def_end_alignment.rb#48
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/def_end_alignment.rb#63
  def autocorrect(corrector, node); end
end

# source://rubocop//lib/rubocop/cop/layout/def_end_alignment.rb#41
RuboCop::Cop::Layout::DefEndAlignment::MSG = T.let(T.unsafe(nil), String)

# Checks the . position in multi-line method calls.
#
# @example EnforcedStyle: leading (default)
#   # bad
#   something.
#   method
#
#   # good
#   something
#   .method
# @example EnforcedStyle: trailing
#   # bad
#   something
#   .method
#
#   # good
#   something.
#   method
#
# source://rubocop//lib/rubocop/cop/layout/dot_position.rb#25
class RuboCop::Cop::Layout::DotPosition < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/dot_position.rb#34
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/layout/dot_position.rb#34
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/dot_position.rb#137
  def ampersand_dot?(node); end

  # source://rubocop//lib/rubocop/cop/layout/dot_position.rb#49
  def autocorrect(corrector, dot, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/dot_position.rb#99
  def correct_dot_position_style?(dot_line, selector_line); end

  # source://rubocop//lib/rubocop/cop/layout/dot_position.rb#126
  def end_range(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/dot_position.rb#122
  def heredoc?(node); end

  # source://rubocop//lib/rubocop/cop/layout/dot_position.rb#114
  def last_heredoc_line(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/dot_position.rb#95
  def line_between?(first_line, second_line); end

  # source://rubocop//lib/rubocop/cop/layout/dot_position.rb#64
  def message(dot); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/dot_position.rb#74
  def proper_dot_position?(node); end

  # source://rubocop//lib/rubocop/cop/layout/dot_position.rb#106
  def receiver_end_line(node); end

  # source://rubocop//lib/rubocop/cop/layout/dot_position.rb#130
  def selector_range(node); end

  class << self
    # source://rubocop//lib/rubocop/cop/layout/dot_position.rb#30
    def autocorrect_incompatible_with; end
  end
end

# Checks the alignment of else keywords. Normally they should
# be aligned with an if/unless/while/until/begin/def/rescue keyword, but there
# are special cases when they should follow the same rules as the
# alignment of end.
#
# @example
#   # bad
#   if something
#   code
#   else
#   code
#   end
#
#   # bad
#   if something
#   code
#   elsif something
#   code
#   end
#
#   # good
#   if something
#   code
#   else
#   code
#   end
#
# source://rubocop//lib/rubocop/cop/layout/else_alignment.rb#32
class RuboCop::Cop::Layout::ElseAlignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::CheckAssignment
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/else_alignment.rb#57
  def on_case(node); end

  # source://rubocop//lib/rubocop/cop/layout/else_alignment.rb#63
  def on_case_match(node); end

  # source://rubocop//lib/rubocop/cop/layout/else_alignment.rb#40
  def on_if(node, base = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/layout/else_alignment.rb#51
  def on_rescue(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/else_alignment.rb#147
  def assignment_node(node); end

  # source://rubocop//lib/rubocop/cop/layout/else_alignment.rb#71
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/layout/else_alignment.rb#106
  def base_for_method_definition(node); end

  # source://rubocop//lib/rubocop/cop/layout/else_alignment.rb#80
  def base_range_of_if(node, base); end

  # source://rubocop//lib/rubocop/cop/layout/else_alignment.rb#89
  def base_range_of_rescue(node); end

  # source://rubocop//lib/rubocop/cop/layout/else_alignment.rb#131
  def check_alignment(base_range, else_range); end

  # source://rubocop//lib/rubocop/cop/layout/else_alignment.rb#115
  def check_assignment(node, rhs); end

  # source://rubocop//lib/rubocop/cop/layout/else_alignment.rb#75
  def check_nested(node, base); end
end

# source://rubocop//lib/rubocop/cop/layout/else_alignment.rb#38
RuboCop::Cop::Layout::ElseAlignment::MSG = T.let(T.unsafe(nil), String)

# Checks empty comment.
#
# @example
#   # bad
#
#   #
#   class Foo
#   end
#
#   # good
#
#   #
#   # Description of `Foo` class.
#   #
#   class Foo
#   end
# @example AllowBorderComment: true (default)
#   # good
#
#   def foo
#   end
#
#   #################
#
#   def bar
#   end
# @example AllowBorderComment: false
#   # bad
#
#   def foo
#   end
#
#   #################
#
#   def bar
#   end
# @example AllowMarginComment: true (default)
#   # good
#
#   #
#   # Description of `Foo` class.
#   #
#   class Foo
#   end
# @example AllowMarginComment: false
#   # bad
#
#   #
#   # Description of `Foo` class.
#   #
#   class Foo
#   end
#
# source://rubocop//lib/rubocop/cop/layout/empty_comment.rb#63
class RuboCop::Cop::Layout::EmptyComment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/empty_comment.rb#69
  def on_new_investigation; end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_comment.rb#131
  def allow_border_comment?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_comment.rb#135
  def allow_margin_comment?; end

  # source://rubocop//lib/rubocop/cop/layout/empty_comment.rb#97
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_comment.rb#127
  def comment_text(comment); end

  # source://rubocop//lib/rubocop/cop/layout/empty_comment.rb#108
  def concat_consecutive_comments(comments); end

  # source://rubocop//lib/rubocop/cop/layout/empty_comment.rb#139
  def current_token(comment); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_comment.rb#117
  def empty_comment_only?(comment_text); end

  # source://rubocop//lib/rubocop/cop/layout/empty_comment.rb#85
  def investigate(comments); end

  # source://rubocop//lib/rubocop/cop/layout/empty_comment.rb#143
  def previous_token(node); end
end

# source://rubocop//lib/rubocop/cop/layout/empty_comment.rb#67
RuboCop::Cop::Layout::EmptyComment::MSG = T.let(T.unsafe(nil), String)

# Enforces empty line after guard clause
#
# @example
#
#   # bad
#   def foo
#   return if need_return?
#   bar
#   end
#
#   # good
#   def foo
#   return if need_return?
#
#   bar
#   end
#
#   # good
#   def foo
#   return if something?
#   return if something_different?
#
#   bar
#   end
#
#   # also good
#   def foo
#   if something?
#   do_something
#   return if need_return?
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#38
class RuboCop::Cop::Layout::EmptyLineAfterGuardClause < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::PathUtil
  extend ::RuboCop::Cop::Util

  # source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#46
  def on_if(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#65
  def autocorrect(corrector, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#87
  def contains_guard_clause?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#80
  def correct_style?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#160
  def heredoc?(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#153
  def heredoc_line(node, heredoc_node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#129
  def last_heredoc_argument(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#143
  def last_heredoc_argument_node(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#172
  def multiple_statements_on_line?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#98
  def next_line_empty?(line); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#91
  def next_line_empty_or_enable_directive_comment?(line); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#102
  def next_line_enable_directive_comment?(line); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#108
  def next_line_rescue_or_ensure?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#122
  def next_sibling_empty_or_guard_clause?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#113
  def next_sibling_parent_empty_or_else?(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#164
  def offense_location(node); end
end

# source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#44
RuboCop::Cop::Layout::EmptyLineAfterGuardClause::END_OF_HEREDOC_LINE = T.let(T.unsafe(nil), Integer)

# source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#43
RuboCop::Cop::Layout::EmptyLineAfterGuardClause::MSG = T.let(T.unsafe(nil), String)

# Checks for a newline after the final magic comment.
#
# @example
#   # good
#   # frozen_string_literal: true
#
#   # Some documentation for Person
#   class Person
#   # Some code
#   end
#
#   # bad
#   # frozen_string_literal: true
#   # Some documentation for Person
#   class Person
#   # Some code
#   end
#
# source://rubocop//lib/rubocop/cop/layout/empty_line_after_magic_comment.rb#23
class RuboCop::Cop::Layout::EmptyLineAfterMagicComment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/empty_line_after_magic_comment.rb#29
  def on_new_investigation; end

  private

  # Find the last magic comment in the source file.
  #
  # Take all comments that precede the first line of code, select the
  # magic comments, and return the last magic comment in the file.
  #
  # @return [Parser::Source::Comment] if magic comments exist before code
  # @return [nil] otherwise
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_line_after_magic_comment.rb#54
  def last_magic_comment(source); end

  # source://rubocop//lib/rubocop/cop/layout/empty_line_after_magic_comment.rb#43
  def offending_range(last_magic_comment); end
end

# source://rubocop//lib/rubocop/cop/layout/empty_line_after_magic_comment.rb#27
RuboCop::Cop::Layout::EmptyLineAfterMagicComment::MSG = T.let(T.unsafe(nil), String)

# Enforces empty line after multiline condition.
#
# @example
#   # bad
#   if multiline &&
#   condition
#   do_something
#   end
#
#   # good
#   if multiline &&
#   condition
#
#   do_something
#   end
#
#   # bad
#   case x
#   when foo,
#   bar
#   do_something
#   end
#
#   # good
#   case x
#   when foo,
#   bar
#
#   do_something
#   end
#
#   # bad
#   begin
#   do_something
#   rescue FooError,
#   BarError
#   handle_error
#   end
#
#   # good
#   begin
#   do_something
#   rescue FooError,
#   BarError
#
#   handle_error
#   end
#
# source://rubocop//lib/rubocop/cop/layout/empty_line_after_multiline_condition.rb#54
class RuboCop::Cop::Layout::EmptyLineAfterMultilineCondition < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/empty_line_after_multiline_condition.rb#82
  def on_case(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_line_after_multiline_condition.rb#60
  def on_if(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_line_after_multiline_condition.rb#93
  def on_rescue(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_line_after_multiline_condition.rb#70
  def on_until(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_line_after_multiline_condition.rb#75
  def on_until_post(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_line_after_multiline_condition.rb#70
  def on_while(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_line_after_multiline_condition.rb#75
  def on_while_post(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/empty_line_after_multiline_condition.rb#127
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_line_after_multiline_condition.rb#105
  def check_condition(condition); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_line_after_multiline_condition.rb#120
  def multiline_rescue_exceptions?(exception_nodes); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_line_after_multiline_condition.rb#116
  def multiline_when_condition?(when_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_line_after_multiline_condition.rb#112
  def next_line_empty?(line); end
end

# source://rubocop//lib/rubocop/cop/layout/empty_line_after_multiline_condition.rb#58
RuboCop::Cop::Layout::EmptyLineAfterMultilineCondition::MSG = T.let(T.unsafe(nil), String)

# Checks whether class/module/method definitions are
# separated by one or more empty lines.
#
# `NumberOfEmptyLines` can be an integer (default is 1) or
# an array (e.g. [1, 2]) to specify a minimum and maximum
# number of empty lines permitted.
#
# `AllowAdjacentOneLineDefs` configures whether adjacent
# one-line definitions are considered an offense.
#
# @example AllowAdjacentOneLineDefs: false
#
#   # bad
#   class ErrorA < BaseError; end
#   class ErrorB < BaseError; end
#   class ErrorC < BaseError; end
#
#   # good
#   class ErrorA < BaseError; end
#
#   class ErrorB < BaseError; end
#
#   class ErrorC < BaseError; end
# @example
#
#   # good
#   def a
#   end
#
#   def b
#   end
# @example EmptyLineBetweenClassDefs: true (default)
#   # checks for empty lines between class definitions.
#
#   # bad
#   class A
#   end
#   class B
#   end
#   def b
#   end
# @example
#
#   # good
#   class A
#   end
#
#   class B
#   end
#
#   def b
#   end
# @example EmptyLineBetweenModuleDefs: true (default)
#   # checks for empty lines between module definitions.
#
#   # bad
#   module A
#   end
#   module B
#   end
#   def b
#   end
# @example
#
#   # good
#   module A
#   end
#
#   module B
#   end
#
#   def b
#   end
# @example AllowAdjacentOneLineDefs: true (default)
#
#   # good
#   class ErrorA < BaseError; end
#   class ErrorB < BaseError; end
#   class ErrorC < BaseError; end
#
#   # good
#   class ErrorA < BaseError; end
#
#   class ErrorB < BaseError; end
#
#   class ErrorC < BaseError; end
# @example EmptyLineBetweenMethodDefs: true (default)
#   # checks for empty lines between method definitions.
#
#   # bad
#   def a
#   end
#   def b
#   end
#
# source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#108
class RuboCop::Cop::Layout::EmptyLineBetweenDefs < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#144
  def autocorrect(corrector, prev_def, node, count); end

  # source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#130
  def check_defs(nodes); end

  # We operate on `begin` nodes, instead of using `OnMethodDef`,
  # so that we can walk over pairs of consecutive nodes and
  # efficiently access a node's predecessor; #prev_node ends up
  # doing a linear scan over siblings, so we don't want to call
  # it on each def.
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#123
  def on_begin(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#267
  def allowance_range?; end

  # source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#251
  def autocorrect_insert_lines(corrector, newline_pos, count); end

  # source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#244
  def autocorrect_remove_lines(corrector, newline_pos, count); end

  # source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#208
  def blank_lines_count_between(first_def_node, second_def_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#162
  def candidate?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#172
  def class_candidate?(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#232
  def def_end(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#228
  def def_start(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#236
  def end_loc(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#186
  def expected_lines; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#204
  def line_count_allowed?(count); end

  # source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#220
  def lines_between_defs(first_def_node, second_def_node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#216
  def maximum_empty_lines; end

  # source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#180
  def message(node, count: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#168
  def method_candidate?(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#212
  def minimum_empty_lines; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#176
  def module_candidate?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#195
  def multiple_blank_lines_groups?(first_def_node, second_def_node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#258
  def node_type(node); end

  class << self
    # source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#114
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#112
RuboCop::Cop::Layout::EmptyLineBetweenDefs::MSG = T.let(T.unsafe(nil), String)

# Checks for two or more consecutive blank lines.
#
# @example
#
#   # bad - It has two empty lines.
#   some_method
#   # one empty line
#   # two empty lines
#   some_method
#
#   # good
#   some_method
#   # one empty line
#   some_method
#
# source://rubocop//lib/rubocop/cop/layout/empty_lines.rb#21
class RuboCop::Cop::Layout::EmptyLines < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/empty_lines.rb#28
  def on_new_investigation; end

  private

  # source://rubocop//lib/rubocop/cop/layout/empty_lines.rb#45
  def each_extra_empty_line(lines); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_lines.rb#63
  def exceeds_line_offset?(line_diff); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_lines.rb#67
  def previous_and_current_lines_empty?(line); end
end

# source://rubocop//lib/rubocop/cop/layout/empty_lines.rb#26
RuboCop::Cop::Layout::EmptyLines::LINE_OFFSET = T.let(T.unsafe(nil), Integer)

# source://rubocop//lib/rubocop/cop/layout/empty_lines.rb#25
RuboCop::Cop::Layout::EmptyLines::MSG = T.let(T.unsafe(nil), String)

# Access modifiers should be surrounded by blank lines.
#
# @example EnforcedStyle: around (default)
#
#   # bad
#   class Foo
#   def bar; end
#   private
#   def baz; end
#   end
#
#   # good
#   class Foo
#   def bar; end
#
#   private
#
#   def baz; end
#   end
# @example EnforcedStyle: only_before
#
#   # bad
#   class Foo
#   def bar; end
#   private
#   def baz; end
#   end
#
#   # good
#   class Foo
#   def bar; end
#
#   private
#   def baz; end
#   end
#
# source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#43
class RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # @return [EmptyLinesAroundAccessModifier] a new instance of EmptyLinesAroundAccessModifier
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#56
  def initialize(config = T.unsafe(nil), options = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#81
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#62
  def on_class(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#71
  def on_module(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#81
  def on_numblock(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#76
  def on_sclass(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#87
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#115
  def allowed_only_before_style?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#164
  def block_start?(line); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#170
  def body_end?(line); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#158
  def class_def?(line); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#124
  def correct_next_line_if_denied_style(corrector, node, line); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#154
  def empty_lines_around?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#104
  def expected_empty_lines?(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#180
  def message(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#189
  def message_for_around_style(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#199
  def message_for_only_before_style(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#176
  def next_empty_line_range(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#148
  def next_line_empty?(last_send_line); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#141
  def previous_line_empty?(send_line); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#137
  def previous_line_ignoring_comments(processed_source, send_line); end
end

# source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#48
RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier::MSG_AFTER = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#52
RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier::MSG_AFTER_FOR_ONLY_BEFORE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#49
RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier::MSG_BEFORE_AND_AFTER = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#51
RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier::MSG_BEFORE_FOR_ONLY_BEFORE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#54
RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks if empty lines exist around the arguments
# of a method invocation.
#
# @example
#   # bad
#   do_something(
#   foo
#
#   )
#
#   process(bar,
#
#   baz: qux,
#   thud: fred)
#
#   some_method(
#
#   [1,2,3],
#   x: y
#   )
#
#   # good
#   do_something(
#   foo
#   )
#
#   process(bar,
#   baz: qux,
#   thud: fred)
#
#   some_method(
#   [1,2,3],
#   x: y
#   )
#
# source://rubocop//lib/rubocop/cop/layout/empty_lines_around_arguments.rb#41
class RuboCop::Cop::Layout::EmptyLinesAroundArguments < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_arguments.rb#47
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_arguments.rb#47
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_arguments.rb#65
  def empty_lines(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_arguments.rb#71
  def extra_lines(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_arguments.rb#93
  def inner_lines(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_arguments.rb#84
  def line_numbers(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_arguments.rb#97
  def outer_lines(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_arguments.rb#78
  def processed_lines(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_arguments.rb#61
  def receiver_and_method_call_on_different_lines?(node); end
end

# source://rubocop//lib/rubocop/cop/layout/empty_lines_around_arguments.rb#45
RuboCop::Cop::Layout::EmptyLinesAroundArguments::MSG = T.let(T.unsafe(nil), String)

# Checks for a newline after an attribute accessor or a group of them.
# `alias` syntax and `alias_method`, `public`, `protected`, and `private` methods are allowed
# by default. These are customizable with `AllowAliasSyntax` and `AllowedMethods` options.
#
# @example
#   # bad
#   attr_accessor :foo
#   def do_something
#   end
#
#   # good
#   attr_accessor :foo
#
#   def do_something
#   end
#
#   # good
#   attr_accessor :foo
#   attr_reader :bar
#   attr_writer :baz
#   attr :qux
#
#   def do_something
#   end
# @example AllowAliasSyntax: true (default)
#   # good
#   attr_accessor :foo
#   alias :foo? :foo
#
#   def do_something
#   end
# @example AllowAliasSyntax: false
#   # bad
#   attr_accessor :foo
#   alias :foo? :foo
#
#   def do_something
#   end
#
#   # good
#   attr_accessor :foo
#
#   alias :foo? :foo
#
#   def do_something
#   end
# @example AllowedMethods: ['private']
#   # good
#   attr_accessor :foo
#   private :foo
#
#   def do_something
#   end
#
# source://rubocop//lib/rubocop/cop/layout/empty_lines_around_attribute_accessor.rb#63
class RuboCop::Cop::Layout::EmptyLinesAroundAttributeAccessor < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::AllowedMethods
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_attribute_accessor.rb#70
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_attribute_accessor.rb#123
  def allow_alias?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_attribute_accessor.rb#133
  def allow_alias_syntax?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_attribute_accessor.rb#127
  def attribute_or_allowed_method?(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_attribute_accessor.rb#83
  def autocorrect(corrector, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_attribute_accessor.rb#107
  def next_line_empty?(line); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_attribute_accessor.rb#94
  def next_line_empty_or_enable_directive_comment?(line); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_attribute_accessor.rb#101
  def next_line_enable_directive_comment?(line); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_attribute_accessor.rb#117
  def next_line_node(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_attribute_accessor.rb#111
  def require_empty_line?(node); end
end

# source://rubocop//lib/rubocop/cop/layout/empty_lines_around_attribute_accessor.rb#68
RuboCop::Cop::Layout::EmptyLinesAroundAttributeAccessor::MSG = T.let(T.unsafe(nil), String)

# Checks if empty lines exist around the bodies of begin-end
# blocks.
#
# @example
#
#   # good
#
#   begin
#   # ...
#   end
#
#   # bad
#
#   begin
#
#   # ...
#
#   end
#
# source://rubocop//lib/rubocop/cop/layout/empty_lines_around_begin_body.rb#24
class RuboCop::Cop::Layout::EmptyLinesAroundBeginBody < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_begin_body.rb#30
  def on_kwbegin(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_begin_body.rb#36
  def style; end
end

# source://rubocop//lib/rubocop/cop/layout/empty_lines_around_begin_body.rb#28
RuboCop::Cop::Layout::EmptyLinesAroundBeginBody::KIND = T.let(T.unsafe(nil), String)

# Checks if empty lines around the bodies of blocks match
# the configuration.
#
# @example EnforcedStyle: no_empty_lines (default)
#   # good
#
#   foo do |bar|
#   # ...
#   end
# @example EnforcedStyle: empty_lines
#   # good
#
#   foo do |bar|
#
#   # ...
#
#   end
#
# source://rubocop//lib/rubocop/cop/layout/empty_lines_around_block_body.rb#24
class RuboCop::Cop::Layout::EmptyLinesAroundBlockBody < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_block_body.rb#30
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_block_body.rb#30
  def on_numblock(node); end
end

# source://rubocop//lib/rubocop/cop/layout/empty_lines_around_block_body.rb#28
RuboCop::Cop::Layout::EmptyLinesAroundBlockBody::KIND = T.let(T.unsafe(nil), String)

# Common functionality for checking if presence/absence of empty lines
# around some kind of body matches the configuration.
#
# source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#8
module RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::AST::NodePattern::Macros

  # source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#20
  def constant_definition?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#23
  def empty_line_required?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#26
  def check(node, body, adjusted_first_line: T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#81
  def check_beginning(style, first_line); end

  # source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#67
  def check_both(style, first_line, last_line); end

  # source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#108
  def check_deferred_empty_line(body); end

  # source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#43
  def check_empty_lines_except_namespace(body, first_line, last_line); end

  # source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#51
  def check_empty_lines_special(body, first_line, last_line); end

  # source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#85
  def check_ending(style, last_line); end

  # source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#98
  def check_line(style, line, msg); end

  # source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#89
  def check_source(style, line_no, desc); end

  # source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#159
  def deferred_message(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#132
  def first_child_requires_empty_line?(body); end

  # source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#140
  def first_empty_line_required_child(body); end

  # source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#155
  def message(type, desc); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#122
  def namespace?(body, with_one_child: T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#148
  def previous_line_ignoring_comments(send_line); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#163
  def valid_body_style?(body); end
end

# source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#15
RuboCop::Cop::Layout::EmptyLinesAroundBody::MSG_DEFERRED = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#13
RuboCop::Cop::Layout::EmptyLinesAroundBody::MSG_EXTRA = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#14
RuboCop::Cop::Layout::EmptyLinesAroundBody::MSG_MISSING = T.let(T.unsafe(nil), String)

# Checks if empty lines around the bodies of classes match
# the configuration.
#
# @example EnforcedStyle: no_empty_lines (default)
#   # good
#
#   class Foo
#   def bar
#   # ...
#   end
#   end
# @example EnforcedStyle: empty_lines
#   # good
#
#   class Foo
#
#   def bar
#   # ...
#   end
#
#   end
# @example EnforcedStyle: empty_lines_except_namespace
#   # good
#
#   class Foo
#   class Bar
#
#   # ...
#
#   end
#   end
# @example EnforcedStyle: empty_lines_special
#   # good
#   class Foo
#
#   def bar; end
#
#   end
# @example EnforcedStyle: beginning_only
#   # good
#
#   class Foo
#
#   def bar
#   # ...
#   end
#   end
# @example EnforcedStyle: ending_only
#   # good
#
#   class Foo
#   def bar
#   # ...
#   end
#
#   end
#
# source://rubocop//lib/rubocop/cop/layout/empty_lines_around_class_body.rb#67
class RuboCop::Cop::Layout::EmptyLinesAroundClassBody < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_class_body.rb#73
  def on_class(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_class_body.rb#79
  def on_sclass(node); end
end

# source://rubocop//lib/rubocop/cop/layout/empty_lines_around_class_body.rb#71
RuboCop::Cop::Layout::EmptyLinesAroundClassBody::KIND = T.let(T.unsafe(nil), String)

# Checks if empty lines exist around the bodies of `begin`
# sections. This cop doesn't check empty lines at `begin` body
# beginning/end and around method definition body.
# `Style/EmptyLinesAroundBeginBody` or `Style/EmptyLinesAroundMethodBody`
# can be used for this purpose.
#
# @example
#
#   # good
#
#   begin
#   do_something
#   rescue
#   do_something2
#   else
#   do_something3
#   ensure
#   do_something4
#   end
#
#   # good
#
#   def foo
#   do_something
#   rescue
#   do_something2
#   end
#
#   # bad
#
#   begin
#   do_something
#
#   rescue
#
#   do_something2
#
#   else
#
#   do_something3
#
#   ensure
#
#   do_something4
#   end
#
#   # bad
#
#   def foo
#   do_something
#
#   rescue
#
#   do_something2
#   end
#
# source://rubocop//lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#61
class RuboCop::Cop::Layout::EmptyLinesAroundExceptionHandlingKeywords < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#67
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#67
  def on_defs(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#72
  def on_kwbegin(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#79
  def check_body(body, line_of_def_or_kwbegin); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#106
  def keyword_locations(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#123
  def keyword_locations_in_ensure(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#119
  def keyword_locations_in_rescue(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#94
  def last_rescue_and_end_on_same_line(body); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#98
  def message(location, keyword); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#102
  def style; end
end

# source://rubocop//lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#65
RuboCop::Cop::Layout::EmptyLinesAroundExceptionHandlingKeywords::MSG = T.let(T.unsafe(nil), String)

# Checks if empty lines exist around the bodies of methods.
#
# @example
#
#   # good
#
#   def foo
#   # ...
#   end
#
#   # bad
#
#   def bar
#
#   # ...
#
#   end
#
# source://rubocop//lib/rubocop/cop/layout/empty_lines_around_method_body.rb#23
class RuboCop::Cop::Layout::EmptyLinesAroundMethodBody < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_method_body.rb#29
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_method_body.rb#29
  def on_defs(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_method_body.rb#36
  def style; end
end

# source://rubocop//lib/rubocop/cop/layout/empty_lines_around_method_body.rb#27
RuboCop::Cop::Layout::EmptyLinesAroundMethodBody::KIND = T.let(T.unsafe(nil), String)

# Checks if empty lines around the bodies of modules match
# the configuration.
#
# @example EnforcedStyle: no_empty_lines (default)
#   # good
#
#   module Foo
#   def bar
#   # ...
#   end
#   end
# @example EnforcedStyle: empty_lines
#   # good
#
#   module Foo
#
#   def bar
#   # ...
#   end
#
#   end
# @example EnforcedStyle: empty_lines_except_namespace
#   # good
#
#   module Foo
#   module Bar
#
#   # ...
#
#   end
#   end
# @example EnforcedStyle: empty_lines_special
#   # good
#   module Foo
#
#   def bar; end
#
#   end
#
# source://rubocop//lib/rubocop/cop/layout/empty_lines_around_module_body.rb#47
class RuboCop::Cop::Layout::EmptyLinesAroundModuleBody < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_module_body.rb#53
  def on_module(node); end
end

# source://rubocop//lib/rubocop/cop/layout/empty_lines_around_module_body.rb#51
RuboCop::Cop::Layout::EmptyLinesAroundModuleBody::KIND = T.let(T.unsafe(nil), String)

# Checks whether the end keywords are aligned properly.
#
# Three modes are supported through the `EnforcedStyleAlignWith`
# configuration parameter:
#
# If it's set to `keyword` (which is the default), the `end`
# shall be aligned with the start of the keyword (if, class, etc.).
#
# If it's set to `variable` the `end` shall be aligned with the
# left-hand-side of the variable assignment, if there is one.
#
# If it's set to `start_of_line`, the `end` shall be aligned with the
# start of the line where the matching keyword appears.
#
# This `Layout/EndAlignment` cop aligns with keywords (e.g. `if`, `while`, `case`)
# by default. On the other hand, `Layout/BeginEndAlignment` cop aligns with
# `EnforcedStyleAlignWith: start_of_line` by default due to `||= begin` tends
# to align with the start of the line. These style can be configured by each cop.
#
# @example EnforcedStyleAlignWith: keyword (default)
#   # bad
#
#   variable = if true
#   end
#
#   # good
#
#   variable = if true
#   end
#
#   variable =
#   if true
#   end
# @example EnforcedStyleAlignWith: variable
#   # bad
#
#   variable = if true
#   end
#
#   # good
#
#   variable = if true
#   end
#
#   variable =
#   if true
#   end
# @example EnforcedStyleAlignWith: start_of_line
#   # bad
#
#   variable = if true
#   end
#
#   puts(if true
#   end)
#
#   # good
#
#   variable = if true
#   end
#
#   puts(if true
#   end)
#
#   variable =
#   if true
#   end
#
# source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#75
class RuboCop::Cop::Layout::EndAlignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::EndKeywordAlignment
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#105
  def on_case(node); end

  # source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#105
  def on_case_match(node); end

  # source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#81
  def on_class(node); end

  # source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#93
  def on_if(node); end

  # source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#89
  def on_module(node); end

  # source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#85
  def on_sclass(node); end

  # source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#101
  def on_until(node); end

  # source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#97
  def on_while(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#161
  def alignment_node(node); end

  # source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#172
  def alignment_node_for_variable_style(node); end

  # source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#142
  def asgn_variable_align_with(outer_node, inner_node); end

  # source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#190
  def assignment_or_operator_method(node); end

  # source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#116
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#131
  def check_asgn_alignment(outer_node, inner_node); end

  # source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#120
  def check_assignment(node, rhs); end

  # source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#152
  def check_other_alignment(node); end
end

# Checks for Windows-style line endings in the source code.
#
# @example EnforcedStyle: native (default)
#   # The `native` style means that CR+LF (Carriage Return + Line Feed) is
#   # enforced on Windows, and LF is enforced on other platforms.
#
#   # bad
#   puts 'Hello' # Return character is LF on Windows.
#   puts 'Hello' # Return character is CR+LF on other than Windows.
#
#   # good
#   puts 'Hello' # Return character is CR+LF on Windows.
#   puts 'Hello' # Return character is LF on other than Windows.
# @example EnforcedStyle: lf
#   # The `lf` style means that LF (Line Feed) is enforced on
#   # all platforms.
#
#   # bad
#   puts 'Hello' # Return character is CR+LF on all platforms.
#
#   # good
#   puts 'Hello' # Return character is LF on all platforms.
# @example EnforcedStyle: crlf
#   # The `crlf` style means that CR+LF (Carriage Return + Line Feed) is
#   # enforced on all platforms.
#
#   # bad
#   puts 'Hello' # Return character is LF on all platforms.
#
#   # good
#   puts 'Hello' # Return character is CR+LF on all platforms.
#
# source://rubocop//lib/rubocop/cop/layout/end_of_line.rb#40
class RuboCop::Cop::Layout::EndOfLine < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/layout/end_of_line.rb#71
  def offense_message(line); end

  # source://rubocop//lib/rubocop/cop/layout/end_of_line.rb#47
  def on_new_investigation; end

  # If there is no LF on the last line, we don't care if there's no CR.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/end_of_line.rb#67
  def unimportant_missing_cr?(index, last_line, line); end

  private

  # source://rubocop//lib/rubocop/cop/layout/end_of_line.rb#85
  def last_line(processed_source); end
end

# source://rubocop//lib/rubocop/cop/layout/end_of_line.rb#44
RuboCop::Cop::Layout::EndOfLine::MSG_DETECTED = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/end_of_line.rb#45
RuboCop::Cop::Layout::EndOfLine::MSG_MISSING = T.let(T.unsafe(nil), String)

# Checks for extra/unnecessary whitespace.
#
# @example
#
#   # good if AllowForAlignment is true
#   name      = "RuboCop"
#   # Some comment and an empty line
#
#   website  += "/rubocop/rubocop" unless cond
#   puts        "rubocop"          if     debug
#
#   # bad for any configuration
#   set_app("RuboCop")
#   website  = "https://github.com/rubocop/rubocop"
#
#   # good only if AllowBeforeTrailingComments is true
#   object.method(arg)  # this is a comment
#
#   # good even if AllowBeforeTrailingComments is false or not set
#   object.method(arg) # this is a comment
#
#   # good with either AllowBeforeTrailingComments or AllowForAlignment
#   object.method(arg)         # this is a comment
#   another_object.method(arg) # this is another comment
#   some_object.method(arg)    # this is some comment
#
# source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#31
class RuboCop::Cop::Layout::ExtraSpacing < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::PrecedingFollowingAlignment
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#39
  def on_new_investigation; end

  private

  # source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#176
  def align_column(asgn_token); end

  # source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#153
  def align_equal_sign(corrector, token, align_to); end

  # source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#143
  def align_equal_signs(range, corrector); end

  # source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#52
  def aligned_locations(locs); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#109
  def aligned_tok?(token); end

  # source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#165
  def all_relevant_assignment_lines(line_number); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#185
  def allow_for_trailing_comments?; end

  # source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#78
  def check_assignment(token); end

  # source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#87
  def check_other(token1, token2, ast); end

  # source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#68
  def check_tokens(ast, token1, token2); end

  # @yield [range_between(start_pos, end_pos)]
  #
  # source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#97
  def extra_space_range(token1, token2); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#139
  def force_equal_sign_alignment?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#117
  def ignored_range?(ast, start_pos); end

  # Returns an array of ranges that should not be reported. It's the
  # extra spaces between the keys and values in a multiline hash,
  # since those are handled by the Layout/HashAlignment cop.
  #
  # source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#124
  def ignored_ranges(ast); end
end

# source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#37
RuboCop::Cop::Layout::ExtraSpacing::MSG_UNALIGNED_ASGN = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#36
RuboCop::Cop::Layout::ExtraSpacing::MSG_UNNECESSARY = T.let(T.unsafe(nil), String)

# Checks the indentation of the first argument in a method call.
# Arguments after the first one are checked by `Layout/ArgumentAlignment`,
# not by this cop.
#
# For indenting the first parameter of method _definitions_, check out
# `Layout/FirstParameterIndentation`.
#
# This cop will respect `Layout/ArgumentAlignment` and will not work when
# `EnforcedStyle: with_fixed_indentation` is specified for `Layout/ArgumentAlignment`.
#
# @example
#
#   # bad
#   some_method(
#   first_param,
#   second_param)
#
#   foo = some_method(
#   first_param,
#   second_param)
#
#   foo = some_method(nested_call(
#   nested_first_param),
#   second_param)
#
#   foo = some_method(
#   nested_call(
#   nested_first_param),
#   second_param)
#
#   some_method nested_call(
#   nested_first_param),
#   second_param
# @example EnforcedStyle: special_for_inner_method_call_in_parentheses (default)
#   # Same as `special_for_inner_method_call` except that the special rule
#   # only applies if the outer method call encloses its arguments in
#   # parentheses.
#
#   # good
#   some_method(
#   first_param,
#   second_param)
#
#   foo = some_method(
#   first_param,
#   second_param)
#
#   foo = some_method(nested_call(
#   nested_first_param),
#   second_param)
#
#   foo = some_method(
#   nested_call(
#   nested_first_param),
#   second_param)
#
#   some_method nested_call(
#   nested_first_param),
#   second_param
# @example EnforcedStyle: consistent
#   # The first argument should always be indented one step more than the
#   # preceding line.
#
#   # good
#   some_method(
#   first_param,
#   second_param)
#
#   foo = some_method(
#   first_param,
#   second_param)
#
#   foo = some_method(nested_call(
#   nested_first_param),
#   second_param)
#
#   foo = some_method(
#   nested_call(
#   nested_first_param),
#   second_param)
#
#   some_method nested_call(
#   nested_first_param),
#   second_param
# @example EnforcedStyle: consistent_relative_to_receiver
#   # The first argument should always be indented one level relative to
#   # the parent that is receiving the argument
#
#   # good
#   some_method(
#   first_param,
#   second_param)
#
#   foo = some_method(
#   first_param,
#   second_param)
#
#   foo = some_method(nested_call(
#   nested_first_param),
#   second_param)
#
#   foo = some_method(
#   nested_call(
#   nested_first_param),
#   second_param)
#
#   some_method nested_call(
#   nested_first_param),
#   second_params
# @example EnforcedStyle: special_for_inner_method_call
#   # The first argument should normally be indented one step more than
#   # the preceding line, but if it's a argument for a method call that
#   # is itself a argument in a method call, then the inner argument
#   # should be indented relative to the inner method.
#
#   # good
#   some_method(
#   first_param,
#   second_param)
#
#   foo = some_method(
#   first_param,
#   second_param)
#
#   foo = some_method(nested_call(
#   nested_first_param),
#   second_param)
#
#   foo = some_method(
#   nested_call(
#   nested_first_param),
#   second_param)
#
#   some_method nested_call(
#   nested_first_param),
#   second_param
#
# source://rubocop//lib/rubocop/cop/layout/first_argument_indentation.rb#147
class RuboCop::Cop::Layout::FirstArgumentIndentation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/first_argument_indentation.rb#222
  def eligible_method_call?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/layout/first_argument_indentation.rb#155
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/layout/first_argument_indentation.rb#155
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/layout/first_argument_indentation.rb#155
  def on_super(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/first_argument_indentation.rb#281
  def argument_alignment_config; end

  # source://rubocop//lib/rubocop/cop/layout/first_argument_indentation.rb#174
  def autocorrect(corrector, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/first_argument_indentation.rb#178
  def bare_operator?(node); end

  # source://rubocop//lib/rubocop/cop/layout/first_argument_indentation.rb#198
  def base_indentation(node); end

  # source://rubocop//lib/rubocop/cop/layout/first_argument_indentation.rb#226
  def base_range(send_node, arg_node); end

  # Returns the column of the given range. For single line ranges, this
  # is simple. For ranges with line breaks, we look a the last code line.
  #
  # source://rubocop//lib/rubocop/cop/layout/first_argument_indentation.rb#238
  def column_of(range); end

  # source://rubocop//lib/rubocop/cop/layout/first_argument_indentation.rb#259
  def comment_lines; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/first_argument_indentation.rb#277
  def enable_layout_first_method_argument_line_break?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/first_argument_indentation.rb#271
  def enforce_first_argument_with_fixed_indentation?; end

  # source://rubocop//lib/rubocop/cop/layout/first_argument_indentation.rb#182
  def message(arg_node); end

  # source://rubocop//lib/rubocop/cop/layout/first_argument_indentation.rb#267
  def on_new_investigation; end

  # Takes the line number of a given code line and returns a string
  # containing the previous line that's not a comment line or a blank
  # line.
  #
  # source://rubocop//lib/rubocop/cop/layout/first_argument_indentation.rb#250
  def previous_code_line(line_number); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/first_argument_indentation.rb#170
  def should_check?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/first_argument_indentation.rb#206
  def special_inner_call_indentation?(node); end
end

# source://rubocop//lib/rubocop/cop/layout/first_argument_indentation.rb#153
RuboCop::Cop::Layout::FirstArgumentIndentation::MSG = T.let(T.unsafe(nil), String)

# Checks the indentation of the first element in an array literal
# where the opening bracket and the first element are on separate lines.
# The other elements' indentations are handled by the ArrayAlignment cop.
#
# By default, array literals that are arguments in a method call with
# parentheses, and where the opening square bracket of the array is on the
# same line as the opening parenthesis of the method call, shall have
# their first element indented one step (two spaces) more than the
# position inside the opening parenthesis.
#
# Other array literals shall have their first element indented one step
# more than the start of the line where the opening square bracket is.
#
# This default style is called 'special_inside_parentheses'. Alternative
# styles are 'consistent' and 'align_brackets'. Here are examples:
#
# @example EnforcedStyle: special_inside_parentheses (default)
#   # The `special_inside_parentheses` style enforces that the first
#   # element in an array literal where the opening bracket and first
#   # element are on separate lines is indented one step (two spaces) more
#   # than the position inside the opening parenthesis.
#
#   #bad
#   array = [
#   :value
#   ]
#   and_in_a_method_call([
#   :no_difference
#   ])
#
#   #good
#   array = [
#   :value
#   ]
#   but_in_a_method_call([
#   :its_like_this
#   ])
# @example EnforcedStyle: consistent
#   # The `consistent` style enforces that the first element in an array
#   # literal where the opening bracket and the first element are on
#   # separate lines is indented the same as an array literal which is not
#   # defined inside a method call.
#
#   #bad
#   # consistent
#   array = [
#   :value
#   ]
#   but_in_a_method_call([
#   :its_like_this
#   ])
#
#   #good
#   array = [
#   :value
#   ]
#   and_in_a_method_call([
#   :no_difference
#   ])
# @example EnforcedStyle: align_brackets
#   # The `align_brackets` style enforces that the opening and closing
#   # brackets are indented to the same position.
#
#   #bad
#   # align_brackets
#   and_now_for_something = [
#   :completely_different
#   ]
#
#   #good
#   # align_brackets
#   and_now_for_something = [
#   :completely_different
#   ]
#
# source://rubocop//lib/rubocop/cop/layout/first_array_element_indentation.rb#82
class RuboCop::Cop::Layout::FirstArrayElementIndentation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineElementIndentation
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/first_array_element_indentation.rb#91
  def on_array(node); end

  # source://rubocop//lib/rubocop/cop/layout/first_array_element_indentation.rb#95
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/layout/first_array_element_indentation.rb#95
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/first_array_element_indentation.rb#104
  def autocorrect(corrector, node); end

  # Returns the description of what the correct indentation is based on.
  #
  # source://rubocop//lib/rubocop/cop/layout/first_array_element_indentation.rb#142
  def base_description(indent_base_type); end

  # source://rubocop//lib/rubocop/cop/layout/first_array_element_indentation.rb#108
  def brace_alignment_style; end

  # source://rubocop//lib/rubocop/cop/layout/first_array_element_indentation.rb#112
  def check(array_node, left_parenthesis); end

  # source://rubocop//lib/rubocop/cop/layout/first_array_element_indentation.rb#126
  def check_right_bracket(right_bracket, first_elem, left_bracket, left_parenthesis); end

  # source://rubocop//lib/rubocop/cop/layout/first_array_element_indentation.rb#155
  def message(base_description); end

  # source://rubocop//lib/rubocop/cop/layout/first_array_element_indentation.rb#163
  def message_for_right_bracket(indent_base_type); end
end

# source://rubocop//lib/rubocop/cop/layout/first_array_element_indentation.rb#88
RuboCop::Cop::Layout::FirstArrayElementIndentation::MSG = T.let(T.unsafe(nil), String)

# Checks for a line break before the first element in a
# multi-line array.
#
# @example AllowMultilineFinalElement: false (default)
#
#   # bad
#   [ :a,
#   :b]
#
#   # bad
#   [ :a, {
#   :b => :c
#   }]
#
#   # good
#   [:a, :b]
#
#   # good
#   [
#   :a,
#   :b]
#
#   # good
#   [
#   :a, {
#   :b => :c
#   }]
# @example AllowMultilineFinalElement: true
#
#   # bad
#   [ :a,
#   :b]
#
#   # good
#   [ :a, {
#   :b => :c
#   }]
#
#   # good
#   [
#   :a,
#   :b]
#
#   # good
#   [:a, :b]
#
# source://rubocop//lib/rubocop/cop/layout/first_array_element_line_break.rb#52
class RuboCop::Cop::Layout::FirstArrayElementLineBreak < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::FirstElementLineBreak
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/first_array_element_line_break.rb#58
  def on_array(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/first_array_element_line_break.rb#66
  def assignment_on_same_line?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/first_array_element_line_break.rb#71
  def ignore_last_element?; end
end

# source://rubocop//lib/rubocop/cop/layout/first_array_element_line_break.rb#56
RuboCop::Cop::Layout::FirstArrayElementLineBreak::MSG = T.let(T.unsafe(nil), String)

# Checks the indentation of the first key in a hash literal
# where the opening brace and the first key are on separate lines. The
# other keys' indentations are handled by the HashAlignment cop.
#
# By default, Hash literals that are arguments in a method call with
# parentheses, and where the opening curly brace of the hash is on the
# same line as the opening parenthesis of the method call, shall have
# their first key indented one step (two spaces) more than the position
# inside the opening parenthesis.
#
# Other hash literals shall have their first key indented one step more
# than the start of the line where the opening curly brace is.
#
# This default style is called 'special_inside_parentheses'. Alternative
# styles are 'consistent' and 'align_braces'. Here are examples:
#
# @example EnforcedStyle: special_inside_parentheses (default)
#   # The `special_inside_parentheses` style enforces that the first key
#   # in a hash literal where the opening brace and the first key are on
#   # separate lines is indented one step (two spaces) more than the
#   # position inside the opening parentheses.
#
#   # bad
#   hash = {
#   key: :value
#   }
#   and_in_a_method_call({
#   no: :difference
#   })
#   takes_multi_pairs_hash(x: {
#   a: 1,
#   b: 2
#   },
#   y: {
#   c: 1,
#   d: 2
#   })
#
#   # good
#   special_inside_parentheses
#   hash = {
#   key: :value
#   }
#   but_in_a_method_call({
#   its_like: :this
#   })
#   takes_multi_pairs_hash(x: {
#   a: 1,
#   b: 2
#   },
#   y: {
#   c: 1,
#   d: 2
#   })
# @example EnforcedStyle: consistent
#   # The `consistent` style enforces that the first key in a hash
#   # literal where the opening brace and the first key are on
#   # separate lines is indented the same as a hash literal which is not
#   # defined inside a method call.
#
#   # bad
#   hash = {
#   key: :value
#   }
#   but_in_a_method_call({
#   its_like: :this
#   })
#
#   # good
#   hash = {
#   key: :value
#   }
#   and_in_a_method_call({
#   no: :difference
#   })
# @example EnforcedStyle: align_braces
#   # The `align_brackets` style enforces that the opening and closing
#   # braces are indented to the same position.
#
#   # bad
#   and_now_for_something = {
#   completely: :different
#   }
#   takes_multi_pairs_hash(x: {
#   a: 1,
#   b: 2
#   },
#   y: {
#   c: 1,
#   d: 2
#   })
#
#   # good
#   and_now_for_something = {
#   completely: :different
#   }
#   takes_multi_pairs_hash(x: {
#   a: 1,
#   b: 2
#   },
#   y: {
#   c: 1,
#   d: 2
#   })
#
# source://rubocop//lib/rubocop/cop/layout/first_hash_element_indentation.rb#113
class RuboCop::Cop::Layout::FirstHashElementIndentation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineElementIndentation
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/first_hash_element_indentation.rb#126
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/layout/first_hash_element_indentation.rb#122
  def on_hash(node); end

  # source://rubocop//lib/rubocop/cop/layout/first_hash_element_indentation.rb#126
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/first_hash_element_indentation.rb#233
  def argument_alignment_config; end

  # source://rubocop//lib/rubocop/cop/layout/first_hash_element_indentation.rb#137
  def autocorrect(corrector, node); end

  # Returns the description of what the correct indentation is based on.
  #
  # source://rubocop//lib/rubocop/cop/layout/first_hash_element_indentation.rb#191
  def base_description(indent_base_type); end

  # source://rubocop//lib/rubocop/cop/layout/first_hash_element_indentation.rb#141
  def brace_alignment_style; end

  # source://rubocop//lib/rubocop/cop/layout/first_hash_element_indentation.rb#145
  def check(hash_node, left_parenthesis); end

  # source://rubocop//lib/rubocop/cop/layout/first_hash_element_indentation.rb#184
  def check_based_on_longest_key(hash_node, left_brace, left_parenthesis); end

  # source://rubocop//lib/rubocop/cop/layout/first_hash_element_indentation.rb#164
  def check_right_brace(right_brace, first_pair, left_brace, left_parenthesis); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/first_hash_element_indentation.rb#227
  def enforce_first_argument_with_fixed_indentation?; end

  # source://rubocop//lib/rubocop/cop/layout/first_hash_element_indentation.rb#204
  def message(base_description); end

  # source://rubocop//lib/rubocop/cop/layout/first_hash_element_indentation.rb#212
  def message_for_right_brace(indent_base_type); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/first_hash_element_indentation.rb#178
  def separator_style?(first_pair); end
end

# source://rubocop//lib/rubocop/cop/layout/first_hash_element_indentation.rb#119
RuboCop::Cop::Layout::FirstHashElementIndentation::MSG = T.let(T.unsafe(nil), String)

# Checks for a line break before the first element in a
# multi-line hash.
#
# @example AllowMultilineFinalElement: false (default)
#
#   # bad
#   { a: 1,
#   b: 2}
#
#   # bad
#   { a: 1, b: {
#   c: 3
#   }}
#
#   # good
#   {
#   a: 1,
#   b: 2 }
#
#   # good
#   {
#   a: 1, b: {
#   c: 3
#   }}
# @example AllowMultilineFinalElement: true
#
#   # bad
#   { a: 1,
#   b: 2}
#
#   # bad
#   { a: 1,
#   b: {
#   c: 3
#   }}
#
#   # good
#   { a: 1, b: {
#   c: 3
#   }}
#
#   # good
#   {
#   a: 1,
#   b: 2 }
#
#   # good
#   {
#   a: 1, b: {
#   c: 3
#   }}
#
# source://rubocop//lib/rubocop/cop/layout/first_hash_element_line_break.rb#58
class RuboCop::Cop::Layout::FirstHashElementLineBreak < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::FirstElementLineBreak
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/first_hash_element_line_break.rb#64
  def on_hash(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/first_hash_element_line_break.rb#74
  def ignore_last_element?; end
end

# source://rubocop//lib/rubocop/cop/layout/first_hash_element_line_break.rb#62
RuboCop::Cop::Layout::FirstHashElementLineBreak::MSG = T.let(T.unsafe(nil), String)

# Checks for a line break before the first argument in a
# multi-line method call.
#
# @example AllowMultilineFinalElement: false (default)
#
#   # bad
#   method(foo, bar,
#   baz)
#
#   # bad
#   method(foo, bar, {
#   baz: "a",
#   qux: "b",
#   })
#
#   # good
#   method(
#   foo, bar,
#   baz)
#
#   # good
#   method(
#   foo, bar, {
#   baz: "a",
#   qux: "b",
#   })
#
#   # ignored
#   method foo, bar,
#   baz
# @example AllowMultilineFinalElement: true
#
#   # bad
#   method(foo, bar,
#   baz)
#
#   # bad
#   method(foo,
#   bar,
#   {
#   baz: "a",
#   qux: "b",
#   }
#   )
#
#   # good
#   method(foo, bar, {
#   baz: "a",
#   qux: "b",
#   })
#
#   # good
#   method(
#   foo, bar,
#   baz)
#
#   # good
#   method(
#   foo,
#   bar,
#   {
#   baz: "a",
#   qux: "b",
#   }
#   )
#
#   # ignored
#   method foo, bar,
#   baz
#
# source://rubocop//lib/rubocop/cop/layout/first_method_argument_line_break.rb#76
class RuboCop::Cop::Layout::FirstMethodArgumentLineBreak < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::FirstElementLineBreak
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/first_method_argument_line_break.rb#82
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/layout/first_method_argument_line_break.rb#82
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/layout/first_method_argument_line_break.rb#82
  def on_super(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/first_method_argument_line_break.rb#101
  def ignore_last_element?; end
end

# source://rubocop//lib/rubocop/cop/layout/first_method_argument_line_break.rb#80
RuboCop::Cop::Layout::FirstMethodArgumentLineBreak::MSG = T.let(T.unsafe(nil), String)

# Checks for a line break before the first parameter in a
# multi-line method parameter definition.
#
# @example AllowMultilineFinalElement: false (default)
#
#   # bad
#   def method(foo, bar,
#   baz)
#   do_something
#   end
#
#   # bad
#   def method(foo, bar, baz = {
#   :a => "b",
#   })
#   do_something
#   end
#
#   # good
#   def method(
#   foo, bar,
#   baz)
#   do_something
#   end
#
#   # good
#   def method(
#   foo, bar, baz = {
#   :a => "b",
#   })
#   do_something
#   end
#
#   # ignored
#   def method foo,
#   bar
#   do_something
#   end
# @example AllowMultilineFinalElement: true
#
#   # bad
#   def method(foo, bar,
#   baz)
#   do_something
#   end
#
#   # good
#   def method(foo, bar, baz = {
#   :a => "b",
#   })
#   do_something
#   end
#
#   # good
#   def method(
#   foo, bar,
#   baz)
#   do_something
#   end
#
#   # ignored
#   def method foo,
#   bar
#   do_something
#   end
#
# source://rubocop//lib/rubocop/cop/layout/first_method_parameter_line_break.rb#73
class RuboCop::Cop::Layout::FirstMethodParameterLineBreak < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::FirstElementLineBreak
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/first_method_parameter_line_break.rb#79
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/layout/first_method_parameter_line_break.rb#79
  def on_defs(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/first_method_parameter_line_break.rb#86
  def ignore_last_element?; end
end

# source://rubocop//lib/rubocop/cop/layout/first_method_parameter_line_break.rb#77
RuboCop::Cop::Layout::FirstMethodParameterLineBreak::MSG = T.let(T.unsafe(nil), String)

# Checks the indentation of the first parameter in a method
# definition. Parameters after the first one are checked by
# Layout/ParameterAlignment, not by this cop.
#
# For indenting the first argument of method _calls_, check out
# Layout/FirstArgumentIndentation, which supports options related to
# nesting that are irrelevant for method _definitions_.
#
# @example
#
#   # bad
#   def some_method(
#   first_param,
#   second_param)
#   123
#   end
# @example EnforcedStyle: consistent (default)
#   # The first parameter should always be indented one step more than the
#   # preceding line.
#
#   # good
#   def some_method(
#   first_param,
#   second_param)
#   123
#   end
# @example EnforcedStyle: align_parentheses
#   # The first parameter should always be indented one step more than the
#   # opening parenthesis.
#
#   # good
#   def some_method(
#   first_param,
#   second_param)
#   123
#   end
#
# source://rubocop//lib/rubocop/cop/layout/first_parameter_indentation.rb#44
class RuboCop::Cop::Layout::FirstParameterIndentation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineElementIndentation
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/first_parameter_indentation.rb#53
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/layout/first_parameter_indentation.rb#53
  def on_defs(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/first_parameter_indentation.rb#63
  def autocorrect(corrector, node); end

  # Returns the description of what the correct indentation is based on.
  #
  # source://rubocop//lib/rubocop/cop/layout/first_parameter_indentation.rb#83
  def base_description(_); end

  # source://rubocop//lib/rubocop/cop/layout/first_parameter_indentation.rb#67
  def brace_alignment_style; end

  # source://rubocop//lib/rubocop/cop/layout/first_parameter_indentation.rb#71
  def check(def_node); end

  # source://rubocop//lib/rubocop/cop/layout/first_parameter_indentation.rb#91
  def message(base_description); end
end

# source://rubocop//lib/rubocop/cop/layout/first_parameter_indentation.rb#50
RuboCop::Cop::Layout::FirstParameterIndentation::MSG = T.let(T.unsafe(nil), String)

# Check that the keys, separators, and values of a multi-line hash
# literal are aligned according to configuration. The configuration
# options are:
#
# * key (left align keys, one space before hash rockets and values)
# * separator (align hash rockets and colons, right align keys)
# * table (left align keys, hash rockets, and values)
#
# The treatment of hashes passed as the last argument to a method call
# can also be configured. The options are:
#
# * always_inspect
# * always_ignore
# * ignore_implicit (without curly braces)
#
# Alternatively you can specify multiple allowed styles. That's done by
# passing a list of styles to EnforcedStyles.
#
# @example EnforcedLastArgumentHashStyle: ignore_explicit
#   # Ignore only explicit hashes.
#
#   # bad
#   do_something(foo: 1,
#   bar: 2)
#
#   # good
#   do_something({foo: 1,
#   bar: 2})
# @example EnforcedHashRocketStyle: separator
#   # bad
#   {
#   :foo => bar,
#   :ba => baz
#   }
#   {
#   :foo => bar,
#   :ba  => baz
#   }
#
#   # good
#   {
#   :foo => bar,
#   :ba => baz
#   }
# @example EnforcedHashRocketStyle: table
#   # bad
#   {
#   :foo => bar,
#   :ba => baz
#   }
#
#   # good
#   {
#   :foo => bar,
#   :ba  => baz
#   }
# @example EnforcedColonStyle: key (default)
#   # bad
#   {
#   foo: bar,
#   ba: baz
#   }
#   {
#   foo: bar,
#   ba:  baz
#   }
#
#   # good
#   {
#   foo: bar,
#   ba: baz
#   }
# @example EnforcedColonStyle: separator
#   # bad
#   {
#   foo: bar,
#   ba: baz
#   }
#
#   # good
#   {
#   foo: bar,
#   ba: baz
#   }
# @example EnforcedColonStyle: table
#   # bad
#   {
#   foo: bar,
#   ba: baz
#   }
#
#   # good
#   {
#   foo: bar,
#   ba:  baz
#   }
# @example EnforcedLastArgumentHashStyle: always_inspect (default)
#   # Inspect both implicit and explicit hashes.
#
#   # bad
#   do_something(foo: 1,
#   bar: 2)
#
#   # bad
#   do_something({foo: 1,
#   bar: 2})
#
#   # good
#   do_something(foo: 1,
#   bar: 2)
#
#   # good
#   do_something(
#   foo: 1,
#   bar: 2
#   )
#
#   # good
#   do_something({foo: 1,
#   bar: 2})
#
#   # good
#   do_something({
#   foo: 1,
#   bar: 2
#   })
# @example EnforcedLastArgumentHashStyle: always_ignore
#   # Ignore both implicit and explicit hashes.
#
#   # good
#   do_something(foo: 1,
#   bar: 2)
#
#   # good
#   do_something({foo: 1,
#   bar: 2})
# @example EnforcedLastArgumentHashStyle: ignore_implicit
#   # Ignore only implicit hashes.
#
#   # bad
#   do_something({foo: 1,
#   bar: 2})
#
#   # good
#   do_something(foo: 1,
#   bar: 2)
# @example EnforcedHashRocketStyle: key (default)
#   # bad
#   {
#   :foo => bar,
#   :ba => baz
#   }
#   {
#   :foo => bar,
#   :ba  => baz
#   }
#
#   # good
#   {
#   :foo => bar,
#   :ba => baz
#   }
#
# source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#178
class RuboCop::Cop::Layout::HashAlignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::HashAlignmentStyles
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # Returns the value of attribute column_deltas.
  #
  # source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#218
  def column_deltas; end

  # Sets the attribute column_deltas
  #
  # @param value the value to set the attribute column_deltas to.
  #
  # source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#218
  def column_deltas=(_arg0); end

  # Returns the value of attribute offenses_by.
  #
  # source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#218
  def offenses_by; end

  # Sets the attribute offenses_by
  #
  # @param value the value to set the attribute offenses_by to.
  #
  # source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#218
  def offenses_by=(_arg0); end

  # source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#208
  def on_hash(node); end

  # source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#195
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#195
  def on_super(node); end

  # source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#195
  def on_yield(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#265
  def add_offenses; end

  # source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#371
  def adjust(corrector, delta, range); end

  # source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#300
  def alignment_for(pair); end

  # source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#314
  def alignment_for_colons; end

  # source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#310
  def alignment_for_hash_rockets; end

  # source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#390
  def argument_alignment_config; end

  # source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#233
  def argument_before_hash(hash_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#222
  def autocorrect_incompatible_with_other_cops?(node); end

  # source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#283
  def check_delta(delta, node:, alignment:); end

  # source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#246
  def check_pairs(node); end

  # source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#337
  def correct_key_value(corrector, delta, key, value, separator); end

  # source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#333
  def correct_no_value(corrector, key_delta, key); end

  # source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#318
  def correct_node(corrector, node, delta); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#242
  def double_splat?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#384
  def enforce_first_argument_with_fixed_indentation?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#380
  def good_alignment?(column_deltas); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#291
  def ignore_hash_argument?(node); end

  # source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#353
  def new_alignment(key); end

  # source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#273
  def register_offenses_with_format(offenses, format); end

  # source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#237
  def reset!; end
end

# source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#183
RuboCop::Cop::Layout::HashAlignment::MESSAGES = T.let(T.unsafe(nil), Hash)

# source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#193
RuboCop::Cop::Layout::HashAlignment::SEPARATOR_ALIGNMENT_STYLES = T.let(T.unsafe(nil), Array)

# Checks for the placement of the closing parenthesis
# in a method call that passes a HEREDOC string as an argument.
# It should be placed at the end of the line containing the
# opening HEREDOC tag.
#
# @example
#   # bad
#
#   foo(<<-SQL
#   bar
#   SQL
#   )
#
#   foo(<<-SQL, 123, <<-NOSQL,
#   bar
#   SQL
#   baz
#   NOSQL
#   )
#
#   foo(
#   bar(<<-SQL
#   baz
#   SQL
#   ),
#   123,
#   )
#
#   # good
#
#   foo(<<-SQL)
#   bar
#   SQL
#
#   foo(<<-SQL, 123, <<-NOSQL)
#   bar
#   SQL
#   baz
#   NOSQL
#
#   foo(
#   bar(<<-SQL),
#   baz
#   SQL
#   123,
#   )
#
# source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#53
class RuboCop::Cop::Layout::HeredocArgumentClosingParenthesis < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#64
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#184
  def add_correct_closing_paren(node, corrector); end

  # source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#271
  def add_correct_external_trailing_comma(node, corrector); end

  # Autocorrection note:
  #
  # Commas are a bit tricky to handle when the method call is
  # embedded in another expression. Here's an example:
  #
  # [
  #   first_array_value,
  #   foo(<<-SQL, 123, 456,
  #     SELECT * FROM db
  #   SQL
  #   ),
  #   third_array_value,
  # ]
  #
  # The "internal" trailing comma is after `456`.
  # The "external" trailing comma is after `)`.
  #
  # To autocorrect, we remove the latter, and move the former up:
  #
  # [
  #   first_array_value,
  #   foo(<<-SQL, 123, 456),
  #     SELECT * FROM db
  #   SQL
  #   third_array_value,
  # ]
  #
  # source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#107
  def autocorrect(corrector, node); end

  # Closing parenthesis helpers.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#162
  def end_keyword_before_closing_parenthesis?(parenthesized_send_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#222
  def exist_argument_between_heredoc_end_and_closing_parentheses?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#289
  def external_trailing_comma?(node); end

  # Returns nil if no trailing external comma.
  #
  # source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#294
  def external_trailing_comma_offset_from_loc_end(node); end

  # source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#137
  def extract_heredoc(node); end

  # source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#133
  def extract_heredoc_argument(node); end

  # source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#230
  def find_most_bottom_of_heredoc_end(arguments); end

  # source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#179
  def fix_closing_parenthesis(node, corrector); end

  # External trailing comma helpers.
  #
  # source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#266
  def fix_external_trailing_comma(node, corrector); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#149
  def heredoc_node?(node); end

  # source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#197
  def incorrect_parenthesis_removal_begin(node); end

  # source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#213
  def incorrect_parenthesis_removal_end(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#244
  def internal_trailing_comma?(node); end

  # Returns nil if no trailing internal comma.
  #
  # source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#249
  def internal_trailing_comma_offset_from_last_arg(node); end

  # source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#115
  def outermost_send_on_same_line(heredoc); end

  # source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#188
  def remove_incorrect_closing_paren(node, corrector); end

  # source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#277
  def remove_incorrect_external_trailing_comma(node, corrector); end

  # Internal trailing comma helpers.
  #
  # source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#238
  def remove_internal_trailing_comma(node, corrector); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#207
  def safe_to_remove_line_containing_closing_paren?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#126
  def send_missing_closing_parens?(parent, child, heredoc); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#153
  def single_line_send_with_heredoc_receiver?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#305
  def space?(pos); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#168
  def subsequent_closing_parentheses_in_same_line?(outermost_send); end

  class << self
    # source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#60
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#57
RuboCop::Cop::Layout::HeredocArgumentClosingParenthesis::MSG = T.let(T.unsafe(nil), String)

# Checks the indentation of the here document bodies. The bodies
# are indented one step.
#
# Note: When ``Layout/LineLength``'s `AllowHeredoc` is false (not default),
#       this cop does not add any offenses for long here documents to
#       avoid `Layout/LineLength`'s offenses.
#
# @example
#   # bad
#   <<-RUBY
#   something
#   RUBY
#
#   # good
#   <<~RUBY
#   something
#   RUBY
#
# source://rubocop//lib/rubocop/cop/layout/heredoc_indentation.rb#24
class RuboCop::Cop::Layout::HeredocIndentation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::Heredoc
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/heredoc_indentation.rb#33
  def on_heredoc(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/heredoc_indentation.rb#117
  def adjust_minus(corrector, node); end

  # source://rubocop//lib/rubocop/cop/layout/heredoc_indentation.rb#112
  def adjust_squiggly(corrector, node); end

  # source://rubocop//lib/rubocop/cop/layout/heredoc_indentation.rb#141
  def base_indent_level(node); end

  # source://rubocop//lib/rubocop/cop/layout/heredoc_indentation.rb#152
  def heredoc_body(node); end

  # source://rubocop//lib/rubocop/cop/layout/heredoc_indentation.rb#156
  def heredoc_end(node); end

  # Returns '~', '-' or nil
  #
  # source://rubocop//lib/rubocop/cop/layout/heredoc_indentation.rb#148
  def heredoc_indent_type(node); end

  # source://rubocop//lib/rubocop/cop/layout/heredoc_indentation.rb#123
  def indented_body(node); end

  # source://rubocop//lib/rubocop/cop/layout/heredoc_indentation.rb#130
  def indented_end(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/heredoc_indentation.rb#88
  def line_too_long?(node); end

  # source://rubocop//lib/rubocop/cop/layout/heredoc_indentation.rb#100
  def longest_line(lines); end

  # source://rubocop//lib/rubocop/cop/layout/heredoc_indentation.rb#108
  def max_line_length; end

  # source://rubocop//lib/rubocop/cop/layout/heredoc_indentation.rb#66
  def message(heredoc_indent_type); end

  # source://rubocop//lib/rubocop/cop/layout/heredoc_indentation.rb#54
  def register_offense(node, heredoc_indent_type); end

  # source://rubocop//lib/rubocop/cop/layout/heredoc_indentation.rb#76
  def type_message(indentation_width, current_indent_type); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/heredoc_indentation.rb#104
  def unlimited_heredoc_length?; end

  # source://rubocop//lib/rubocop/cop/layout/heredoc_indentation.rb#84
  def width_message(indentation_width); end
end

# source://rubocop//lib/rubocop/cop/layout/heredoc_indentation.rb#29
RuboCop::Cop::Layout::HeredocIndentation::TYPE_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/heredoc_indentation.rb#31
RuboCop::Cop::Layout::HeredocIndentation::WIDTH_MSG = T.let(T.unsafe(nil), String)

# Checks for inconsistent indentation.
#
# The difference between `indented_internal_methods` and `normal` is
# that the `indented_internal_methods` style prescribes that in
# classes and modules the `protected` and `private` modifier keywords
# shall be indented the same as public methods and that protected and
# private members shall be indented one step more than the modifiers.
# Other than that, both styles mean that entities on the same logical
# depth shall have the same indentation.
#
# @example EnforcedStyle: normal (default)
#   # bad
#   class A
#   def test
#   puts 'hello'
#   puts 'world'
#   end
#   end
#
#   # bad
#   class A
#   def test
#   puts 'hello'
#   puts 'world'
#   end
#
#   protected
#
#   def foo
#   end
#
#   private
#
#   def bar
#   end
#   end
#
#   # good
#   class A
#   def test
#   puts 'hello'
#   puts 'world'
#   end
#   end
#
#   # good
#   class A
#   def test
#   puts 'hello'
#   puts 'world'
#   end
#
#   protected
#
#   def foo
#   end
#
#   private
#
#   def bar
#   end
#   end
# @example EnforcedStyle: indented_internal_methods
#   # bad
#   class A
#   def test
#   puts 'hello'
#   puts 'world'
#   end
#   end
#
#   # bad
#   class A
#   def test
#   puts 'hello'
#   puts 'world'
#   end
#
#   protected
#
#   def foo
#   end
#
#   private
#
#   def bar
#   end
#   end
#
#   # good
#   class A
#   def test
#   puts 'hello'
#   puts 'world'
#   end
#   end
#
#   # good
#   class A
#   def test
#   puts 'hello'
#   puts 'world'
#   end
#
#   protected
#
#   def foo
#   end
#
#   private
#
#   def bar
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/layout/indentation_consistency.rb#121
class RuboCop::Cop::Layout::IndentationConsistency < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/indentation_consistency.rb#128
  def on_begin(node); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_consistency.rb#132
  def on_kwbegin(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/indentation_consistency.rb#138
  def autocorrect(corrector, node); end

  # Not all nodes define `bare_access_modifier?` (for example,
  # `RuboCop::AST::DefNode` does not), so we must check `send_type?` first
  # to avoid a NoMethodError.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/indentation_consistency.rb#145
  def bare_access_modifier?(node); end

  # Returns an integer representing the correct indentation, or nil to
  # indicate that the correct indentation is that of the first child that
  # is not an access modifier.
  #
  # source://rubocop//lib/rubocop/cop/layout/indentation_consistency.rb#152
  def base_column_for_normal_style(node); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_consistency.rb#172
  def check(node); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_consistency.rb#187
  def check_indented_internal_methods_style(node); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_consistency.rb#180
  def check_normal_style(node); end
end

# source://rubocop//lib/rubocop/cop/layout/indentation_consistency.rb#126
RuboCop::Cop::Layout::IndentationConsistency::MSG = T.let(T.unsafe(nil), String)

# Checks that the indentation method is consistent.
# Either tabs only or spaces only are used for indentation.
#
# @example EnforcedStyle: spaces (default)
#   # bad
#   # This example uses a tab to indent bar.
#   def foo
#   bar
#   end
#
#   # good
#   # This example uses spaces to indent bar.
#   def foo
#   bar
#   end
# @example EnforcedStyle: tabs
#   # bad
#   # This example uses spaces to indent bar.
#   def foo
#   bar
#   end
#
#   # good
#   # This example uses a tab to indent bar.
#   def foo
#   bar
#   end
#
# source://rubocop//lib/rubocop/cop/layout/indentation_style.rb#34
class RuboCop::Cop::Layout::IndentationStyle < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/indentation_style.rb#42
  def on_new_investigation; end

  private

  # source://rubocop//lib/rubocop/cop/layout/indentation_style.rb#58
  def autocorrect(corrector, range); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_style.rb#82
  def autocorrect_lambda_for_spaces(corrector, range); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_style.rb#77
  def autocorrect_lambda_for_tabs(corrector, range); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_style.rb#66
  def find_offense(line, lineno); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/indentation_style.rb#88
  def in_string_literal?(ranges, tabs_range); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_style.rb#109
  def message(_node); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_style.rb#92
  def string_literal_ranges(ast); end
end

# source://rubocop//lib/rubocop/cop/layout/indentation_style.rb#40
RuboCop::Cop::Layout::IndentationStyle::MSG = T.let(T.unsafe(nil), String)

# Checks for indentation that doesn't use the specified number
# of spaces.
#
# See also the IndentationConsistency cop which is the companion to this
# one.
#
# @example
#   # bad
#   class A
#   def test
#   puts 'hello'
#   end
#   end
#
#   # good
#   class A
#   def test
#   puts 'hello'
#   end
#   end
# @example AllowedPatterns: ['^\s*module']
#   # bad
#   module A
#   class B
#   def test
#   puts 'hello'
#   end
#   end
#   end
#
#   # good
#   module A
#   class B
#   def test
#   puts 'hello'
#   end
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#45
class RuboCop::Cop::Layout::IndentationWidth < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::AllowedPattern
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#57
  def access_modifier?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#81
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#138
  def on_case(case_node); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#146
  def on_case_match(case_match); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#95
  def on_class(node); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#104
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#121
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#121
  def on_defs(node); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#66
  def on_ensure(node); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#66
  def on_for(node); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#156
  def on_if(node, base = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#73
  def on_kwbegin(node); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#95
  def on_module(node); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#81
  def on_numblock(node); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#66
  def on_resbody(node); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#61
  def on_rescue(node); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#95
  def on_sclass(node); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#104
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#128
  def on_until(node, base = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#128
  def on_while(node, base = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#227
  def access_modifier_indentation_style; end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#165
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#235
  def check_assignment(node, rhs); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#255
  def check_if(node, body, else_clause, base_loc); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#268
  def check_indentation(base_loc, body_node, style = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#169
  def check_members(base, members); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#193
  def check_members_for_indented_internal_methods_style(members); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#199
  def check_members_for_normal_style(base, members); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#341
  def check_rescue?(rescue_node); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#377
  def configured_indentation_width; end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#207
  def each_member(members); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#231
  def indentation_consistency_style; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#323
  def indentation_to_check?(base_loc, body_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#219
  def indented_internal_methods_style?; end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#381
  def leftmost_modifier_of(node); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#302
  def message(configured_indentation_width, indentation, name); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#360
  def offending_range(body_node, indentation); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#278
  def offense(body_node, indentation, style); end

  # Returns true if the given node is within another node that has
  # already been marked for autocorrection by this cop.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#313
  def other_offense_in_same_range?(node); end

  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#181
  def select_check_member(member); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#345
  def skip_check?(base_loc, body_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#223
  def special_modifier?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#368
  def starts_with_access_modifier?(body_node); end
end

# source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#53
RuboCop::Cop::Layout::IndentationWidth::MSG = T.let(T.unsafe(nil), String)

# Checks for indentation of the first non-blank non-comment
# line in a file.
#
# @example
#   # bad
#   class A
#   def foo; end
#   end
#
#   # good
#   class A
#   def foo; end
#   end
#
# source://rubocop//lib/rubocop/cop/layout/initial_indentation.rb#20
class RuboCop::Cop::Layout::InitialIndentation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/initial_indentation.rb#26
  def on_new_investigation; end

  private

  # source://rubocop//lib/rubocop/cop/layout/initial_indentation.rb#36
  def first_token; end

  # @yield [range_between(space_range.begin_pos, token.begin_pos)]
  #
  # source://rubocop//lib/rubocop/cop/layout/initial_indentation.rb#40
  def space_before(token); end
end

# source://rubocop//lib/rubocop/cop/layout/initial_indentation.rb#24
RuboCop::Cop::Layout::InitialIndentation::MSG = T.let(T.unsafe(nil), String)

# Checks whether comments have a leading space after the
# `#` denoting the start of the comment. The leading space is not
# required for some RDoc special syntax, like `#++`, `#--`,
# `#:nodoc`, `=begin`- and `=end` comments, "shebang" directives,
# or rackup options.
#
# @example
#
#   # bad
#   #Some comment
#
#   # good
#   # Some comment
# @example AllowDoxygenCommentStyle: false (default)
#
#   # bad
#
#   #**
#   # Some comment
#   # Another line of comment
#   #*
# @example AllowDoxygenCommentStyle: true
#
#   # good
#
#   #**
#   # Some comment
#   # Another line of comment
#   #*
# @example AllowGemfileRubyComment: false (default)
#
#   # bad
#
#   #ruby=2.7.0
#   #ruby-gemset=myproject
# @example AllowGemfileRubyComment: true
#
#   # good
#
#   #ruby=2.7.0
#   #ruby-gemset=myproject
#
# source://rubocop//lib/rubocop/cop/layout/leading_comment_space.rb#52
class RuboCop::Cop::Layout::LeadingCommentSpace < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/leading_comment_space.rb#58
  def on_new_investigation; end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/leading_comment_space.rb#95
  def allow_doxygen_comment?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/leading_comment_space.rb#103
  def allow_gemfile_ruby_comment?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/leading_comment_space.rb#79
  def allowed_on_first_line?(comment); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/leading_comment_space.rb#99
  def doxygen_comment_style?(comment); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/leading_comment_space.rb#107
  def gemfile?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/leading_comment_space.rb#115
  def gemfile_ruby_comment?(comment); end

  # source://rubocop//lib/rubocop/cop/layout/leading_comment_space.rb#75
  def hash_mark(expr); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/leading_comment_space.rb#91
  def rackup_config_file?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/leading_comment_space.rb#87
  def rackup_options?(comment); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/leading_comment_space.rb#111
  def ruby_comment_in_gemfile?(comment); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/leading_comment_space.rb#83
  def shebang?(comment); end
end

# source://rubocop//lib/rubocop/cop/layout/leading_comment_space.rb#56
RuboCop::Cop::Layout::LeadingCommentSpace::MSG = T.let(T.unsafe(nil), String)

# Checks for unnecessary leading blank lines at the beginning
# of a file.
#
# @example
#
#   # bad
#   # (start of file)
#
#   class Foo
#   end
#
#   # bad
#   # (start of file)
#
#   # a comment
#
#   # good
#   # (start of file)
#   class Foo
#   end
#
#   # good
#   # (start of file)
#   # a comment
#
# source://rubocop//lib/rubocop/cop/layout/leading_empty_lines.rb#30
class RuboCop::Cop::Layout::LeadingEmptyLines < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/leading_empty_lines.rb#35
  def on_new_investigation; end
end

# source://rubocop//lib/rubocop/cop/layout/leading_empty_lines.rb#33
RuboCop::Cop::Layout::LeadingEmptyLines::MSG = T.let(T.unsafe(nil), String)

# Checks that strings broken over multiple lines (by a backslash) contain
# trailing spaces instead of leading spaces (default) or leading spaces
# instead of trailing spaces.
#
# @example EnforcedStyle: trailing (default)
#   # bad
#   'this text contains a lot of' \
#   '               spaces'
#
#   # good
#   'this text contains a lot of               ' \
#   'spaces'
#
#   # bad
#   'this text is too' \
#   ' long'
#
#   # good
#   'this text is too ' \
#   'long'
# @example EnforcedStyle: leading
#   # bad
#   'this text contains a lot of               ' \
#   'spaces'
#
#   # good
#   'this text contains a lot of' \
#   '               spaces'
#
#   # bad
#   'this text is too ' \
#   'long'
#
#   # good
#   'this text is too' \
#   ' long'
#
# source://rubocop//lib/rubocop/cop/layout/line_continuation_leading_space.rb#43
class RuboCop::Cop::Layout::LineContinuationLeadingSpace < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/line_continuation_leading_space.rb#54
  def on_dstr(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/line_continuation_leading_space.rb#105
  def autocorrect(corrector, offense_range, insert_pos, spaces); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/line_continuation_leading_space.rb#101
  def continuation?(line); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/line_continuation_leading_space.rb#130
  def enforced_style_leading?; end

  # source://rubocop//lib/rubocop/cop/layout/line_continuation_leading_space.rb#79
  def investigate_leading_style(first_line, second_line, end_of_first_line); end

  # source://rubocop//lib/rubocop/cop/layout/line_continuation_leading_space.rb#90
  def investigate_trailing_style(first_line, second_line, end_of_first_line); end

  # source://rubocop//lib/rubocop/cop/layout/line_continuation_leading_space.rb#110
  def leading_offense_range(end_of_first_line, matches); end

  # source://rubocop//lib/rubocop/cop/layout/line_continuation_leading_space.rb#122
  def message(_range); end

  # source://rubocop//lib/rubocop/cop/layout/line_continuation_leading_space.rb#75
  def raw_lines(node); end

  # source://rubocop//lib/rubocop/cop/layout/line_continuation_leading_space.rb#116
  def trailing_offense_range(end_of_first_line, matches); end
end

# source://rubocop//lib/rubocop/cop/layout/line_continuation_leading_space.rb#49
RuboCop::Cop::Layout::LineContinuationLeadingSpace::LEADING_STYLE_OFFENSE = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/layout/line_continuation_leading_space.rb#47
RuboCop::Cop::Layout::LineContinuationLeadingSpace::LINE_1_ENDING = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/layout/line_continuation_leading_space.rb#48
RuboCop::Cop::Layout::LineContinuationLeadingSpace::LINE_2_BEGINNING = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/layout/line_continuation_leading_space.rb#50
RuboCop::Cop::Layout::LineContinuationLeadingSpace::TRAILING_STYLE_OFFENSE = T.let(T.unsafe(nil), Regexp)

# Checks that the backslash of a line continuation is separated from
# preceding text by exactly one space (default) or zero spaces.
#
# @example EnforcedStyle: space (default)
#   # bad
#   'a'\
#   'b'  \
#   'c'
#
#   # good
#   'a' \
#   'b' \
#   'c'
# @example EnforcedStyle: no_space
#   # bad
#   'a' \
#   'b'  \
#   'c'
#
#   # good
#   'a'\
#   'b'\
#   'c'
#
# source://rubocop//lib/rubocop/cop/layout/line_continuation_spacing.rb#30
class RuboCop::Cop::Layout::LineContinuationSpacing < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/line_continuation_spacing.rb#34
  def on_new_investigation; end

  private

  # source://rubocop//lib/rubocop/cop/layout/line_continuation_spacing.rb#81
  def autocorrect(corrector, range); end

  # source://rubocop//lib/rubocop/cop/layout/line_continuation_spacing.rb#111
  def comment_ranges(comments); end

  # source://rubocop//lib/rubocop/cop/layout/line_continuation_spacing.rb#65
  def find_offensive_spacing(line); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/line_continuation_spacing.rb#121
  def ignore_range?(backtick_range); end

  # source://rubocop//lib/rubocop/cop/layout/line_continuation_spacing.rb#91
  def ignored_literal_ranges(ast); end

  # source://rubocop//lib/rubocop/cop/layout/line_continuation_spacing.rb#125
  def ignored_ranges; end

  # source://rubocop//lib/rubocop/cop/layout/line_continuation_spacing.rb#49
  def investigate(line, line_number); end

  # source://rubocop//lib/rubocop/cop/layout/line_continuation_spacing.rb#115
  def last_line(processed_source); end

  # source://rubocop//lib/rubocop/cop/layout/line_continuation_spacing.rb#73
  def message(_range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/line_continuation_spacing.rb#130
  def no_space_style?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/line_continuation_spacing.rb#134
  def space_style?; end
end

# Checks the indentation of the next line after a line that ends with a string
# literal and a backslash.
#
# If `EnforcedStyle: aligned` is set, the concatenated string parts shall be aligned with the
# first part. There are some exceptions, such as implicit return values, where the
# concatenated string parts shall be indented regardless of `EnforcedStyle` configuration.
#
# If `EnforcedStyle: indented` is set, it's the second line that shall be indented one step
# more than the first line. Lines 3 and forward shall be aligned with line 2.
#
# @example
#   # bad
#   def some_method
#   'x' \
#   'y' \
#   'z'
#   end
#
#   my_hash = {
#   first: 'a message' \
#   'in two parts'
#   }
#
#   # good
#   def some_method
#   'x' \
#   'y' \
#   'z'
#   end
# @example EnforcedStyle: aligned (default)
#   # bad
#   puts 'x' \
#   'y'
#
#   my_hash = {
#   first: 'a message' \
#   'in two parts'
#   }
#
#   # good
#   puts 'x' \
#   'y'
#
#   my_hash = {
#   first: 'a message' \
#   'in two parts'
#   }
# @example EnforcedStyle: indented
#   # bad
#   result = 'x' \
#   'y'
#
#   my_hash = {
#   first: 'a message' \
#   'in two parts'
#   }
#
#   # good
#   result = 'x' \
#   'y'
#
#   my_hash = {
#   first: 'a message' \
#   'in two parts'
#   }
#
# source://rubocop//lib/rubocop/cop/layout/line_end_string_concatenation_indentation.rb#74
class RuboCop::Cop::Layout::LineEndStringConcatenationIndentation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::Alignment
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/line_end_string_concatenation_indentation.rb#95
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/layout/line_end_string_concatenation_indentation.rb#83
  def on_dstr(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/line_end_string_concatenation_indentation.rb#135
  def add_offense_and_correction(node, message); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/line_end_string_concatenation_indentation.rb#107
  def always_indented?(dstr_node); end

  # source://rubocop//lib/rubocop/cop/layout/line_end_string_concatenation_indentation.rb#126
  def base_column(child); end

  # source://rubocop//lib/rubocop/cop/layout/line_end_string_concatenation_indentation.rb#111
  def check_aligned(children, start_index); end

  # source://rubocop//lib/rubocop/cop/layout/line_end_string_concatenation_indentation.rb#120
  def check_indented(children); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/line_end_string_concatenation_indentation.rb#101
  def strings_concatenated_with_backslash?(dstr_node); end
end

# source://rubocop//lib/rubocop/cop/layout/line_end_string_concatenation_indentation.rb#79
RuboCop::Cop::Layout::LineEndStringConcatenationIndentation::MSG_ALIGN = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/line_end_string_concatenation_indentation.rb#80
RuboCop::Cop::Layout::LineEndStringConcatenationIndentation::MSG_INDENT = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/line_end_string_concatenation_indentation.rb#81
RuboCop::Cop::Layout::LineEndStringConcatenationIndentation::PARENT_TYPES_FOR_INDENTED = T.let(T.unsafe(nil), Array)

# Checks the length of lines in the source code.
# The maximum length is configurable.
# The tab size is configured in the `IndentationWidth`
# of the `Layout/IndentationStyle` cop.
# It also ignores a shebang line by default.
#
# This cop has some autocorrection capabilities.
# It can programmatically shorten certain long lines by
# inserting line breaks into expressions that can be safely
# split across lines. These include arrays, hashes, and
# method calls with argument lists.
#
# If autocorrection is enabled, the following Layout cops
# are recommended to further format the broken lines.
# (Many of these are enabled by default.)
#
# * ArgumentAlignment
# * ArrayAlignment
# * BlockAlignment
# * BlockDelimiters
# * BlockEndNewline
# * ClosingParenthesisIndentation
# * FirstArgumentIndentation
# * FirstArrayElementIndentation
# * FirstHashElementIndentation
# * FirstParameterIndentation
# * HashAlignment
# * IndentationWidth
# * MultilineArrayLineBreaks
# * MultilineBlockLayout
# * MultilineHashBraceLayout
# * MultilineHashKeyLineBreaks
# * MultilineMethodArgumentLineBreaks
# * MultilineMethodParameterLineBreaks
# * ParameterAlignment
#
# Together, these cops will pretty print hashes, arrays,
# method calls, etc. For example, let's say the max columns
# is 25:
#
# @example
#
#   # bad
#   {foo: "0000000000", bar: "0000000000", baz: "0000000000"}
#
#   # good
#   {foo: "0000000000",
#   bar: "0000000000", baz: "0000000000"}
#
#   # good (with recommended cops enabled)
#   {
#   foo: "0000000000",
#   bar: "0000000000",
#   baz: "0000000000",
#   }
#
# source://rubocop//lib/rubocop/cop/layout/line_length.rb#63
class RuboCop::Cop::Layout::LineLength < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::CheckLineBreakable
  include ::RuboCop::Cop::AllowedPattern
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::LineLengthHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/exclude_limit.rb#11
  def max=(value); end

  # source://rubocop//lib/rubocop/cop/layout/line_length.rb#80
  def on_array(node); end

  # source://rubocop//lib/rubocop/cop/layout/line_length.rb#74
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/layout/line_length.rb#80
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/layout/line_length.rb#80
  def on_hash(node); end

  # source://rubocop//lib/rubocop/cop/layout/line_length.rb#94
  def on_investigation_end; end

  # source://rubocop//lib/rubocop/cop/layout/line_length.rb#88
  def on_new_investigation; end

  # source://rubocop//lib/rubocop/cop/layout/line_length.rb#74
  def on_numblock(node); end

  # source://rubocop//lib/rubocop/cop/layout/line_length.rb#80
  def on_potential_breakable_node(node); end

  # source://rubocop//lib/rubocop/cop/layout/line_length.rb#80
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/line_length.rb#219
  def allow_heredoc?; end

  # source://rubocop//lib/rubocop/cop/layout/line_length.rb#223
  def allowed_heredoc; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/line_length.rb#183
  def allowed_line?(line, line_index); end

  # source://rubocop//lib/rubocop/cop/layout/line_length.rb#135
  def breakable_block_range(block_node); end

  # Returns the value of attribute breakable_range.
  #
  # source://rubocop//lib/rubocop/cop/layout/line_length.rb#102
  def breakable_range; end

  # Sets the attribute breakable_range
  #
  # @param value the value to set the attribute breakable_range to.
  #
  # source://rubocop//lib/rubocop/cop/layout/line_length.rb#102
  def breakable_range=(_arg0); end

  # source://rubocop//lib/rubocop/cop/layout/line_length.rb#143
  def breakable_range_after_semicolon(semicolon_token); end

  # source://rubocop//lib/rubocop/cop/layout/line_length.rb#156
  def breakable_range_by_line_index; end

  # source://rubocop//lib/rubocop/cop/layout/line_length.rb#250
  def check_directive_line(line, line_index); end

  # source://rubocop//lib/rubocop/cop/layout/line_length.rb#125
  def check_for_breakable_block(block_node); end

  # source://rubocop//lib/rubocop/cop/layout/line_length.rb#104
  def check_for_breakable_node(node); end

  # source://rubocop//lib/rubocop/cop/layout/line_length.rb#117
  def check_for_breakable_semicolons(processed_source); end

  # source://rubocop//lib/rubocop/cop/layout/line_length.rb#171
  def check_line(line, line_index); end

  # source://rubocop//lib/rubocop/cop/layout/line_length.rb#267
  def check_uri_line(line, line_index); end

  # source://rubocop//lib/rubocop/cop/layout/line_length.rb#204
  def excess_range(uri_range, line, line_index); end

  # source://rubocop//lib/rubocop/cop/layout/line_length.rb#227
  def extract_heredocs(ast); end

  # source://rubocop//lib/rubocop/cop/layout/line_length.rb#160
  def heredocs; end

  # source://rubocop//lib/rubocop/cop/layout/line_length.rb#164
  def highlight_start(line); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/line_length.rb#246
  def line_in_heredoc?(line_number); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/line_length.rb#237
  def line_in_permitted_heredoc?(line_number); end

  # source://rubocop//lib/rubocop/cop/layout/line_length.rb#215
  def max; end

  # source://rubocop//lib/rubocop/cop/layout/line_length.rb#193
  def register_offense(loc, line, line_index, length: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/line_length.rb#189
  def shebang?(line, line_index); end
end

# source://rubocop//lib/rubocop/cop/layout/line_length.rb#72
RuboCop::Cop::Layout::LineLength::MSG = T.let(T.unsafe(nil), String)

# Checks that the closing brace in an array literal is either
# on the same line as the last array element or on a new line.
#
# When using the `symmetrical` (default) style:
#
# If an array's opening brace is on the same line as the first element
# of the array, then the closing brace should be on the same line as
# the last element of the array.
#
# If an array's opening brace is on the line above the first element
# of the array, then the closing brace should be on the line below
# the last element of the array.
#
# When using the `new_line` style:
#
# The closing brace of a multi-line array literal must be on the line
# after the last element of the array.
#
# When using the `same_line` style:
#
# The closing brace of a multi-line array literal must be on the same
# line as the last element of the array.
#
# @example EnforcedStyle: symmetrical (default)
#   # bad
#   [ :a,
#   :b
#   ]
#
#   # bad
#   [
#   :a,
#   :b ]
#
#   # good
#   [ :a,
#   :b ]
#
#   # good
#   [
#   :a,
#   :b
#   ]
# @example EnforcedStyle: new_line
#   # bad
#   [
#   :a,
#   :b ]
#
#   # bad
#   [ :a,
#   :b ]
#
#   # good
#   [ :a,
#   :b
#   ]
#
#   # good
#   [
#   :a,
#   :b
#   ]
# @example EnforcedStyle: same_line
#   # bad
#   [ :a,
#   :b
#   ]
#
#   # bad
#   [
#   :a,
#   :b
#   ]
#
#   # good
#   [
#   :a,
#   :b ]
#
#   # good
#   [ :a,
#   :b ]
#
# source://rubocop//lib/rubocop/cop/layout/multiline_array_brace_layout.rb#91
class RuboCop::Cop::Layout::MultilineArrayBraceLayout < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/multiline_array_brace_layout.rb#109
  def on_array(node); end
end

# source://rubocop//lib/rubocop/cop/layout/multiline_array_brace_layout.rb#103
RuboCop::Cop::Layout::MultilineArrayBraceLayout::ALWAYS_NEW_LINE_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/multiline_array_brace_layout.rb#106
RuboCop::Cop::Layout::MultilineArrayBraceLayout::ALWAYS_SAME_LINE_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/multiline_array_brace_layout.rb#99
RuboCop::Cop::Layout::MultilineArrayBraceLayout::NEW_LINE_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/multiline_array_brace_layout.rb#95
RuboCop::Cop::Layout::MultilineArrayBraceLayout::SAME_LINE_MESSAGE = T.let(T.unsafe(nil), String)

# Ensures that each item in a multi-line array
# starts on a separate line.
#
# @example AllowMultilineFinalElement: false (default)
#
#   # bad
#   [
#   a, b,
#   c
#   ]
#
#   # bad
#   [ a, b, foo(
#   bar
#   )]
#
#   # good
#   [
#   a,
#   b,
#   c
#   ]
#
#   # good
#   [
#   a,
#   b,
#   foo(
#   bar
#   )
#   ]
# @example AllowMultilineFinalElement: true
#
#   # bad
#   [
#   a, b,
#   c
#   ]
#
#   # good
#   [ a, b, foo(
#   bar
#   )]
#
#   # good
#   [
#   a,
#   b,
#   c
#   ]
#
#   # good
#   [
#   a,
#   b,
#   foo(
#   bar
#   )
#   ]
#
# source://rubocop//lib/rubocop/cop/layout/multiline_array_line_breaks.rb#66
class RuboCop::Cop::Layout::MultilineArrayLineBreaks < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::MultilineElementLineBreaks
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/multiline_array_line_breaks.rb#72
  def on_array(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/multiline_array_line_breaks.rb#78
  def ignore_last_element?; end
end

# source://rubocop//lib/rubocop/cop/layout/multiline_array_line_breaks.rb#70
RuboCop::Cop::Layout::MultilineArrayLineBreaks::MSG = T.let(T.unsafe(nil), String)

# Checks whether the multiline assignments have a newline
# after the assignment operator.
#
# @example EnforcedStyle: new_line (default)
#   # bad
#   foo = if expression
#   'bar'
#   end
#
#   # good
#   foo =
#   if expression
#   'bar'
#   end
#
#   # good
#   foo =
#   begin
#   compute
#   rescue => e
#   nil
#   end
# @example EnforcedStyle: same_line
#   # good
#   foo = if expression
#   'bar'
#   end
# @example SupportedTypes: ['block', 'case', 'class', 'if', 'kwbegin', 'module'] (default)
#   # good
#   foo =
#   if expression
#   'bar'
#   end
#
#   # good
#   foo =
#   [1].map do |i|
#   i + 1
#   end
# @example SupportedTypes: ['block']
#   # good
#   foo = if expression
#   'bar'
#   end
#
#   # good
#   foo =
#   [1].map do |i|
#   'bar' * i
#   end
#
# source://rubocop//lib/rubocop/cop/layout/multiline_assignment_layout.rb#60
class RuboCop::Cop::Layout::MultilineAssignmentLayout < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/multiline_assignment_layout.rb#72
  def check_assignment(node, rhs); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_assignment_layout.rb#81
  def check_by_enforced_style(node, rhs); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_assignment_layout.rb#90
  def check_new_line_offense(node, rhs); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_assignment_layout.rb#98
  def check_same_line_offense(node, rhs); end

  private

  # source://rubocop//lib/rubocop/cop/layout/multiline_assignment_layout.rb#111
  def supported_types; end
end

# source://rubocop//lib/rubocop/cop/layout/multiline_assignment_layout.rb#66
RuboCop::Cop::Layout::MultilineAssignmentLayout::NEW_LINE_OFFENSE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/multiline_assignment_layout.rb#69
RuboCop::Cop::Layout::MultilineAssignmentLayout::SAME_LINE_OFFENSE = T.let(T.unsafe(nil), String)

# Checks whether the multiline do end blocks have a newline
# after the start of the block. Additionally, it checks whether the block
# arguments, if any, are on the same line as the start of the
# block. Putting block arguments on separate lines, because the whole
# line would otherwise be too long, is accepted.
#
# @example
#   # bad
#   blah do |i| foo(i)
#   bar(i)
#   end
#
#   # bad
#   blah do
#   |i| foo(i)
#   bar(i)
#   end
#
#   # good
#   blah do |i|
#   foo(i)
#   bar(i)
#   end
#
#   # bad
#   blah { |i| foo(i)
#   bar(i)
#   }
#
#   # good
#   blah { |i|
#   foo(i)
#   bar(i)
#   }
#
#   # good
#   blah { |
#   long_list,
#   of_parameters,
#   that_would_not,
#   fit_on_one_line
#   |
#   foo(i)
#   bar(i)
#   }
#
# source://rubocop//lib/rubocop/cop/layout/multiline_block_layout.rb#51
class RuboCop::Cop::Layout::MultilineBlockLayout < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/multiline_block_layout.rb#59
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_block_layout.rb#59
  def on_numblock(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/multiline_block_layout.rb#98
  def add_offense_for_expression(node, expr, msg); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/multiline_block_layout.rb#75
  def args_on_beginning_line?(node); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_block_layout.rb#105
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_block_layout.rb#120
  def autocorrect_arguments(corrector, node); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_block_layout.rb#130
  def autocorrect_body(corrector, node, block_body); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_block_layout.rb#142
  def block_arg_string(node, args); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_block_layout.rb#90
  def characters_needed_for_space_and_pipes(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/multiline_block_layout.rb#154
  def include_trailing_comma?(args); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/multiline_block_layout.rb#79
  def line_break_necessary_in_args?(node); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_block_layout.rb#83
  def needed_length_for_args(node); end
end

# source://rubocop//lib/rubocop/cop/layout/multiline_block_layout.rb#56
RuboCop::Cop::Layout::MultilineBlockLayout::ARG_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/multiline_block_layout.rb#55
RuboCop::Cop::Layout::MultilineBlockLayout::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/multiline_block_layout.rb#57
RuboCop::Cop::Layout::MultilineBlockLayout::PIPE_SIZE = T.let(T.unsafe(nil), Integer)

# Checks that the closing brace in a hash literal is either
# on the same line as the last hash element, or a new line.
#
# When using the `symmetrical` (default) style:
#
# If a hash's opening brace is on the same line as the first element
# of the hash, then the closing brace should be on the same line as
# the last element of the hash.
#
# If a hash's opening brace is on the line above the first element
# of the hash, then the closing brace should be on the line below
# the last element of the hash.
#
# When using the `new_line` style:
#
# The closing brace of a multi-line hash literal must be on the line
# after the last element of the hash.
#
# When using the `same_line` style:
#
# The closing brace of a multi-line hash literal must be on the same
# line as the last element of the hash.
#
# @example EnforcedStyle: symmetrical (default)
#
#   # bad
#   { a: 1,
#   b: 2
#   }
#   # bad
#   {
#   a: 1,
#   b: 2 }
#
#   # good
#   { a: 1,
#   b: 2 }
#
#   # good
#   {
#   a: 1,
#   b: 2
#   }
# @example EnforcedStyle: new_line
#   # bad
#   {
#   a: 1,
#   b: 2 }
#
#   # bad
#   { a: 1,
#   b: 2 }
#
#   # good
#   { a: 1,
#   b: 2
#   }
#
#   # good
#   {
#   a: 1,
#   b: 2
#   }
# @example EnforcedStyle: same_line
#   # bad
#   { a: 1,
#   b: 2
#   }
#
#   # bad
#   {
#   a: 1,
#   b: 2
#   }
#
#   # good
#   {
#   a: 1,
#   b: 2 }
#
#   # good
#   { a: 1,
#   b: 2 }
#
# source://rubocop//lib/rubocop/cop/layout/multiline_hash_brace_layout.rb#91
class RuboCop::Cop::Layout::MultilineHashBraceLayout < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/multiline_hash_brace_layout.rb#109
  def on_hash(node); end
end

# source://rubocop//lib/rubocop/cop/layout/multiline_hash_brace_layout.rb#103
RuboCop::Cop::Layout::MultilineHashBraceLayout::ALWAYS_NEW_LINE_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/multiline_hash_brace_layout.rb#106
RuboCop::Cop::Layout::MultilineHashBraceLayout::ALWAYS_SAME_LINE_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/multiline_hash_brace_layout.rb#99
RuboCop::Cop::Layout::MultilineHashBraceLayout::NEW_LINE_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/multiline_hash_brace_layout.rb#95
RuboCop::Cop::Layout::MultilineHashBraceLayout::SAME_LINE_MESSAGE = T.let(T.unsafe(nil), String)

# Ensures that each key in a multi-line hash
# starts on a separate line.
#
# @example AllowMultilineFinalElement: false (default)
#
#   # bad
#   {
#   a: 1, b: 2,
#   c: 3
#   }
#
#   # bad
#   { a: 1, b: {
#   c: 3,
#   }}
#
#   # good
#   {
#   a: 1,
#   b: 2,
#   c: 3
#   }
#
#   # good
#   {
#   a: 1,
#   b: {
#   c: 3,
#   }
#   }
# @example AllowMultilineFinalElement: true
#
#   # bad
#   {
#   a: 1, b: 2,
#   c: 3
#   }
#
#   # good
#   { a: 1, b: {
#   c: 3,
#   }}
#
#   # good
#   {
#   a: 1,
#   b: 2,
#   c: 3
#   }
#
#   # good
#   {
#   a: 1,
#   b: {
#   c: 3,
#   }
#   }
#
# source://rubocop//lib/rubocop/cop/layout/multiline_hash_key_line_breaks.rb#65
class RuboCop::Cop::Layout::MultilineHashKeyLineBreaks < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::MultilineElementLineBreaks
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/multiline_hash_key_line_breaks.rb#71
  def on_hash(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/multiline_hash_key_line_breaks.rb#87
  def ignore_last_element?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/multiline_hash_key_line_breaks.rb#83
  def starts_with_curly_brace?(node); end
end

# source://rubocop//lib/rubocop/cop/layout/multiline_hash_key_line_breaks.rb#69
RuboCop::Cop::Layout::MultilineHashKeyLineBreaks::MSG = T.let(T.unsafe(nil), String)

# Ensures that each argument in a multi-line method call
# starts on a separate line.
#
# NOTE: This cop does not move the first argument, if you want that to
# be on a separate line, see `Layout/FirstMethodArgumentLineBreak`.
#
# @example AllowMultilineFinalElement: false (default)
#
#   # bad
#   foo(a, b,
#   c
#   )
#
#   # bad
#   foo(a, b, {
#   foo: "bar",
#   })
#
#   # good
#   foo(
#   a,
#   b,
#   c
#   )
#
#   # good
#   foo(a, b, c)
#
#   # good
#   foo(
#   a,
#   b,
#   {
#   foo: "bar",
#   }
#   )
# @example AllowMultilineFinalElement: true
#
#   # bad
#   foo(a, b,
#   c
#   )
#
#   # good
#   foo(a, b, {
#   foo: "bar",
#   })
#
#   # good
#   foo(
#   a,
#   b,
#   c
#   )
#
#   # good
#   foo(a, b, c)
#
#   # good
#   foo(
#   a,
#   b,
#   {
#   foo: "bar",
#   }
#   )
#
# source://rubocop//lib/rubocop/cop/layout/multiline_method_argument_line_breaks.rb#73
class RuboCop::Cop::Layout::MultilineMethodArgumentLineBreaks < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::MultilineElementLineBreaks
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/multiline_method_argument_line_breaks.rb#79
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/multiline_method_argument_line_breaks.rb#98
  def ignore_last_element?; end
end

# source://rubocop//lib/rubocop/cop/layout/multiline_method_argument_line_breaks.rb#77
RuboCop::Cop::Layout::MultilineMethodArgumentLineBreaks::MSG = T.let(T.unsafe(nil), String)

# Checks that the closing brace in a method call is either
# on the same line as the last method argument, or a new line.
#
# When using the `symmetrical` (default) style:
#
# If a method call's opening brace is on the same line as the first
# argument of the call, then the closing brace should be on the same
# line as the last argument of the call.
#
# If an method call's opening brace is on the line above the first
# argument of the call, then the closing brace should be on the line
# below the last argument of the call.
#
# When using the `new_line` style:
#
# The closing brace of a multi-line method call must be on the line
# after the last argument of the call.
#
# When using the `same_line` style:
#
# The closing brace of a multi-line method call must be on the same
# line as the last argument of the call.
#
# @example EnforcedStyle: symmetrical (default)
#   # bad
#   foo(a,
#   b
#   )
#
#   # bad
#   foo(
#   a,
#   b)
#
#   # good
#   foo(a,
#   b)
#
#   # good
#   foo(
#   a,
#   b
#   )
# @example EnforcedStyle: new_line
#   # bad
#   foo(
#   a,
#   b)
#
#   # bad
#   foo(a,
#   b)
#
#   # good
#   foo(a,
#   b
#   )
#
#   # good
#   foo(
#   a,
#   b
#   )
# @example EnforcedStyle: same_line
#   # bad
#   foo(a,
#   b
#   )
#
#   # bad
#   foo(
#   a,
#   b
#   )
#
#   # good
#   foo(
#   a,
#   b)
#
#   # good
#   foo(a,
#   b)
#
# source://rubocop//lib/rubocop/cop/layout/multiline_method_call_brace_layout.rb#91
class RuboCop::Cop::Layout::MultilineMethodCallBraceLayout < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_brace_layout.rb#109
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_brace_layout.rb#115
  def children(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_brace_layout.rb#119
  def ignored_literal?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_brace_layout.rb#123
  def single_line_ignoring_receiver?(node); end
end

# source://rubocop//lib/rubocop/cop/layout/multiline_method_call_brace_layout.rb#103
RuboCop::Cop::Layout::MultilineMethodCallBraceLayout::ALWAYS_NEW_LINE_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/multiline_method_call_brace_layout.rb#106
RuboCop::Cop::Layout::MultilineMethodCallBraceLayout::ALWAYS_SAME_LINE_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/multiline_method_call_brace_layout.rb#99
RuboCop::Cop::Layout::MultilineMethodCallBraceLayout::NEW_LINE_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/multiline_method_call_brace_layout.rb#95
RuboCop::Cop::Layout::MultilineMethodCallBraceLayout::SAME_LINE_MESSAGE = T.let(T.unsafe(nil), String)

# Checks the indentation of the method name part in method calls
# that span more than one line.
#
# @example EnforcedStyle: aligned (default)
#   # bad
#   while myvariable
#   .b
#   # do something
#   end
#
#   # good
#   while myvariable
#   .b
#   # do something
#   end
#
#   # good
#   Thing.a
#   .b
#   .c
# @example EnforcedStyle: indented
#   # good
#   while myvariable
#   .b
#
#   # do something
#   end
# @example EnforcedStyle: indented_relative_to_receiver
#   # good
#   while myvariable
#   .a
#   .b
#
#   # do something
#   end
#
#   # good
#   myvariable = Thing
#   .a
#   .b
#   .c
#
# source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#49
class RuboCop::Cop::Layout::MultilineMethodCallIndentation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::MultilineExpressionIndentation
  extend ::RuboCop::Cop::AutoCorrector

  # @raise [ValidationError]
  #
  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#55
  def validate_config; end

  private

  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#136
  def align_with_base_message(rhs); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#152
  def alignment_base(node, rhs, given_style); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#67
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#140
  def base_source; end

  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#101
  def extra_indentation(given_style, parent); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#222
  def first_call_has_a_dot(node); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#213
  def get_dot_right_above(node); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#113
  def message(node, lhs, rhs); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#144
  def no_base_message(lhs, rhs, node); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#87
  def offending_range(node, lhs, rhs, given_style); end

  # @yield [operation_rhs.first_argument]
  #
  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#232
  def operation_rhs(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#242
  def operator_rhs?(node, receiver); end

  # a
  #   .b
  #   .c
  #
  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#193
  def receiver_alignment_base(node); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#131
  def relative_to_receiver_message(rhs); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#71
  def relevant_node?(send_node); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#75
  def right_hand_side(send_node); end

  # a.b
  #  .c
  #
  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#181
  def semantic_alignment_base(node, rhs); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#201
  def semantic_alignment_node(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#127
  def should_align_with_base?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#123
  def should_indent_relative_to_receiver?; end

  # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#163
  def syntactic_alignment_base(lhs, rhs); end
end

# Checks that the closing brace in a method definition is either
# on the same line as the last method parameter, or a new line.
#
# When using the `symmetrical` (default) style:
#
# If a method definition's opening brace is on the same line as the
# first parameter of the definition, then the closing brace should be
# on the same line as the last parameter of the definition.
#
# If an method definition's opening brace is on the line above the first
# parameter of the definition, then the closing brace should be on the
# line below the last parameter of the definition.
#
# When using the `new_line` style:
#
# The closing brace of a multi-line method definition must be on the line
# after the last parameter of the definition.
#
# When using the `same_line` style:
#
# The closing brace of a multi-line method definition must be on the same
# line as the last parameter of the definition.
#
# @example EnforcedStyle: symmetrical (default)
#   # bad
#   def foo(a,
#   b
#   )
#   end
#
#   # bad
#   def foo(
#   a,
#   b)
#   end
#
#   # good
#   def foo(a,
#   b)
#   end
#
#   # good
#   def foo(
#   a,
#   b
#   )
#   end
# @example EnforcedStyle: new_line
#   # bad
#   def foo(
#   a,
#   b)
#   end
#
#   # bad
#   def foo(a,
#   b)
#   end
#
#   # good
#   def foo(a,
#   b
#   )
#   end
#
#   # good
#   def foo(
#   a,
#   b
#   )
#   end
# @example EnforcedStyle: same_line
#   # bad
#   def foo(a,
#   b
#   )
#   end
#
#   # bad
#   def foo(
#   a,
#   b
#   )
#   end
#
#   # good
#   def foo(
#   a,
#   b)
#   end
#
#   # good
#   def foo(a,
#   b)
#   end
#
# source://rubocop//lib/rubocop/cop/layout/multiline_method_definition_brace_layout.rb#103
class RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/multiline_method_definition_brace_layout.rb#121
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_method_definition_brace_layout.rb#121
  def on_defs(node); end
end

# source://rubocop//lib/rubocop/cop/layout/multiline_method_definition_brace_layout.rb#115
RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout::ALWAYS_NEW_LINE_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/multiline_method_definition_brace_layout.rb#118
RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout::ALWAYS_SAME_LINE_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/multiline_method_definition_brace_layout.rb#111
RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout::NEW_LINE_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/multiline_method_definition_brace_layout.rb#107
RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout::SAME_LINE_MESSAGE = T.let(T.unsafe(nil), String)

# Ensures that each parameter in a multi-line method definition
# starts on a separate line.
#
# NOTE: This cop does not move the first argument, if you want that to
# be on a separate line, see `Layout/FirstMethodParameterLineBreak`.
#
# @example AllowMultilineFinalElement: false (default)
#
#   # bad
#   def foo(a, b,
#   c
#   )
#   end
#
#   # bad
#   def foo(a, b = {
#   foo: "bar",
#   })
#   end
#
#   # good
#   def foo(
#   a,
#   b,
#   c
#   )
#   end
#
#   # good
#   def foo(
#   a,
#   b = {
#   foo: "bar",
#   }
#   )
#   end
#
#   # good
#   def foo(a, b, c)
#   end
# @example AllowMultilineFinalElement: true
#
#   # bad
#   def foo(a, b,
#   c
#   )
#   end
#
#   # good
#   def foo(a, b = {
#   foo: "bar",
#   })
#   end
#
#   # good
#   def foo(
#   a,
#   b,
#   c
#   )
#   end
#
#   # good
#   def foo(
#   a,
#   b = {
#   foo: "bar",
#   }
#   )
#   end
#
#   # good
#   def foo(a, b, c)
#   end
#
# source://rubocop//lib/rubocop/cop/layout/multiline_method_parameter_line_breaks.rb#81
class RuboCop::Cop::Layout::MultilineMethodParameterLineBreaks < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::MultilineElementLineBreaks
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/multiline_method_parameter_line_breaks.rb#87
  def on_def(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/multiline_method_parameter_line_breaks.rb#95
  def ignore_last_element?; end
end

# source://rubocop//lib/rubocop/cop/layout/multiline_method_parameter_line_breaks.rb#85
RuboCop::Cop::Layout::MultilineMethodParameterLineBreaks::MSG = T.let(T.unsafe(nil), String)

# Checks the indentation of the right hand side operand in binary operations that
# span more than one line.
#
# The `aligned` style checks that operators are aligned if they are part of an `if` or `while`
# condition, an explicit `return` statement, etc. In other contexts, the second operand should
# be indented regardless of enforced style.
#
# @example EnforcedStyle: aligned (default)
#   # bad
#   if a +
#   b
#   something &&
#   something_else
#   end
#
#   # good
#   if a +
#   b
#   something &&
#   something_else
#   end
# @example EnforcedStyle: indented
#   # bad
#   if a +
#   b
#   something &&
#   something_else
#   end
#
#   # good
#   if a +
#   b
#   something &&
#   something_else
#   end
#
# source://rubocop//lib/rubocop/cop/layout/multiline_operation_indentation.rb#43
class RuboCop::Cop::Layout::MultilineOperationIndentation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::MultilineExpressionIndentation
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/multiline_operation_indentation.rb#49
  def on_and(node); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_operation_indentation.rb#53
  def on_or(node); end

  # @raise [ValidationError]
  #
  # source://rubocop//lib/rubocop/cop/layout/multiline_operation_indentation.rb#57
  def validate_config; end

  private

  # source://rubocop//lib/rubocop/cop/layout/multiline_operation_indentation.rb#68
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_operation_indentation.rb#78
  def check_and_or(node); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_operation_indentation.rb#110
  def message(node, lhs, rhs); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_operation_indentation.rb#84
  def offending_range(node, lhs, rhs, given_style); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/multiline_operation_indentation.rb#72
  def relevant_node?(node); end

  # source://rubocop//lib/rubocop/cop/layout/multiline_operation_indentation.rb#121
  def right_hand_side(send_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/multiline_operation_indentation.rb#97
  def should_align?(node, rhs, given_style); end
end

# Here we check if the parameters on a multi-line method call or
# definition are aligned.
#
# To set the alignment of the first argument, use the cop
# FirstParameterIndentation.
#
# @example EnforcedStyle: with_first_parameter (default)
#   # good
#
#   def foo(bar,
#   baz)
#   123
#   end
#
#   def foo(
#   bar,
#   baz
#   )
#   123
#   end
#
#   # bad
#
#   def foo(bar,
#   baz)
#   123
#   end
#
#   # bad
#
#   def foo(
#   bar,
#   baz)
#   123
#   end
# @example EnforcedStyle: with_fixed_indentation
#   # good
#
#   def foo(bar,
#   baz)
#   123
#   end
#
#   def foo(
#   bar,
#   baz
#   )
#   123
#   end
#
#   # bad
#
#   def foo(bar,
#   baz)
#   123
#   end
#
#   # bad
#
#   def foo(
#   bar,
#   baz)
#   123
#   end
#
# source://rubocop//lib/rubocop/cop/layout/parameter_alignment.rb#71
class RuboCop::Cop::Layout::ParameterAlignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/parameter_alignment.rb#81
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/layout/parameter_alignment.rb#81
  def on_defs(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/parameter_alignment.rb#90
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/layout/parameter_alignment.rb#102
  def base_column(node, args); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/parameter_alignment.rb#98
  def fixed_indentation?; end

  # source://rubocop//lib/rubocop/cop/layout/parameter_alignment.rb#94
  def message(_node); end

  # source://rubocop//lib/rubocop/cop/layout/parameter_alignment.rb#113
  def target_method_lineno(node); end
end

# source://rubocop//lib/rubocop/cop/layout/parameter_alignment.rb#75
RuboCop::Cop::Layout::ParameterAlignment::ALIGN_PARAMS_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/parameter_alignment.rb#78
RuboCop::Cop::Layout::ParameterAlignment::FIXED_INDENT_MSG = T.let(T.unsafe(nil), String)

# Checks whether certain expressions, e.g. method calls, that could fit
# completely on a single line, are broken up into multiple lines unnecessarily.
#
# @example any configuration
#   # bad
#   foo(
#   a,
#   b
#   )
#
#   puts 'string that fits on ' \
#   'a single line'
#
#   things
#   .select { |thing| thing.cond? }
#   .join('-')
#
#   # good
#   foo(a, b)
#
#   puts 'string that fits on a single line'
#
#   things.select { |thing| thing.cond? }.join('-')
# @example InspectBlocks: false (default)
#   # good
#   foo(a) do |x|
#   puts x
#   end
# @example InspectBlocks: true
#   # bad
#   foo(a) do |x|
#   puts x
#   end
#
#   # good
#   foo(a) { |x| puts x }
#
# source://rubocop//lib/rubocop/cop/layout/redundant_line_break.rb#45
class RuboCop::Cop::Layout::RedundantLineBreak < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::CheckAssignment
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/redundant_line_break.rb#51
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/redundant_line_break.rb#64
  def check_assignment(node, _rhs); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/redundant_line_break.rb#112
  def comment_within?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/redundant_line_break.rb#82
  def configured_to_not_be_inspected?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/redundant_line_break.rb#106
  def convertible_block?(node); end

  # source://rubocop//lib/rubocop/cop/layout/redundant_line_break.rb#132
  def max_line_length; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/redundant_line_break.rb#77
  def offense?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/redundant_line_break.rb#89
  def other_cop_takes_precedence?(node); end

  # source://rubocop//lib/rubocop/cop/layout/redundant_line_break.rb#70
  def register_offense(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/redundant_line_break.rb#95
  def single_line_block_chain_enabled?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/redundant_line_break.rb#99
  def suitable_as_single_line?(node); end

  # source://rubocop//lib/rubocop/cop/layout/redundant_line_break.rb#123
  def to_single_line(source); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/redundant_line_break.rb#118
  def too_long?(node); end
end

# source://rubocop//lib/rubocop/cop/layout/redundant_line_break.rb#49
RuboCop::Cop::Layout::RedundantLineBreak::MSG = T.let(T.unsafe(nil), String)

# Checks whether the rescue and ensure keywords are aligned
# properly.
#
# @example
#
#   # bad
#   begin
#   something
#   rescue
#   puts 'error'
#   end
#
#   # good
#   begin
#   something
#   rescue
#   puts 'error'
#   end
#
# source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#24
class RuboCop::Cop::Layout::RescueEnsureAlignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::EndKeywordAlignment
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#40
  def on_ensure(node); end

  # source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#44
  def on_new_investigation; end

  # source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#36
  def on_resbody(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#186
  def access_modifier?(node); end

  # source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#163
  def access_modifier_node(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#149
  def aligned_with_leading_dot?(do_keyword_line, send_node_loc, rescue_keyword_column); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#136
  def aligned_with_line_break_method?(ancestor_node, node); end

  # source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#195
  def alignment_location(alignment_node); end

  # We will use ancestor or wrapper with access modifier.
  #
  # source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#116
  def alignment_node(node); end

  # source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#95
  def alignment_source(node, starting_loc); end

  # source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#132
  def ancestor_node(node); end

  # source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#155
  def assignment_node(node); end

  # source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#73
  def autocorrect(corrector, node, alignment_location); end

  # source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#203
  def begin_end_alignment_style; end

  # Check alignment of node with rescue or ensure modifiers.
  #
  # source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#57
  def check(node); end

  # source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#83
  def format_message(alignment_node, alignment_loc, kw_loc); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#173
  def modifier?(node); end

  # source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#179
  def whitespace_range(node); end
end

# source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#34
RuboCop::Cop::Layout::RescueEnsureAlignment::ALTERNATIVE_ACCESS_MODIFIERS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#32
RuboCop::Cop::Layout::RescueEnsureAlignment::ANCESTOR_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#33
RuboCop::Cop::Layout::RescueEnsureAlignment::ANCESTOR_TYPES_WITH_ACCESS_MODIFIERS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#29
RuboCop::Cop::Layout::RescueEnsureAlignment::MSG = T.let(T.unsafe(nil), String)

# Checks if method calls are chained onto single line blocks. It considers that a
# line break before the dot improves the readability of the code.
#
# @example
#   # bad
#   example.select { |item| item.cond? }.join('-')
#
#   # good
#   example.select { |item| item.cond? }
#   .join('-')
#
#   # good (not a concern for this cop)
#   example.select do |item|
#   item.cond?
#   end.join('-')
#
# source://rubocop//lib/rubocop/cop/layout/single_line_block_chain.rb#22
class RuboCop::Cop::Layout::SingleLineBlockChain < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/single_line_block_chain.rb#28
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/single_line_block_chain.rb#51
  def call_method_after_block?(node, dot_range, closing_block_delimiter_line_num); end

  # source://rubocop//lib/rubocop/cop/layout/single_line_block_chain.rb#35
  def offending_range(node); end

  # source://rubocop//lib/rubocop/cop/layout/single_line_block_chain.rb#57
  def selector_range(node); end
end

# source://rubocop//lib/rubocop/cop/layout/single_line_block_chain.rb#26
RuboCop::Cop::Layout::SingleLineBlockChain::MSG = T.let(T.unsafe(nil), String)

# Checks for colon (:) not followed by some kind of space.
# N.B. this cop does not handle spaces after a ternary operator, which are
# instead handled by Layout/SpaceAroundOperators.
#
# @example
#   # bad
#   def f(a:, b:2); {a:3}; end
#
#   # good
#   def f(a:, b: 2); {a: 3}; end
#
# source://rubocop//lib/rubocop/cop/layout/space_after_colon.rb#16
class RuboCop::Cop::Layout::SpaceAfterColon < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/space_after_colon.rb#29
  def on_kwoptarg(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_after_colon.rb#21
  def on_pair(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_after_colon.rb#43
  def followed_by_space?(colon); end

  # source://rubocop//lib/rubocop/cop/layout/space_after_colon.rb#39
  def register_offense(colon); end
end

# source://rubocop//lib/rubocop/cop/layout/space_after_colon.rb#19
RuboCop::Cop::Layout::SpaceAfterColon::MSG = T.let(T.unsafe(nil), String)

# Checks for comma (,) not followed by some kind of space.
#
# @example
#
#   # bad
#   [1,2]
#   { foo:bar,}
#
#   # good
#   [1, 2]
#   { foo:bar, }
#
# source://rubocop//lib/rubocop/cop/layout/space_after_comma.rb#17
class RuboCop::Cop::Layout::SpaceAfterComma < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::SpaceAfterPunctuation
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/space_after_comma.rb#26
  def kind(token); end

  # source://rubocop//lib/rubocop/cop/layout/space_after_comma.rb#21
  def space_style_before_rcurly; end
end

# Checks for space between a method name and a left parenthesis in defs.
#
# @example
#
#   # bad
#   def func (x) end
#   def method= (y) end
#
#   # good
#   def func(x) end
#   def method=(y) end
#
# source://rubocop//lib/rubocop/cop/layout/space_after_method_name.rb#17
class RuboCop::Cop::Layout::SpaceAfterMethodName < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/space_after_method_name.rb#23
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_after_method_name.rb#23
  def on_defs(node); end
end

# source://rubocop//lib/rubocop/cop/layout/space_after_method_name.rb#21
RuboCop::Cop::Layout::SpaceAfterMethodName::MSG = T.let(T.unsafe(nil), String)

# Checks for space after `!`.
#
# @example
#   # bad
#   ! something
#
#   # good
#   !something
#
# source://rubocop//lib/rubocop/cop/layout/space_after_not.rb#14
class RuboCop::Cop::Layout::SpaceAfterNot < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/space_after_not.rb#21
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_after_not.rb#33
  def whitespace_after_operator?(node); end
end

# source://rubocop//lib/rubocop/cop/layout/space_after_not.rb#18
RuboCop::Cop::Layout::SpaceAfterNot::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/space_after_not.rb#19
RuboCop::Cop::Layout::SpaceAfterNot::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for semicolon (;) not followed by some kind of space.
#
# @example
#   # bad
#   x = 1;y = 2
#
#   # good
#   x = 1; y = 2
#
# source://rubocop//lib/rubocop/cop/layout/space_after_semicolon.rb#14
class RuboCop::Cop::Layout::SpaceAfterSemicolon < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::SpaceAfterPunctuation
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/space_after_semicolon.rb#23
  def kind(token); end

  # source://rubocop//lib/rubocop/cop/layout/space_after_semicolon.rb#18
  def space_style_before_rcurly; end
end

# Checks the spacing inside and after block parameters pipes. Line breaks
# inside parameter pipes are checked by `Layout/MultilineBlockLayout` and
# not by this cop.
#
# @example EnforcedStyleInsidePipes: no_space (default)
#   # bad
#   {}.each { | x,  y |puts x }
#   ->( x,  y ) { puts x }
#
#   # good
#   {}.each { |x, y| puts x }
#   ->(x, y) { puts x }
# @example EnforcedStyleInsidePipes: space
#   # bad
#   {}.each { |x,  y| puts x }
#   ->(x,  y) { puts x }
#
#   # good
#   {}.each { | x, y | puts x }
#   ->( x, y ) { puts x }
#
# source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#27
class RuboCop::Cop::Layout::SpaceAroundBlockParameters < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#32
  def on_block(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#65
  def check_after_closing_pipe(arguments); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#125
  def check_arg(arg); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#103
  def check_closing_pipe_space(arguments, closing_pipe); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#121
  def check_each_arg(args); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#56
  def check_inside_pipes(arguments); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#150
  def check_no_space(space_begin_pos, space_end_pos, msg); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#73
  def check_no_space_style_inside_pipes(arguments); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#92
  def check_opening_pipe_space(arguments, opening_pipe); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#136
  def check_space(space_begin_pos, space_end_pos, range, msg, node = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#85
  def check_space_style_inside_pipes(arguments); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#113
  def last_end_pos_inside_pipes(arguments, range); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#44
  def pipes(arguments); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#48
  def pipes?(arguments); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#52
  def style_parameter_name; end
end

# Checks that the equals signs in parameter default assignments
# have or don't have surrounding space depending on configuration.
#
# @example EnforcedStyle: space (default)
#   # bad
#   def some_method(arg1=:default, arg2=nil, arg3=[])
#   # do something...
#   end
#
#   # good
#   def some_method(arg1 = :default, arg2 = nil, arg3 = [])
#   # do something...
#   end
# @example EnforcedStyle: no_space
#   # bad
#   def some_method(arg1 = :default, arg2 = nil, arg3 = [])
#   # do something...
#   end
#
#   # good
#   def some_method(arg1=:default, arg2=nil, arg3=[])
#   # do something...
#   end
#
# source://rubocop//lib/rubocop/cop/layout/space_around_equals_in_parameter_default.rb#30
class RuboCop::Cop::Layout::SpaceAroundEqualsInParameterDefault < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/space_around_equals_in_parameter_default.rb#38
  def on_optarg(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/space_around_equals_in_parameter_default.rb#67
  def autocorrect(corrector, range); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_equals_in_parameter_default.rb#46
  def check_optarg(arg, equals, value); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_equals_in_parameter_default.rb#58
  def incorrect_style_detected(arg, value); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_equals_in_parameter_default.rb#83
  def message(_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_around_equals_in_parameter_default.rb#79
  def no_surrounding_space?(arg, equals); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_around_equals_in_parameter_default.rb#75
  def space_on_both_sides?(arg, equals); end
end

# source://rubocop//lib/rubocop/cop/layout/space_around_equals_in_parameter_default.rb#36
RuboCop::Cop::Layout::SpaceAroundEqualsInParameterDefault::MSG = T.let(T.unsafe(nil), String)

# Checks the spacing around the keywords.
#
# @example
#
#   # bad
#   something 'test'do|x|
#   end
#
#   while(something)
#   end
#
#   something = 123if test
#
#   # good
#   something 'test' do |x|
#   end
#
#   while (something)
#   end
#
#   something = 123 if test
#
# source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#27
class RuboCop::Cop::Layout::SpaceAroundKeyword < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#40
  def on_and(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#44
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#48
  def on_break(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#52
  def on_case(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#56
  def on_case_match(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#156
  def on_defined?(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#60
  def on_ensure(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#64
  def on_for(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#68
  def on_if(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#72
  def on_if_guard(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#76
  def on_in_pattern(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#80
  def on_kwbegin(node); end

  # Handle one-line pattern matching syntax (`in`) with `Parser::Ruby27`.
  #
  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#85
  def on_match_pattern(node); end

  # Handle one-line pattern matching syntax (`in`) with `Parser::Ruby30`.
  #
  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#92
  def on_match_pattern_p(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#96
  def on_next(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#100
  def on_or(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#104
  def on_postexe(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#108
  def on_preexe(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#112
  def on_resbody(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#116
  def on_rescue(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#120
  def on_return(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#124
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#128
  def on_super(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#136
  def on_unless_guard(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#140
  def on_until(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#144
  def on_when(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#148
  def on_while(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#152
  def on_yield(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#132
  def on_zsuper(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#235
  def accept_left_parenthesis?(range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#239
  def accept_left_square_bracket?(range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#243
  def accept_namespace_operator?(range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#228
  def accepted_opening_delimiter?(range, char); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#162
  def check(node, locations, begin_keyword = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#177
  def check_begin(node, range, begin_keyword); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#183
  def check_end(node, range, begin_keyword); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#196
  def check_keyword(node, range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#192
  def do?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#251
  def namespace_operator?(range, pos); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#255
  def preceded_by_operator?(node, _range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#247
  def safe_navigation_call?(range, pos); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#217
  def space_after_missing?(range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#210
  def space_before_missing?(range); end
end

# source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#36
RuboCop::Cop::Layout::SpaceAroundKeyword::ACCEPT_LEFT_PAREN = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#37
RuboCop::Cop::Layout::SpaceAroundKeyword::ACCEPT_LEFT_SQUARE_BRACKET = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#38
RuboCop::Cop::Layout::SpaceAroundKeyword::ACCEPT_NAMESPACE_OPERATOR = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#33
RuboCop::Cop::Layout::SpaceAroundKeyword::DO = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#31
RuboCop::Cop::Layout::SpaceAroundKeyword::MSG_AFTER = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#30
RuboCop::Cop::Layout::SpaceAroundKeyword::MSG_BEFORE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#35
RuboCop::Cop::Layout::SpaceAroundKeyword::NAMESPACE_OPERATOR = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#34
RuboCop::Cop::Layout::SpaceAroundKeyword::SAFE_NAVIGATION = T.let(T.unsafe(nil), String)

# Checks method call operators to not have spaces around them.
#
# @example
#   # bad
#   foo. bar
#   foo .bar
#   foo . bar
#   foo. bar .buzz
#   foo
#   . bar
#   . buzz
#   foo&. bar
#   foo &.bar
#   foo &. bar
#   foo &. bar&. buzz
#   RuboCop:: Cop
#   RuboCop:: Cop:: Cop
#   :: RuboCop::Cop
#
#   # good
#   foo.bar
#   foo.bar.buzz
#   foo
#   .bar
#   .buzz
#   foo&.bar
#   foo&.bar&.buzz
#   RuboCop::Cop
#   RuboCop::Cop::Cop
#   ::RuboCop::Cop
#
# source://rubocop//lib/rubocop/cop/layout/space_around_method_call_operator.rb#37
class RuboCop::Cop::Layout::SpaceAroundMethodCallOperator < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/space_around_method_call_operator.rb#53
  def on_const(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_method_call_operator.rb#45
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_method_call_operator.rb#45
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/space_around_method_call_operator.rb#87
  def check_space(begin_pos, end_pos); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_method_call_operator.rb#67
  def check_space_after_dot(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_method_call_operator.rb#81
  def check_space_after_double_colon(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_method_call_operator.rb#61
  def check_space_before_dot(node); end
end

# source://rubocop//lib/rubocop/cop/layout/space_around_method_call_operator.rb#43
RuboCop::Cop::Layout::SpaceAroundMethodCallOperator::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/space_around_method_call_operator.rb#41
RuboCop::Cop::Layout::SpaceAroundMethodCallOperator::SPACES_REGEXP = T.let(T.unsafe(nil), Regexp)

# Checks that operators have space around them, except for ** which
# should or shouldn't have surrounding space depending on configuration.
# It allows vertical alignment consisting of one or more whitespace
# around operators.
#
# This cop has `AllowForAlignment` option. When `true`, allows most
# uses of extra spacing if the intent is to align with an operator on
# the previous or next line, not counting empty lines or comment lines.
#
# @example
#   # bad
#   total = 3*4
#   "apple"+"juice"
#   my_number = 38/4
#
#   # good
#   total = 3 * 4
#   "apple" + "juice"
#   my_number = 38 / 4
# @example AllowForAlignment: true (default)
#   # good
#   {
#   1 =>  2,
#   11 => 3
#   }
# @example AllowForAlignment: false
#   # bad
#   {
#   1 =>  2,
#   11 => 3
#   }
# @example EnforcedStyleForExponentOperator: no_space (default)
#   # bad
#   a ** b
#
#   # good
#   a**b
# @example EnforcedStyleForExponentOperator: space
#   # bad
#   a**b
#
#   # good
#   a ** b
#
# source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#53
class RuboCop::Cop::Layout::SpaceAroundOperators < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::PrecedingFollowingAlignment
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::RationalLiteral
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#119
  def on_and(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#103
  def on_and_asgn(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#103
  def on_assignment(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#119
  def on_binary(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#111
  def on_casgn(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#119
  def on_class(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#103
  def on_cvasgn(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#103
  def on_gvasgn(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#78
  def on_if(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#103
  def on_ivasgn(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#103
  def on_lvasgn(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#103
  def on_masgn(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#135
  def on_match_pattern(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#127
  def on_op_asgn(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#119
  def on_or(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#103
  def on_or_asgn(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#70
  def on_pair(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#85
  def on_resbody(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#66
  def on_sclass(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#93
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#127
  def on_special_asgn(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#236
  def align_hash_cop_config; end

  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#179
  def autocorrect(corrector, range); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#163
  def check_operator(type, operator, right_operand); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#189
  def enclose_operator_with_space(corrector, range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#216
  def excess_leading_space?(type, operator, with_space); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#231
  def excess_trailing_space?(right_operand, with_space); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#248
  def force_equal_sign_alignment?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#240
  def hash_table_style?; end

  # @yield [msg]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#174
  def offense(type, operator, with_space, right_operand); end

  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#202
  def offense_message(type, operator, with_space, right_operand); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#159
  def operator_with_regular_syntax?(send_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#155
  def regular_operator?(send_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#252
  def should_not_have_surrounding_space?(operator); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#244
  def space_around_exponent_operator?; end

  class << self
    # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#62
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#60
RuboCop::Cop::Layout::SpaceAroundOperators::EXCESSIVE_SPACE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#59
RuboCop::Cop::Layout::SpaceAroundOperators::IRREGULAR_METHODS = T.let(T.unsafe(nil), Array)

# Checks that block braces have or don't have a space before the opening
# brace depending on configuration.
#
# @example EnforcedStyle: space (default)
#   # bad
#   foo.map{ |a|
#   a.bar.to_s
#   }
#
#   # good
#   foo.map { |a|
#   a.bar.to_s
#   }
# @example EnforcedStyle: no_space
#   # bad
#   foo.map { |a|
#   a.bar.to_s
#   }
#
#   # good
#   foo.map{ |a|
#   a.bar.to_s
#   }
# @example EnforcedStyleForEmptyBraces: space (default)
#   # bad
#   7.times{}
#
#   # good
#   7.times {}
# @example EnforcedStyleForEmptyBraces: no_space
#   # bad
#   7.times {}
#
#   # good
#   7.times{}
#
# source://rubocop//lib/rubocop/cop/layout/space_before_block_braces.rb#44
class RuboCop::Cop::Layout::SpaceBeforeBlockBraces < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/space_before_block_braces.rb#56
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_before_block_braces.rb#56
  def on_numblock(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/space_before_block_braces.rb#124
  def autocorrect(corrector, range); end

  # source://rubocop//lib/rubocop/cop/layout/space_before_block_braces.rb#144
  def block_delimiters_style; end

  # source://rubocop//lib/rubocop/cop/layout/space_before_block_braces.rb#83
  def check_empty(left_brace, space_plus_brace, used_style); end

  # source://rubocop//lib/rubocop/cop/layout/space_before_block_braces.rb#100
  def check_non_empty(left_brace, space_plus_brace, used_style); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_before_block_braces.rb#140
  def conflict_with_block_delimiters?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_before_block_braces.rb#148
  def empty_braces?(loc); end

  # source://rubocop//lib/rubocop/cop/layout/space_before_block_braces.rb#115
  def space_detected(left_brace, space_plus_brace); end

  # source://rubocop//lib/rubocop/cop/layout/space_before_block_braces.rb#108
  def space_missing(left_brace); end

  # source://rubocop//lib/rubocop/cop/layout/space_before_block_braces.rb#131
  def style_for_empty_braces; end

  class << self
    # source://rubocop//lib/rubocop/cop/layout/space_before_block_braces.rb#52
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop//lib/rubocop/cop/layout/space_before_block_braces.rb#50
RuboCop::Cop::Layout::SpaceBeforeBlockBraces::DETECTED_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/space_before_block_braces.rb#49
RuboCop::Cop::Layout::SpaceBeforeBlockBraces::MISSING_MSG = T.let(T.unsafe(nil), String)

# Checks for space between the name of a receiver and a left
# brackets.
#
# @example
#
#   # bad
#   collection [index_or_key]
#
#   # good
#   collection[index_or_key]
#
# source://rubocop//lib/rubocop/cop/layout/space_before_brackets.rb#17
class RuboCop::Cop::Layout::SpaceBeforeBrackets < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/space_before_brackets.rb#24
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_before_brackets.rb#48
  def dot_before_brackets?(node, receiver_end_pos, selector_begin_pos); end

  # source://rubocop//lib/rubocop/cop/layout/space_before_brackets.rb#35
  def offense_range(node, begin_pos); end

  # source://rubocop//lib/rubocop/cop/layout/space_before_brackets.rb#54
  def offense_range_for_assignment(node, begin_pos); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_before_brackets.rb#67
  def reference_variable_with_brackets?(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_before_brackets.rb#63
  def register_offense(range); end
end

# source://rubocop//lib/rubocop/cop/layout/space_before_brackets.rb#21
RuboCop::Cop::Layout::SpaceBeforeBrackets::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/space_before_brackets.rb#22
RuboCop::Cop::Layout::SpaceBeforeBrackets::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for comma (,) preceded by space.
#
# @example
#   # bad
#   [1 , 2 , 3]
#   a(1 , 2)
#   each { |a , b| }
#
#   # good
#   [1, 2, 3]
#   a(1, 2)
#   each { |a, b| }
#
# source://rubocop//lib/rubocop/cop/layout/space_before_comma.rb#19
class RuboCop::Cop::Layout::SpaceBeforeComma < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SpaceBeforePunctuation
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/space_before_comma.rb#23
  def kind(token); end
end

# Checks for missing space between a token and a comment on the
# same line.
#
# @example
#   # bad
#   1 + 1# this operation does ...
#
#   # good
#   1 + 1 # this operation does ...
#
# source://rubocop//lib/rubocop/cop/layout/space_before_comment.rb#15
class RuboCop::Cop::Layout::SpaceBeforeComment < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/space_before_comment.rb#20
  def on_new_investigation; end
end

# source://rubocop//lib/rubocop/cop/layout/space_before_comment.rb#18
RuboCop::Cop::Layout::SpaceBeforeComment::MSG = T.let(T.unsafe(nil), String)

# Checks that exactly one space is used between a method name and the
# first argument for method calls without parentheses.
#
# Alternatively, extra spaces can be added to align the argument with
# something on a preceding or following line, if the AllowForAlignment
# config parameter is true.
#
# @example
#   # bad
#   something  x
#   something   y, z
#   something'hello'
#
#   # good
#   something x
#   something y, z
#   something 'hello'
#
# source://rubocop//lib/rubocop/cop/layout/space_before_first_arg.rb#24
class RuboCop::Cop::Layout::SpaceBeforeFirstArg < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::PrecedingFollowingAlignment
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/space_before_first_arg.rb#35
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_before_first_arg.rb#35
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_before_first_arg.rb#55
  def expect_params_after_method_name?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_before_first_arg.rb#64
  def no_space_between_method_name_and_first_argument?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_before_first_arg.rb#51
  def regular_method_call_with_arguments?(node); end

  class << self
    # source://rubocop//lib/rubocop/cop/layout/space_before_first_arg.rb#31
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop//lib/rubocop/cop/layout/space_before_first_arg.rb#29
RuboCop::Cop::Layout::SpaceBeforeFirstArg::MSG = T.let(T.unsafe(nil), String)

# Checks for semicolon (;) preceded by space.
#
# @example
#   # bad
#   x = 1 ; y = 2
#
#   # good
#   x = 1; y = 2
#
# source://rubocop//lib/rubocop/cop/layout/space_before_semicolon.rb#14
class RuboCop::Cop::Layout::SpaceBeforeSemicolon < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SpaceBeforePunctuation
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/space_before_semicolon.rb#18
  def kind(token); end
end

# Checks for spaces between `->` and opening parameter
# parenthesis (`(`) in lambda literals.
#
# @example EnforcedStyle: require_no_space (default)
#   # bad
#   a = -> (x, y) { x + y }
#
#   # good
#   a = ->(x, y) { x + y }
# @example EnforcedStyle: require_space
#   # bad
#   a = ->(x, y) { x + y }
#
#   # good
#   a = -> (x, y) { x + y }
#
# source://rubocop//lib/rubocop/cop/layout/space_in_lambda_literal.rb#22
class RuboCop::Cop::Layout::SpaceInLambdaLiteral < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/space_in_lambda_literal.rb#30
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_in_lambda_literal.rb#50
  def arrow_lambda_with_args?(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_in_lambda_literal.rb#72
  def lambda_arguments(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_in_lambda_literal.rb#65
  def range_of_offense(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_in_lambda_literal.rb#58
  def space_after_arrow(lambda_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_in_lambda_literal.rb#54
  def space_after_arrow?(lambda_node); end
end

# source://rubocop//lib/rubocop/cop/layout/space_in_lambda_literal.rb#28
RuboCop::Cop::Layout::SpaceInLambdaLiteral::MSG_REQUIRE_NO_SPACE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/space_in_lambda_literal.rb#27
RuboCop::Cop::Layout::SpaceInLambdaLiteral::MSG_REQUIRE_SPACE = T.let(T.unsafe(nil), String)

# Checks that brackets used for array literals have or don't have
# surrounding space depending on configuration.
#
# @example EnforcedStyle: no_space (default)
#   # The `no_space` style enforces that array literals have
#   # no surrounding space.
#
#   # bad
#   array = [ a, b, c, d ]
#
#   # good
#   array = [a, b, c, d]
# @example EnforcedStyle: space
#   # The `space` style enforces that array literals have
#   # surrounding space.
#
#   # bad
#   array = [a, b, c, d]
#
#   # good
#   array = [ a, b, c, d ]
# @example EnforcedStyle: compact
#   # The `compact` style normally requires a space inside
#   # array brackets, with the exception that successive left
#   # or right brackets are collapsed together in nested arrays.
#
#   # bad
#   array = [ a, [ b, c ] ]
#   array = [
#   [ a ],
#   [ b, c ]
#   ]
#
#   # good
#   array = [ a, [ b, c ]]
#   array = [[ a ],
#   [ b, c ]]
# @example EnforcedStyleForEmptyBrackets: no_space (default)
#   # The `no_space` EnforcedStyleForEmptyBrackets style enforces that
#   # empty array brackets do not contain spaces.
#
#   # bad
#   foo = [ ]
#   bar = [     ]
#
#   # good
#   foo = []
#   bar = []
# @example EnforcedStyleForEmptyBrackets: space
#   # The `space` EnforcedStyleForEmptyBrackets style enforces that
#   # empty array brackets contain exactly one space.
#
#   # bad
#   foo = []
#   bar = [    ]
#
#   # good
#   foo = [ ]
#   bar = [ ]
#
# source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#70
class RuboCop::Cop::Layout::SpaceInsideArrayLiteralBrackets < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#78
  def on_array(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#109
  def array_brackets(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#95
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#217
  def compact(corrector, bracket, side); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#203
  def compact_corrections(corrector, node, left, right); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#195
  def compact_offense(node, token, side: T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#157
  def compact_offenses(node, left, right, start_ok, end_ok); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#118
  def empty_config; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#126
  def end_has_own_line?(token); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#133
  def index_for(node, token); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#141
  def issue_offenses(node, left, right, start_ok, end_ok); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#137
  def line_and_column_for(token); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#178
  def multi_dimensional_array?(node, token, side: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#189
  def next_to_bracket?(token, side: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#153
  def next_to_comment?(node, token); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#122
  def next_to_newline?(node, token); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#170
  def qualifies_for_compact?(node, token, side: T.unsafe(nil)); end
end

# source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#76
RuboCop::Cop::Layout::SpaceInsideArrayLiteralBrackets::EMPTY_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#75
RuboCop::Cop::Layout::SpaceInsideArrayLiteralBrackets::MSG = T.let(T.unsafe(nil), String)

# Checks for unnecessary additional spaces inside array percent literals
# (i.e. %i/%w).
#
# Note that blank percent literals (e.g. `%i( )`) are checked by
# `Layout/SpaceInsidePercentLiteralDelimiters`.
#
# @example
#
#   # bad
#   %w(foo  bar  baz)
#   # good
#   %i(foo bar baz)
#
# source://rubocop//lib/rubocop/cop/layout/space_inside_array_percent_literal.rb#18
class RuboCop::Cop::Layout::SpaceInsideArrayPercentLiteral < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::MatchRange
  include ::RuboCop::Cop::PercentLiteral
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/space_inside_array_percent_literal.rb#26
  def on_array(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_array_percent_literal.rb#30
  def on_percent_literal(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/space_inside_array_percent_literal.rb#40
  def each_unnecessary_space_match(node, &blk); end
end

# source://rubocop//lib/rubocop/cop/layout/space_inside_array_percent_literal.rb#23
RuboCop::Cop::Layout::SpaceInsideArrayPercentLiteral::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/space_inside_array_percent_literal.rb#24
RuboCop::Cop::Layout::SpaceInsideArrayPercentLiteral::MULTIPLE_SPACES_BETWEEN_ITEMS_REGEX = T.let(T.unsafe(nil), Regexp)

# Checks that block braces have or don't have surrounding space inside
# them on configuration. For blocks taking parameters, it checks that the
# left brace has or doesn't have trailing space depending on
# configuration.
#
# @example EnforcedStyle: space (default)
#   # The `space` style enforces that block braces have
#   # surrounding space.
#
#   # bad
#   some_array.each {puts e}
#
#   # good
#   some_array.each { puts e }
# @example EnforcedStyle: no_space
#   # The `no_space` style enforces that block braces don't
#   # have surrounding space.
#
#   # bad
#   some_array.each { puts e }
#
#   # good
#   some_array.each {puts e}
# @example EnforcedStyleForEmptyBraces: no_space (default)
#   # The `no_space` EnforcedStyleForEmptyBraces style enforces that
#   # block braces don't have a space in between when empty.
#
#   # bad
#   some_array.each {   }
#   some_array.each {  }
#   some_array.each { }
#
#   # good
#   some_array.each {}
# @example EnforcedStyleForEmptyBraces: space
#   # The `space` EnforcedStyleForEmptyBraces style enforces that
#   # block braces have at least a space in between when empty.
#
#   # bad
#   some_array.each {}
#
#   # good
#   some_array.each { }
#   some_array.each {  }
#   some_array.each {   }
# @example SpaceBeforeBlockParameters: true (default)
#   # The SpaceBeforeBlockParameters style set to `true` enforces that
#   # there is a space between `{` and `|`. Overrides `EnforcedStyle`
#   # if there is a conflict.
#
#   # bad
#   [1, 2, 3].each {|n| n * 2 }
#
#   # good
#   [1, 2, 3].each { |n| n * 2 }
# @example SpaceBeforeBlockParameters: false
#   # The SpaceBeforeBlockParameters style set to `false` enforces that
#   # there is no space between `{` and `|`. Overrides `EnforcedStyle`
#   # if there is a conflict.
#
#   # bad
#   [1, 2, 3].each { |n| n * 2 }
#
#   # good
#   [1, 2, 3].each {|n| n * 2 }
#
# source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#79
class RuboCop::Cop::Layout::SpaceInsideBlockBraces < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SurroundingSpace
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#85
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#85
  def on_numblock(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#122
  def adjacent_braces(left_brace, right_brace); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#161
  def aligned_braces?(inner, right_brace, column); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#130
  def braces_with_contents_inside(node, inner); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#105
  def check_inside(node, left_brace, right_brace); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#137
  def check_left_brace(inner, left_brace, args_delimiter); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#145
  def check_right_brace(node, inner, left_brace, right_brace, single_line); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#165
  def inner_last_space_count(inner); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#157
  def multiline_block?(left_brace, right_brace); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#222
  def no_space(begin_pos, end_pos, msg); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#169
  def no_space_inside_left_brace(left_brace, args_delimiter); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#238
  def offense(begin_pos, end_pos, msg, style_param = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#201
  def pipe?(args_delimiter); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#230
  def space(begin_pos, end_pos, msg); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#186
  def space_inside_left_brace(left_brace, args_delimiter); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#205
  def space_inside_right_brace(inner, right_brace, column); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#251
  def style_for_empty_braces; end
end

# Checks that braces used for hash literals have or don't have
# surrounding space depending on configuration.
#
# @example EnforcedStyle: space (default)
#   # The `space` style enforces that hash literals have
#   # surrounding space.
#
#   # bad
#   h = {a: 1, b: 2}
#
#   # good
#   h = { a: 1, b: 2 }
# @example EnforcedStyle: no_space
#   # The `no_space` style enforces that hash literals have
#   # no surrounding space.
#
#   # bad
#   h = { a: 1, b: 2 }
#
#   # good
#   h = {a: 1, b: 2}
# @example EnforcedStyle: compact
#   # The `compact` style normally requires a space inside
#   # hash braces, with the exception that successive left
#   # braces or right braces are collapsed together in nested hashes.
#
#   # bad
#   h = { a: { b: 2 } }
#   foo = { { a: 1 } => { b: { c: 2 } } }
#
#   # good
#   h = { a: { b: 2 }}
#   foo = {{ a: 1 } => { b: { c: 2 }}}
# @example EnforcedStyleForEmptyBraces: no_space (default)
#   # The `no_space` EnforcedStyleForEmptyBraces style enforces that
#   # empty hash braces do not contain spaces.
#
#   # bad
#   foo = { }
#   bar = {    }
#   baz = {
#   }
#
#   # good
#   foo = {}
#   bar = {}
#   baz = {}
# @example EnforcedStyleForEmptyBraces: space
#   # The `space` EnforcedStyleForEmptyBraces style enforces that
#   # empty hash braces contain space.
#
#   # bad
#   foo = {}
#
#   # good
#   foo = { }
#   foo = {    }
#   foo = {
#   }
#
# source://rubocop//lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#70
class RuboCop::Cop::Layout::SpaceInsideHashLiteralBraces < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#78
  def on_hash(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#137
  def ambiguous_or_unexpected_style_detected(style, is_match); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#129
  def autocorrect(corrector, range); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#89
  def check(token1, token2); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#184
  def check_whitespace_only_hash(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#202
  def enforce_no_space_style_for_empty_braces?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#104
  def expect_space?(token1, token2); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#117
  def incorrect_style_detected(token1, token2, expect_space, is_empty_braces); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#150
  def message(brace, is_empty_braces, expect_space); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#145
  def offense?(token1, expect_space); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#196
  def range_inside_hash(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#176
  def range_of_space_to_the_left(range); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#168
  def range_of_space_to_the_right(range); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#160
  def space_range(token_range); end
end

# source://rubocop//lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#76
RuboCop::Cop::Layout::SpaceInsideHashLiteralBraces::MSG = T.let(T.unsafe(nil), String)

# Checks for spaces inside ordinary round parentheses.
#
# @example EnforcedStyle: no_space (default)
#   # The `no_space` style enforces that parentheses do not have spaces.
#
#   # bad
#   f( 3)
#   g = (a + 3 )
#   f( )
#
#   # good
#   f(3)
#   g = (a + 3)
#   f()
# @example EnforcedStyle: space
#   # The `space` style enforces that parentheses have a space at the
#   # beginning and end.
#   # Note: Empty parentheses should not have spaces.
#
#   # bad
#   f(3)
#   g = (a + 3)
#   y( )
#
#   # good
#   f( 3 )
#   g = ( a + 3 )
#   y()
# @example EnforcedStyle: compact
#   # The `compact` style enforces that parentheses have a space at the
#   # beginning with the exception that successive parentheses are allowed.
#   # Note: Empty parentheses should not have spaces.
#
#   # bad
#   f(3)
#   g = (a + 3)
#   y( )
#   g( f( x ) )
#   g( f( x( 3 ) ), 5 )
#   g( ( ( 3 + 5 ) * f) ** x, 5 )
#
#   # good
#   f( 3 )
#   g = ( a + 3 )
#   y()
#   g( f( x ))
#   g( f( x( 3 )), 5 )
#   g((( 3 + 5 ) * f ) ** x, 5 )
#
# source://rubocop//lib/rubocop/cop/layout/space_inside_parens.rb#57
class RuboCop::Cop::Layout::SpaceInsideParens < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/space_inside_parens.rb#66
  def on_new_investigation; end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_inside_parens.rb#161
  def can_be_ignored?(token1, token2); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_parens.rb#99
  def correct_extraneous_space(tokens); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_parens.rb#115
  def correct_extraneous_space_between_consecutive_parens(token1, token2); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_parens.rb#124
  def correct_extraneous_space_in_empty_parens(token1, token2); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_parens.rb#135
  def correct_missing_space(token1, token2); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_inside_parens.rb#153
  def left_parens?(token1, token2); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_inside_parens.rb#149
  def parens?(token1, token2); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_parens.rb#88
  def process_with_compact_style(tokens); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_parens.rb#81
  def process_with_space_style(tokens); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/space_inside_parens.rb#157
  def right_parens?(token1, token2); end
end

# source://rubocop//lib/rubocop/cop/layout/space_inside_parens.rb#63
RuboCop::Cop::Layout::SpaceInsideParens::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/space_inside_parens.rb#64
RuboCop::Cop::Layout::SpaceInsideParens::MSG_SPACE = T.let(T.unsafe(nil), String)

# Checks for unnecessary additional spaces inside the delimiters of
# %i/%w/%x literals.
#
# @example
#
#   # bad
#   %i( foo bar baz )
#
#   # good
#   %i(foo bar baz)
#
#   # bad
#   %w( foo bar baz )
#
#   # good
#   %w(foo bar baz)
#
#   # bad
#   %x(  ls -l )
#
#   # good
#   %x(ls -l)
#
#   # bad
#   %w( )
#   %w(
#   )
#
#   # good
#   %w()
#
# source://rubocop//lib/rubocop/cop/layout/space_inside_percent_literal_delimiters.rb#36
class RuboCop::Cop::Layout::SpaceInsidePercentLiteralDelimiters < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::MatchRange
  include ::RuboCop::Cop::PercentLiteral
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/space_inside_percent_literal_delimiters.rb#45
  def on_array(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_percent_literal_delimiters.rb#53
  def on_percent_literal(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_percent_literal_delimiters.rb#49
  def on_xstr(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/space_inside_percent_literal_delimiters.rb#60
  def add_offenses_for_blank_spaces(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_percent_literal_delimiters.rb#69
  def add_offenses_for_unnecessary_spaces(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_percent_literal_delimiters.rb#85
  def body_range(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_percent_literal_delimiters.rb#79
  def regex_matches(node, &blk); end
end

# source://rubocop//lib/rubocop/cop/layout/space_inside_percent_literal_delimiters.rb#42
RuboCop::Cop::Layout::SpaceInsidePercentLiteralDelimiters::BEGIN_REGEX = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/layout/space_inside_percent_literal_delimiters.rb#43
RuboCop::Cop::Layout::SpaceInsidePercentLiteralDelimiters::END_REGEX = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/layout/space_inside_percent_literal_delimiters.rb#41
RuboCop::Cop::Layout::SpaceInsidePercentLiteralDelimiters::MSG = T.let(T.unsafe(nil), String)

# Checks for spaces inside range literals.
#
# @example
#   # bad
#   1 .. 3
#
#   # good
#   1..3
#
#   # bad
#   'a' .. 'z'
#
#   # good
#   'a'..'z'
#
# source://rubocop//lib/rubocop/cop/layout/space_inside_range_literal.rb#20
class RuboCop::Cop::Layout::SpaceInsideRangeLiteral < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/space_inside_range_literal.rb#29
  def on_erange(node); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_range_literal.rb#25
  def on_irange(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/space_inside_range_literal.rb#35
  def check(node); end
end

# source://rubocop//lib/rubocop/cop/layout/space_inside_range_literal.rb#23
RuboCop::Cop::Layout::SpaceInsideRangeLiteral::MSG = T.let(T.unsafe(nil), String)

# Checks that reference brackets have or don't have
# surrounding space depending on configuration.
#
# @example EnforcedStyle: no_space (default)
#   # The `no_space` style enforces that reference brackets have
#   # no surrounding space.
#
#   # bad
#   hash[ :key ]
#   array[ index ]
#
#   # good
#   hash[:key]
#   array[index]
# @example EnforcedStyle: space
#   # The `space` style enforces that reference brackets have
#   # surrounding space.
#
#   # bad
#   hash[:key]
#   array[index]
#
#   # good
#   hash[ :key ]
#   array[ index ]
# @example EnforcedStyleForEmptyBrackets: no_space (default)
#   # The `no_space` EnforcedStyleForEmptyBrackets style enforces that
#   # empty reference brackets do not contain spaces.
#
#   # bad
#   foo[ ]
#   foo[     ]
#   foo[
#   ]
#
#   # good
#   foo[]
# @example EnforcedStyleForEmptyBrackets: space
#   # The `space` EnforcedStyleForEmptyBrackets style enforces that
#   # empty reference brackets contain exactly one space.
#
#   # bad
#   foo[]
#   foo[    ]
#   foo[
#   ]
#
#   # good
#   foo[ ]
#
# source://rubocop//lib/rubocop/cop/layout/space_inside_reference_brackets.rb#60
class RuboCop::Cop::Layout::SpaceInsideReferenceBrackets < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/space_inside_reference_brackets.rb#70
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/space_inside_reference_brackets.rb#92
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_reference_brackets.rb#121
  def closing_bracket(tokens, opening_bracket); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_reference_brackets.rb#137
  def empty_config; end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_reference_brackets.rb#110
  def left_ref_bracket(node, tokens); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_reference_brackets.rb#132
  def previous_token(current_token); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_reference_brackets.rb#104
  def reference_brackets(node); end
end

# source://rubocop//lib/rubocop/cop/layout/space_inside_reference_brackets.rb#66
RuboCop::Cop::Layout::SpaceInsideReferenceBrackets::EMPTY_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/space_inside_reference_brackets.rb#65
RuboCop::Cop::Layout::SpaceInsideReferenceBrackets::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/space_inside_reference_brackets.rb#68
RuboCop::Cop::Layout::SpaceInsideReferenceBrackets::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for whitespace within string interpolations.
#
# @example EnforcedStyle: no_space (default)
#   # bad
#   var = "This is the #{ space } example"
#
#   # good
#   var = "This is the #{no_space} example"
# @example EnforcedStyle: space
#   # bad
#   var = "This is the #{no_space} example"
#
#   # good
#   var = "This is the #{ space } example"
#
# source://rubocop//lib/rubocop/cop/layout/space_inside_string_interpolation.rb#21
class RuboCop::Cop::Layout::SpaceInsideStringInterpolation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Interpolation
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/space_inside_string_interpolation.rb#31
  def on_interpolation(begin_node); end

  private

  # source://rubocop//lib/rubocop/cop/layout/space_inside_string_interpolation.rb#47
  def autocorrect(corrector, begin_node); end

  # source://rubocop//lib/rubocop/cop/layout/space_inside_string_interpolation.rb#57
  def delimiters(begin_node); end
end

# source://rubocop//lib/rubocop/cop/layout/space_inside_string_interpolation.rb#28
RuboCop::Cop::Layout::SpaceInsideStringInterpolation::NO_SPACE_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/layout/space_inside_string_interpolation.rb#29
RuboCop::Cop::Layout::SpaceInsideStringInterpolation::SPACE_MSG = T.let(T.unsafe(nil), String)

# Looks for trailing blank lines and a final newline in the
# source code.
#
# @example EnforcedStyle: final_newline (default)
#   # `final_newline` looks for one newline at the end of files.
#
#   # bad
#   class Foo; end
#
#   # EOF
#
#   # bad
#   class Foo; end # EOF
#
#   # good
#   class Foo; end
#   # EOF
# @example EnforcedStyle: final_blank_line
#   # `final_blank_line` looks for one blank line followed by a new line
#   # at the end of files.
#
#   # bad
#   class Foo; end
#   # EOF
#
#   # bad
#   class Foo; end # EOF
#
#   # good
#   class Foo; end
#
#   # EOF
#
# source://rubocop//lib/rubocop/cop/layout/trailing_empty_lines.rb#40
class RuboCop::Cop::Layout::TrailingEmptyLines < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/trailing_empty_lines.rb#45
  def on_new_investigation; end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/trailing_empty_lines.rb#79
  def ends_in_end?(processed_source); end

  # source://rubocop//lib/rubocop/cop/layout/trailing_empty_lines.rb#89
  def message(wanted_blank_lines, blank_lines); end

  # source://rubocop//lib/rubocop/cop/layout/trailing_empty_lines.rb#66
  def offense_detected(buffer, wanted_blank_lines, blank_lines, whitespace_at_end); end
end

# Looks for trailing whitespace in the source code.
#
# @example
#   # The line in this example contains spaces after the 0.
#   # bad
#   x = 0
#
#   # The line in this example ends directly after the 0.
#   # good
#   x = 0
# @example AllowInHeredoc: false (default)
#   # The line in this example contains spaces after the 0.
#   # bad
#   code = <<~RUBY
#   x = 0
#   RUBY
#
#   # ok
#   code = <<~RUBY
#   x = 0 #{}
#   RUBY
#
#   # good
#   trailing_whitespace = ' '
#   code = <<~RUBY
#   x = 0#{trailing_whitespace}
#   RUBY
# @example AllowInHeredoc: true
#   # The line in this example contains spaces after the 0.
#   # good
#   code = <<~RUBY
#   x = 0
#   RUBY
#
# source://rubocop//lib/rubocop/cop/layout/trailing_whitespace.rb#42
class RuboCop::Cop::Layout::TrailingWhitespace < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::Heredoc
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/layout/trailing_whitespace.rb#57
  def on_heredoc(_node); end

  # source://rubocop//lib/rubocop/cop/layout/trailing_whitespace.rb#49
  def on_new_investigation; end

  private

  # source://rubocop//lib/rubocop/cop/layout/trailing_whitespace.rb#112
  def extract_heredocs(ast); end

  # source://rubocop//lib/rubocop/cop/layout/trailing_whitespace.rb#103
  def find_heredoc(line_number); end

  # source://rubocop//lib/rubocop/cop/layout/trailing_whitespace.rb#108
  def heredocs; end

  # source://rubocop//lib/rubocop/cop/layout/trailing_whitespace.rb#125
  def offense_range(lineno, line); end

  # source://rubocop//lib/rubocop/cop/layout/trailing_whitespace.rb#61
  def process_line(line, lineno); end

  # source://rubocop//lib/rubocop/cop/layout/trailing_whitespace.rb#75
  def process_line_in_heredoc(corrector, range, heredoc); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/trailing_whitespace.rb#99
  def skip_heredoc?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/trailing_whitespace.rb#95
  def static?(heredoc); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/trailing_whitespace.rb#86
  def whitespace_is_indentation?(range, level); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/layout/trailing_whitespace.rb#90
  def whitespace_only?(range); end
end

# source://rubocop//lib/rubocop/cop/layout/trailing_whitespace.rb#47
RuboCop::Cop::Layout::TrailingWhitespace::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/legacy/corrections_proxy.rb#5
module RuboCop::Cop::Legacy; end

# Legacy support for Corrector#corrections
# See https://docs.rubocop.org/rubocop/v1_upgrade_notes.html
#
# source://rubocop//lib/rubocop/cop/legacy/corrections_proxy.rb#8
class RuboCop::Cop::Legacy::CorrectionsProxy
  # @return [CorrectionsProxy] a new instance of CorrectionsProxy
  #
  # source://rubocop//lib/rubocop/cop/legacy/corrections_proxy.rb#9
  def initialize(corrector); end

  # source://rubocop//lib/rubocop/cop/legacy/corrections_proxy.rb#13
  def <<(callable); end

  # source://rubocop//lib/rubocop/cop/legacy/corrections_proxy.rb#21
  def concat(corrections); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/legacy/corrections_proxy.rb#17
  def empty?; end

  protected

  # Returns the value of attribute corrector.
  #
  # source://rubocop//lib/rubocop/cop/legacy/corrections_proxy.rb#31
  def corrector; end

  private

  # source://rubocop//lib/rubocop/cop/legacy/corrections_proxy.rb#35
  def suppress_clobbering; end
end

# This class handles autocorrection for code that needs to be moved
# to new lines.
#
# source://rubocop//lib/rubocop/cop/correctors/line_break_corrector.rb#7
class RuboCop::Cop::LineBreakCorrector
  extend ::RuboCop::Cop::Alignment
  extend ::RuboCop::Cop::TrailingBody
  extend ::RuboCop::PathUtil
  extend ::RuboCop::Cop::Util

  class << self
    # source://rubocop//lib/rubocop/cop/correctors/line_break_corrector.rb#27
    def break_line_before(range:, node:, corrector:, configured_width:, indent_steps: T.unsafe(nil)); end

    # source://rubocop//lib/rubocop/cop/correctors/line_break_corrector.rb#15
    def correct_trailing_body(configured_width:, corrector:, node:, processed_source:); end

    # source://rubocop//lib/rubocop/cop/correctors/line_break_corrector.rb#35
    def move_comment(eol_comment:, node:, corrector:); end

    # Returns the value of attribute processed_source.
    #
    # source://rubocop//lib/rubocop/cop/correctors/line_break_corrector.rb#13
    def processed_source; end

    private

    # source://rubocop//lib/rubocop/cop/correctors/line_break_corrector.rb#45
    def remove_semicolon(node, corrector); end

    # source://rubocop//lib/rubocop/cop/correctors/line_break_corrector.rb#51
    def semicolon(node); end

    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/cop/correctors/line_break_corrector.rb#58
    def trailing_class_definition?(token, body); end
  end
end

# Help methods for determining if a line is too long.
#
# source://rubocop//lib/rubocop/cop/mixin/line_length_help.rb#6
module RuboCop::Cop::LineLengthHelp
  include ::RuboCop::Cop::Alignment

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/line_length_help.rb#24
  def allow_uri?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/line_length_help.rb#28
  def allowed_uri_position?(line, uri_range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/line_length_help.rb#15
  def directive_on_source_line?(line_index); end

  # source://rubocop//lib/rubocop/cop/mixin/line_length_help.rb#72
  def extend_uri_end_position(line, end_position); end

  # source://rubocop//lib/rubocop/cop/mixin/line_length_help.rb#36
  def find_excessive_uri_range(line); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/line_length_help.rb#11
  def ignore_cop_directives?; end

  # source://rubocop//lib/rubocop/cop/mixin/line_length_help.rb#59
  def indentation_difference(line); end

  # source://rubocop//lib/rubocop/cop/mixin/line_length_help.rb#32
  def line_length(line); end

  # source://rubocop//lib/rubocop/cop/mixin/line_length_help.rb#105
  def line_length_without_directive(line); end

  # source://rubocop//lib/rubocop/cop/mixin/line_length_help.rb#51
  def match_uris(string); end

  # source://rubocop//lib/rubocop/cop/mixin/line_length_help.rb#88
  def tab_indentation_width; end

  # source://rubocop//lib/rubocop/cop/mixin/line_length_help.rb#93
  def uri_regexp; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/line_length_help.rb#98
  def valid_uri?(uri_ish_string); end
end

# source://rubocop//lib/rubocop/cop/mixin/unused_argument.rb#5
module RuboCop::Cop::Lint; end

# Checks for mistyped shorthand assignments.
#
# @example
#   # bad
#   x =- y
#   x =+ y
#   x =* y
#   x =! y
#
#   # good
#   x -= y # or x = -y
#   x += y # or x = +y
#   x *= y # or x = *y
#   x != y # or x = !y
#
# source://rubocop//lib/rubocop/cop/lint/ambiguous_assignment.rb#21
class RuboCop::Cop::Lint::AmbiguousAssignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/lint/ambiguous_assignment.rb#30
  def on_asgn(node); end

  # source://rubocop//lib/rubocop/cop/lint/ambiguous_assignment.rb#30
  def on_casgn(node); end

  # source://rubocop//lib/rubocop/cop/lint/ambiguous_assignment.rb#30
  def on_cvasgn(node); end

  # source://rubocop//lib/rubocop/cop/lint/ambiguous_assignment.rb#30
  def on_gvasgn(node); end

  # source://rubocop//lib/rubocop/cop/lint/ambiguous_assignment.rb#30
  def on_ivasgn(node); end

  # source://rubocop//lib/rubocop/cop/lint/ambiguous_assignment.rb#30
  def on_lvasgn(node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/ambiguous_assignment.rb#44
  def rhs(node); end
end

# source://rubocop//lib/rubocop/cop/lint/ambiguous_assignment.rb#28
RuboCop::Cop::Lint::AmbiguousAssignment::MISTAKES = T.let(T.unsafe(nil), Hash)

# source://rubocop//lib/rubocop/cop/lint/ambiguous_assignment.rb#24
RuboCop::Cop::Lint::AmbiguousAssignment::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/ambiguous_assignment.rb#26
RuboCop::Cop::Lint::AmbiguousAssignment::SIMPLE_ASSIGNMENT_TYPES = T.let(T.unsafe(nil), Array)

# Checks for ambiguous block association with method
# when param passed without parentheses.
#
# This cop can customize allowed methods with `AllowedMethods`.
# By default, there are no methods to allowed.
#
# @example
#
#   # bad
#   some_method a { |val| puts val }
# @example
#
#   # good
#   # With parentheses, there's no ambiguity.
#   some_method(a { |val| puts val })
#   # or (different meaning)
#   some_method(a) { |val| puts val }
#
#   # good
#   # Operator methods require no disambiguation
#   foo == bar { |b| b.baz }
#
#   # good
#   # Lambda arguments require no disambiguation
#   foo = ->(bar) { bar.baz }
# @example AllowedMethods: [] (default)
#
#   # bad
#   expect { do_something }.to change { object.attribute }
# @example AllowedMethods: [change]
#
#   # good
#   expect { do_something }.to change { object.attribute }
# @example AllowedPatterns: [] (default)
#
#   # bad
#   expect { do_something }.to change { object.attribute }
# @example AllowedPatterns: ['change']
#
#   # good
#   expect { do_something }.to change { object.attribute }
#   expect { do_something }.to not_change { object.attribute }
#
# source://rubocop//lib/rubocop/cop/lint/ambiguous_block_association.rb#54
class RuboCop::Cop::Lint::AmbiguousBlockAssociation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::AllowedPattern

  # source://rubocop//lib/rubocop/cop/lint/ambiguous_block_association.rb#62
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/lint/ambiguous_block_association.rb#62
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/ambiguous_block_association.rb#81
  def allowed_method_pattern?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/ambiguous_block_association.rb#77
  def ambiguous_block_association?(send_node); end

  # source://rubocop//lib/rubocop/cop/lint/ambiguous_block_association.rb#87
  def message(send_node); end
end

# source://rubocop//lib/rubocop/cop/lint/ambiguous_block_association.rb#58
RuboCop::Cop::Lint::AmbiguousBlockAssociation::MSG = T.let(T.unsafe(nil), String)

# Checks for ambiguous operators in the first argument of a
# method invocation without parentheses.
#
# @example
#
#   # bad
#
#   # The `*` is interpreted as a splat operator but it could possibly be
#   # a `*` method invocation (i.e. `do_something.*(some_array)`).
#   do_something *some_array
# @example
#
#   # good
#
#   # With parentheses, there's no ambiguity.
#   do_something(*some_array)
#
# source://rubocop//lib/rubocop/cop/lint/ambiguous_operator.rb#23
class RuboCop::Cop::Lint::AmbiguousOperator < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/ambiguous_operator.rb#45
  def on_new_investigation; end

  private

  # source://rubocop//lib/rubocop/cop/lint/ambiguous_operator.rb#64
  def find_offense_node_by(diagnostic); end

  # source://rubocop//lib/rubocop/cop/lint/ambiguous_operator.rb#82
  def message(diagnostic); end

  # source://rubocop//lib/rubocop/cop/lint/ambiguous_operator.rb#92
  def offense_node(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/ambiguous_operator.rb#88
  def offense_position?(node, diagnostic); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/ambiguous_operator.rb#101
  def unary_operator?(node, diagnostic); end

  class << self
    # source://rubocop//lib/rubocop/cop/lint/ambiguous_operator.rb#41
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop//lib/rubocop/cop/lint/ambiguous_operator.rb#26
RuboCop::Cop::Lint::AmbiguousOperator::AMBIGUITIES = T.let(T.unsafe(nil), Hash)

# source://rubocop//lib/rubocop/cop/lint/ambiguous_operator.rb#36
RuboCop::Cop::Lint::AmbiguousOperator::MSG_FORMAT = T.let(T.unsafe(nil), String)

# Looks for expressions containing multiple binary operators
# where precedence is ambiguous due to lack of parentheses. For example,
# in `1 + 2 * 3`, the multiplication will happen before the addition, but
# lexically it appears that the addition will happen first.
#
# The cop does not consider unary operators (ie. `!a` or `-b`) or comparison
# operators (ie. `a =~ b`) because those are not ambiguous.
#
# NOTE: Ranges are handled by `Lint/AmbiguousRange`.
#
# @example
#   # bad
#   a + b * c
#   a || b && c
#   a ** b + c
#
#   # good (different precedence)
#   a + (b * c)
#   a || (b && c)
#   (a ** b) + c
#
#   # good (same precedence)
#   a + b + c
#   a * b / c % d
#
# source://rubocop//lib/rubocop/cop/lint/ambiguous_operator_precedence.rb#30
class RuboCop::Cop::Lint::AmbiguousOperatorPrecedence < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/ambiguous_operator_precedence.rb#54
  def on_and(node); end

  # source://rubocop//lib/rubocop/cop/lint/ambiguous_operator_precedence.rb#47
  def on_new_investigation; end

  # source://rubocop//lib/rubocop/cop/lint/ambiguous_operator_precedence.rb#65
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/ambiguous_operator_precedence.rb#105
  def autocorrect(corrector, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/ambiguous_operator_precedence.rb#89
  def greater_precedence?(node1, node2); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/ambiguous_operator_precedence.rb#85
  def operator?(node); end

  # source://rubocop//lib/rubocop/cop/lint/ambiguous_operator_precedence.rb#97
  def operator_name(node); end

  # source://rubocop//lib/rubocop/cop/lint/ambiguous_operator_precedence.rb#79
  def precedence(node); end
end

# source://rubocop//lib/rubocop/cop/lint/ambiguous_operator_precedence.rb#45
RuboCop::Cop::Lint::AmbiguousOperatorPrecedence::MSG = T.let(T.unsafe(nil), String)

# See https://ruby-doc.org/core-3.0.2/doc/syntax/precedence_rdoc.html
#
# source://rubocop//lib/rubocop/cop/lint/ambiguous_operator_precedence.rb#34
RuboCop::Cop::Lint::AmbiguousOperatorPrecedence::PRECEDENCE = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/ambiguous_operator_precedence.rb#44
RuboCop::Cop::Lint::AmbiguousOperatorPrecedence::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for ambiguous ranges.
#
# Ranges have quite low precedence, which leads to unexpected behavior when
# using a range with other operators. This cop avoids that by making ranges
# explicit by requiring parenthesis around complex range boundaries (anything
# that is not a literal: numerics, strings, symbols, etc.).
#
# This cop can be configured with `RequireParenthesesForMethodChains` in order to
# specify whether method chains (including `self.foo`) should be wrapped in parens
# by this cop.
#
# NOTE: Regardless of this configuration, if a method receiver is a basic literal
# value, it will be wrapped in order to prevent the ambiguity of `1..2.to_a`.
#
# @example
#   # bad
#   x || 1..2
#   (x || 1..2)
#   1..2.to_a
#
#   # good, unambiguous
#   1..2
#   'a'..'z'
#   :bar..:baz
#   MyClass::MIN..MyClass::MAX
#   @min..@max
#   a..b
#   -a..b
#
#   # good, ambiguity removed
#   x || (1..2)
#   (x || 1)..2
#   (x || 1)..(y || 2)
#   (1..2).to_a
# @example RequireParenthesesForMethodChains: false (default)
#   # good
#   a.foo..b.bar
#   (a.foo)..(b.bar)
# @example RequireParenthesesForMethodChains: true
#   # bad
#   a.foo..b.bar
#
#   # good
#   (a.foo)..(b.bar)
#
# source://rubocop//lib/rubocop/cop/lint/ambiguous_range.rb#59
class RuboCop::Cop::Lint::AmbiguousRange < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/ambiguous_range.rb#64
  def on_erange(node); end

  # source://rubocop//lib/rubocop/cop/lint/ambiguous_range.rb#64
  def on_irange(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/ambiguous_range.rb#82
  def acceptable?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/ambiguous_range.rb#89
  def acceptable_call?(node); end

  # @yield [range.begin]
  #
  # source://rubocop//lib/rubocop/cop/lint/ambiguous_range.rb#77
  def each_boundary(range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/ambiguous_range.rb#99
  def require_parentheses_for_method_chain?; end
end

# source://rubocop//lib/rubocop/cop/lint/ambiguous_range.rb#62
RuboCop::Cop::Lint::AmbiguousRange::MSG = T.let(T.unsafe(nil), String)

# Checks for ambiguous regexp literals in the first argument of
# a method invocation without parentheses.
#
# @example
#
#   # bad
#
#   # This is interpreted as a method invocation with a regexp literal,
#   # but it could possibly be `/` method invocations.
#   # (i.e. `do_something./(pattern)./(i)`)
#   do_something /pattern/i
# @example
#
#   # good
#
#   # With parentheses, there's no ambiguity.
#   do_something(/pattern/i)
#
# source://rubocop//lib/rubocop/cop/lint/ambiguous_regexp_literal.rb#24
class RuboCop::Cop::Lint::AmbiguousRegexpLiteral < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/ambiguous_regexp_literal.rb#31
  def on_new_investigation; end

  private

  # source://rubocop//lib/rubocop/cop/lint/ambiguous_regexp_literal.rb#56
  def find_offense_node(node, regexp_receiver); end

  # source://rubocop//lib/rubocop/cop/lint/ambiguous_regexp_literal.rb#49
  def find_offense_node_by(diagnostic); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/ambiguous_regexp_literal.rb#67
  def first_argument_is_regexp?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/ambiguous_regexp_literal.rb#71
  def method_chain_to_regexp_receiver?(node, regexp_receiver); end
end

# source://rubocop//lib/rubocop/cop/lint/ambiguous_regexp_literal.rb#27
RuboCop::Cop::Lint::AmbiguousRegexpLiteral::MSG = T.let(T.unsafe(nil), String)

# Checks for assignments in the conditions of
# if/while/until.
#
# `AllowSafeAssignment` option for safe assignment.
# By safe assignment we mean putting parentheses around
# an assignment to indicate "I know I'm using an assignment
# as a condition. It's not a mistake."
#
# @example
#   # bad
#   if some_var = true
#   do_something
#   end
#
#   # good
#   if some_var == true
#   do_something
#   end
# @example AllowSafeAssignment: true (default)
#   # good
#   if (some_var = true)
#   do_something
#   end
# @example AllowSafeAssignment: false
#   # bad
#   if (some_var = true)
#   do_something
#   end
#
# source://rubocop//lib/rubocop/cop/lint/assignment_in_condition.rb#41
class RuboCop::Cop::Lint::AssignmentInCondition < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::SafeAssignment
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/assignment_in_condition.rb#55
  def on_if(node); end

  # source://rubocop//lib/rubocop/cop/lint/assignment_in_condition.rb#55
  def on_until(node); end

  # source://rubocop//lib/rubocop/cop/lint/assignment_in_condition.rb#55
  def on_while(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/assignment_in_condition.rb#82
  def allowed_construct?(asgn_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/assignment_in_condition.rb#86
  def conditional_assignment?(asgn_node); end

  # source://rubocop//lib/rubocop/cop/lint/assignment_in_condition.rb#74
  def message(_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/assignment_in_condition.rb#90
  def skip_children?(asgn_node); end

  # source://rubocop//lib/rubocop/cop/lint/assignment_in_condition.rb#96
  def traverse_node(node, &block); end
end

# source://rubocop//lib/rubocop/cop/lint/assignment_in_condition.rb#53
RuboCop::Cop::Lint::AssignmentInCondition::ASGN_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/assignment_in_condition.rb#50
RuboCop::Cop::Lint::AssignmentInCondition::MSG_WITHOUT_SAFE_ASSIGNMENT_ALLOWED = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/assignment_in_condition.rb#46
RuboCop::Cop::Lint::AssignmentInCondition::MSG_WITH_SAFE_ASSIGNMENT_ALLOWED = T.let(T.unsafe(nil), String)

# `BigDecimal.new()` is deprecated since BigDecimal 1.3.3.
# This cop identifies places where `BigDecimal.new()`
# can be replaced by `BigDecimal()`.
#
# @example
#   # bad
#   BigDecimal.new(123.456, 3)
#
#   # good
#   BigDecimal(123.456, 3)
#
# source://rubocop//lib/rubocop/cop/lint/big_decimal_new.rb#17
class RuboCop::Cop::Lint::BigDecimalNew < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/big_decimal_new.rb#25
  def big_decimal_new(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/big_decimal_new.rb#30
  def on_send(node); end
end

# source://rubocop//lib/rubocop/cop/lint/big_decimal_new.rb#20
RuboCop::Cop::Lint::BigDecimalNew::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/big_decimal_new.rb#22
RuboCop::Cop::Lint::BigDecimalNew::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for places where binary operator has identical operands.
#
# It covers arithmetic operators: `-`, `/`, `%`;
# comparison operators: `==`, `===`, `=~`, `>`, `>=`, `<`, `<=`;
# bitwise operators: `|`, `^`, `&`;
# boolean operators: `&&`, `||`
# and "spaceship" operator - `<=>`.
#
# Simple arithmetic operations are allowed by this cop: `+`, `*`, `**`, `<<` and `>>`.
# Although these can be rewritten in a different way, it should not be necessary to
# do so. This does not include operations such as `-` or `/` where the result will
# always be the same (`x - x` will always be 0; `x / x` will always be 1), and
# thus are legitimate offenses.
#
# @example
#   # bad
#   x / x
#   x.top >= x.top
#
#   if a.x != 0 && a.x != 0
#   do_something
#   end
#
#   def child?
#   left_child || left_child
#   end
#
#   # good
#   x + x
#   1 << 1
#
# source://rubocop//lib/rubocop/cop/lint/binary_operator_with_identical_operands.rb#48
class RuboCop::Cop::Lint::BinaryOperatorWithIdenticalOperands < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/lint/binary_operator_with_identical_operands.rb#61
  def on_and(node); end

  # source://rubocop//lib/rubocop/cop/lint/binary_operator_with_identical_operands.rb#61
  def on_or(node); end

  # source://rubocop//lib/rubocop/cop/lint/binary_operator_with_identical_operands.rb#52
  def on_send(node); end
end

# source://rubocop//lib/rubocop/cop/lint/binary_operator_with_identical_operands.rb#50
RuboCop::Cop::Lint::BinaryOperatorWithIdenticalOperands::ALLOWED_MATH_OPERATORS = T.let(T.unsafe(nil), Set)

# source://rubocop//lib/rubocop/cop/lint/binary_operator_with_identical_operands.rb#49
RuboCop::Cop::Lint::BinaryOperatorWithIdenticalOperands::MSG = T.let(T.unsafe(nil), String)

# Checks for `:true` and `:false` symbols.
# In most cases it would be a typo.
#
# @example
#
#   # bad
#   :true
#
#   # good
#   true
# @example
#
#   # bad
#   :false
#
#   # good
#   false
#
# source://rubocop//lib/rubocop/cop/lint/boolean_symbol.rb#29
class RuboCop::Cop::Lint::BooleanSymbol < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/boolean_symbol.rb#35
  def boolean_symbol?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/boolean_symbol.rb#37
  def on_sym(node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/boolean_symbol.rb#50
  def autocorrect(corrector, node); end
end

# source://rubocop//lib/rubocop/cop/lint/boolean_symbol.rb#32
RuboCop::Cop::Lint::BooleanSymbol::MSG = T.let(T.unsafe(nil), String)

# Checks for circular argument references in optional keyword
# arguments and optional ordinal arguments.
#
# This cop mirrors a warning produced by MRI since 2.2.
#
# @example
#
#   # bad
#
#   def bake(pie: pie)
#   pie.heat_up
#   end
# @example
#
#   # good
#
#   def bake(pie:)
#   pie.refrigerate
#   end
# @example
#
#   # good
#
#   def bake(pie: self.pie)
#   pie.feed_to(user)
#   end
# @example
#
#   # bad
#
#   def cook(dry_ingredients = dry_ingredients)
#   dry_ingredients.reduce(&:+)
#   end
# @example
#
#   # good
#
#   def cook(dry_ingredients = self.dry_ingredients)
#   dry_ingredients.combine
#   end
#
# source://rubocop//lib/rubocop/cop/lint/circular_argument_reference.rb#50
class RuboCop::Cop::Lint::CircularArgumentReference < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/lint/circular_argument_reference.rb#53
  def on_kwoptarg(node); end

  # source://rubocop//lib/rubocop/cop/lint/circular_argument_reference.rb#57
  def on_optarg(node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/circular_argument_reference.rb#63
  def check_for_circular_argument_references(arg_name, arg_value); end
end

# source://rubocop//lib/rubocop/cop/lint/circular_argument_reference.rb#51
RuboCop::Cop::Lint::CircularArgumentReference::MSG = T.let(T.unsafe(nil), String)

# Do not define constants within a block, since the block's scope does not
# isolate or namespace the constant in any way.
#
# If you are trying to define that constant once, define it outside of
# the block instead, or use a variable or method if defining the constant
# in the outer scope would be problematic.
#
# For meta-programming, use `const_set`.
#
# @example
#   # bad
#   task :lint do
#   FILES_TO_LINT = Dir['lib/*.rb']
#   end
#
#   # bad
#   describe 'making a request' do
#   class TestRequest; end
#   end
#
#   # bad
#   module M
#   extend ActiveSupport::Concern
#   included do
#   LIST = []
#   end
#   end
#
#   # good
#   task :lint do
#   files_to_lint = Dir['lib/*.rb']
#   end
#
#   # good
#   describe 'making a request' do
#   let(:test_request) { Class.new }
#   # see also `stub_const` for RSpec
#   end
#
#   # good
#   module M
#   extend ActiveSupport::Concern
#   included do
#   const_set(:LIST, [])
#   end
#   end
# @example AllowedMethods: ['enums'] (default)
#   # good
#
#   # `enums` for Typed Enums via `T::Enum` in Sorbet.
#   # https://sorbet.org/docs/tenum
#   class TestEnum < T::Enum
#   enums do
#   Foo = new("foo")
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/lint/constant_definition_in_block.rb#64
class RuboCop::Cop::Lint::ConstantDefinitionInBlock < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::AllowedMethods

  # source://rubocop//lib/rubocop/cop/lint/constant_definition_in_block.rb#70
  def constant_assigned_in_block?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/constant_definition_in_block.rb#75
  def module_defined_in_block?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/constant_definition_in_block.rb#79
  def on_casgn(node); end

  # source://rubocop//lib/rubocop/cop/lint/constant_definition_in_block.rb#85
  def on_class(node); end

  # source://rubocop//lib/rubocop/cop/lint/constant_definition_in_block.rb#85
  def on_module(node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/constant_definition_in_block.rb#94
  def method_name(node); end
end

# source://rubocop//lib/rubocop/cop/lint/constant_definition_in_block.rb#67
RuboCop::Cop::Lint::ConstantDefinitionInBlock::MSG = T.let(T.unsafe(nil), String)

# Checks for overwriting an exception with an exception result by use `rescue =>`.
#
# You intended to write as `rescue StandardError`.
# However, you have written `rescue => StandardError`.
# In that case, the result of `rescue` will overwrite `StandardError`.
#
# @example
#
#   # bad
#   begin
#   something
#   rescue => StandardError
#   end
#
#   # good
#   begin
#   something
#   rescue StandardError
#   end
#
# source://rubocop//lib/rubocop/cop/lint/constant_overwritten_in_rescue.rb#26
class RuboCop::Cop::Lint::ConstantOverwrittenInRescue < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/constant_overwritten_in_rescue.rb#41
  def on_resbody(node); end

  # source://rubocop//lib/rubocop/cop/lint/constant_overwritten_in_rescue.rb#33
  def overwritten_constant(param0 = T.unsafe(nil)); end

  class << self
    # source://rubocop//lib/rubocop/cop/lint/constant_overwritten_in_rescue.rb#37
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop//lib/rubocop/cop/lint/constant_overwritten_in_rescue.rb#30
RuboCop::Cop::Lint::ConstantOverwrittenInRescue::MSG = T.let(T.unsafe(nil), String)

# Check that certain constants are fully qualified.
#
# This is not enabled by default because it would mark a lot of offenses
# unnecessarily.
#
# Generally, gems should fully qualify all constants to avoid conflicts with
# the code that uses the gem. Enable this cop without using `Only`/`Ignore`
#
# Large projects will over time end up with one or two constant names that
# are problematic because of a conflict with a library or just internally
# using the same name a namespace and a class. To avoid too many unnecessary
# offenses, Enable this cop with `Only: [The, Constant, Names, Causing, Issues]`
#
# NOTE: `Style/RedundantConstantBase` cop is disabled if this cop is enabled to prevent
# conflicting rules. Because it respects user configurations that want to enable
# this cop which is disabled by default.
#
# @example
#   # By default checks every constant
#
#   # bad
#   User
#
#   # bad
#   User::Login
#
#   # good
#   ::User
#
#   # good
#   ::User::Login
# @example Only: ['Login']
#   # Restrict this cop to only being concerned about certain constants
#
#   # bad
#   Login
#
#   # good
#   ::Login
#
#   # good
#   User::Login
# @example Ignore: ['Login']
#   # Restrict this cop not being concerned about certain constants
#
#   # bad
#   User
#
#   # good
#   ::User::Login
#
#   # good
#   Login
#
# source://rubocop//lib/rubocop/cop/lint/constant_resolution.rb#62
class RuboCop::Cop::Lint::ConstantResolution < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/lint/constant_resolution.rb#70
  def on_const(node); end

  # source://rubocop//lib/rubocop/cop/lint/constant_resolution.rb#66
  def unqualified_const?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/lint/constant_resolution.rb#83
  def allowed_names; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/constant_resolution.rb#78
  def const_name?(name); end

  # source://rubocop//lib/rubocop/cop/lint/constant_resolution.rb#87
  def ignored_names; end
end

# source://rubocop//lib/rubocop/cop/lint/constant_resolution.rb#63
RuboCop::Cop::Lint::ConstantResolution::MSG = T.let(T.unsafe(nil), String)

# Checks for debug calls (such as `debugger` or `binding.pry`) that should
# not be kept for production code.
#
# The cop can be configured using `DebuggerMethods`. By default, a number of gems
# debug entrypoints are configured (`Kernel`, `Byebug`, `Capybara`, `debug.rb`,
# `Pry`, `Rails`, `RubyJard`, and `WebConsole`). Additional methods can be added.
#
# Specific default groups can be disabled if necessary:
#
# [source,yaml]
# ----
# Lint/Debugger:
#   DebuggerMethods:
#     WebConsole: ~
# ----
#
# You can also add your own methods by adding a new category:
#
# [source,yaml]
# ----
# Lint/Debugger:
#   DebuggerMethods:
#     MyDebugger:
#       MyDebugger.debug_this
# ----
#
# @example
#
#   # bad (ok during development)
#
#   # using pry
#   def some_method
#   binding.pry
#   do_something
#   end
# @example
#
#   # bad (ok during development)
#
#   # using byebug
#   def some_method
#   byebug
#   do_something
#   end
# @example
#
#   # good
#
#   def some_method
#   do_something
#   end
# @example DebuggerMethods: [my_debugger]
#
#   # bad (ok during development)
#
#   def some_method
#   my_debugger
#   end
#
# source://rubocop//lib/rubocop/cop/lint/debugger.rb#67
class RuboCop::Cop::Lint::Debugger < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/lint/debugger.rb#70
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/debugger.rb#98
  def chained_method_name(send_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/debugger.rb#92
  def debugger_method?(send_node); end

  # source://rubocop//lib/rubocop/cop/lint/debugger.rb#85
  def debugger_methods; end

  # source://rubocop//lib/rubocop/cop/lint/debugger.rb#81
  def message(node); end
end

# source://rubocop//lib/rubocop/cop/lint/debugger.rb#68
RuboCop::Cop::Lint::Debugger::MSG = T.let(T.unsafe(nil), String)

# Checks for uses of the deprecated class method usages.
#
# @example
#
#   # bad
#   File.exists?(some_path)
#   Dir.exists?(some_path)
#   iterator?
#   attr :name, true
#   attr :name, false
#   ENV.freeze # Calling `Env.freeze` raises `TypeError` since Ruby 2.7.
#   ENV.clone
#   ENV.dup # Calling `Env.dup` raises `TypeError` since Ruby 3.1.
#   Socket.gethostbyname(host)
#   Socket.gethostbyaddr(host)
#
#   # good
#   File.exist?(some_path)
#   Dir.exist?(some_path)
#   block_given?
#   attr_accessor :name
#   attr_reader :name
#   ENV # `ENV.freeze` cannot prohibit changes to environment variables.
#   ENV.to_h
#   ENV.to_h # `ENV.dup` cannot dup `ENV`, use `ENV.to_h` to get a copy of `ENV` as a hash.
#   Addrinfo.getaddrinfo(nodename, service)
#   Addrinfo.tcp(host, port).getnameinfo
#
# source://rubocop//lib/rubocop/cop/lint/deprecated_class_methods.rb#33
class RuboCop::Cop::Lint::DeprecatedClassMethods < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/deprecated_class_methods.rb#53
  def deprecated_class_method?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/deprecated_class_methods.rb#63
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/deprecated_class_methods.rb#112
  def dir_env_file_const?(node); end

  # source://rubocop//lib/rubocop/cop/lint/deprecated_class_methods.rb#83
  def offense_range(node); end

  # source://rubocop//lib/rubocop/cop/lint/deprecated_class_methods.rb#93
  def preferred_method(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/deprecated_class_methods.rb#108
  def socket_const?(node); end
end

# source://rubocop//lib/rubocop/cop/lint/deprecated_class_methods.rb#50
RuboCop::Cop::Lint::DeprecatedClassMethods::DIR_ENV_FILE_CONSTANTS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/deprecated_class_methods.rb#36
RuboCop::Cop::Lint::DeprecatedClassMethods::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/deprecated_class_methods.rb#41
RuboCop::Cop::Lint::DeprecatedClassMethods::PREFERRED_METHODS = T.let(T.unsafe(nil), Hash)

# source://rubocop//lib/rubocop/cop/lint/deprecated_class_methods.rb#37
RuboCop::Cop::Lint::DeprecatedClassMethods::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for deprecated constants.
#
# It has `DeprecatedConstants` config. If there is an alternative method, you can set
# alternative value as `Alternative`. And you can set the deprecated version as
# `DeprecatedVersion`. These options can be omitted if they are not needed.
#
#   DeprecatedConstants:
#     'DEPRECATED_CONSTANT':
#       Alternative: 'alternative_value'
#       DeprecatedVersion: 'deprecated_version'
#
# By default, `NIL`, `TRUE`, `FALSE`, `Net::HTTPServerException, `Random::DEFAULT`,
# `Struct::Group`, and `Struct::Passwd` are configured.
#
# @example
#
#   # bad
#   NIL
#   TRUE
#   FALSE
#   Net::HTTPServerException
#   Random::DEFAULT # Return value of Ruby 2 is `Random` instance, Ruby 3.0 is `Random` class.
#   Struct::Group
#   Struct::Passwd
#
#   # good
#   nil
#   true
#   false
#   Net::HTTPClientException
#   Random.new # `::DEFAULT` has been deprecated in Ruby 3, `.new` is compatible with Ruby 2.
#   Etc::Group
#   Etc::Passwd
#
# source://rubocop//lib/rubocop/cop/lint/deprecated_constants.rb#40
class RuboCop::Cop::Lint::DeprecatedConstants < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/deprecated_constants.rb#46
  def on_const(node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/deprecated_constants.rb#66
  def constant_name(node, nested_constant_name); end

  # source://rubocop//lib/rubocop/cop/lint/deprecated_constants.rb#82
  def deprecated_constants; end

  # source://rubocop//lib/rubocop/cop/lint/deprecated_constants.rb#72
  def message(good, bad, deprecated_version); end
end

# source://rubocop//lib/rubocop/cop/lint/deprecated_constants.rb#44
RuboCop::Cop::Lint::DeprecatedConstants::DO_NOT_USE_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/deprecated_constants.rb#43
RuboCop::Cop::Lint::DeprecatedConstants::SUGGEST_GOOD_MSG = T.let(T.unsafe(nil), String)

# Algorithmic constants for `OpenSSL::Cipher` and `OpenSSL::Digest`
# deprecated since OpenSSL version 2.2.0. Prefer passing a string
# instead.
#
# @example
#
#   # Example for OpenSSL::Cipher instantiation.
#
#   # bad
#   OpenSSL::Cipher::AES.new(128, :GCM)
#
#   # good
#   OpenSSL::Cipher.new('aes-128-gcm')
# @example
#
#   # Example for OpenSSL::Digest instantiation.
#
#   # bad
#   OpenSSL::Digest::SHA256.new
#
#   # good
#   OpenSSL::Digest.new('SHA256')
# @example
#
#   # Example for ::Digest inherited class methods.
#
#   # bad
#   OpenSSL::Digest::SHA256.digest('foo')
#
#   # good
#   OpenSSL::Digest.digest('SHA256', 'foo')
#
# source://rubocop//lib/rubocop/cop/lint/deprecated_open_ssl_constant.rb#40
class RuboCop::Cop::Lint::DeprecatedOpenSSLConstant < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/deprecated_open_ssl_constant.rb#49
  def algorithm_const(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/deprecated_open_ssl_constant.rb#59
  def digest_const?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/deprecated_open_ssl_constant.rb#63
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/deprecated_open_ssl_constant.rb#110
  def algorithm_name(node); end

  # source://rubocop//lib/rubocop/cop/lint/deprecated_open_ssl_constant.rb#75
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/lint/deprecated_open_ssl_constant.rb#139
  def build_cipher_arguments(node, algorithm_name, no_arguments); end

  # source://rubocop//lib/rubocop/cop/lint/deprecated_open_ssl_constant.rb#102
  def correction_range(node); end

  # source://rubocop//lib/rubocop/cop/lint/deprecated_open_ssl_constant.rb#87
  def message(node); end

  # source://rubocop//lib/rubocop/cop/lint/deprecated_open_ssl_constant.rb#106
  def openssl_class(node); end

  # source://rubocop//lib/rubocop/cop/lint/deprecated_open_ssl_constant.rb#128
  def replacement_args(node); end

  # source://rubocop//lib/rubocop/cop/lint/deprecated_open_ssl_constant.rb#120
  def sanitize_arguments(arguments); end
end

# source://rubocop//lib/rubocop/cop/lint/deprecated_open_ssl_constant.rb#44
RuboCop::Cop::Lint::DeprecatedOpenSSLConstant::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/deprecated_open_ssl_constant.rb#46
RuboCop::Cop::Lint::DeprecatedOpenSSLConstant::NO_ARG_ALGORITHM = T.let(T.unsafe(nil), Array)

# Checks constructors for disjunctive assignments (`||=`) that should
# be plain assignments.
#
# So far, this cop is only concerned with disjunctive assignment of
# instance variables.
#
# In ruby, an instance variable is nil until a value is assigned, so the
# disjunction is unnecessary. A plain assignment has the same effect.
#
# @example
#   # bad
#   def initialize
#   @x ||= 1
#   end
#
#   # good
#   def initialize
#   @x = 1
#   end
#
# source://rubocop//lib/rubocop/cop/lint/disjunctive_assignment_in_constructor.rb#48
class RuboCop::Cop::Lint::DisjunctiveAssignmentInConstructor < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/disjunctive_assignment_in_constructor.rb#53
  def on_def(node); end

  private

  # @param node [DefNode] a constructor definition
  #
  # source://rubocop//lib/rubocop/cop/lint/disjunctive_assignment_in_constructor.rb#60
  def check(node); end

  # source://rubocop//lib/rubocop/cop/lint/disjunctive_assignment_in_constructor.rb#66
  def check_body(body); end

  # @param lines [Array] the logical lines of the constructor
  #
  # source://rubocop//lib/rubocop/cop/lint/disjunctive_assignment_in_constructor.rb#78
  def check_body_lines(lines); end

  # Add an offense if the LHS of the given disjunctive assignment is
  # an instance variable.
  #
  # For now, we only care about assignments to instance variables.
  #
  # @param node [Node] a disjunctive assignment
  #
  # source://rubocop//lib/rubocop/cop/lint/disjunctive_assignment_in_constructor.rb#99
  def check_disjunctive_assignment(node); end
end

# source://rubocop//lib/rubocop/cop/lint/disjunctive_assignment_in_constructor.rb#51
RuboCop::Cop::Lint::DisjunctiveAssignmentInConstructor::MSG = T.let(T.unsafe(nil), String)

# Checks that there are no repeated bodies
# within `if/unless`, `case-when`, `case-in` and `rescue` constructs.
#
# With `IgnoreLiteralBranches: true`, branches are not registered
# as offenses if they return a basic literal value (string, symbol,
# integer, float, rational, complex, `true`, `false`, or `nil`), or
# return an array, hash, regexp or range that only contains one of
# the above basic literal values.
#
# With `IgnoreConstantBranches: true`, branches are not registered
# as offenses if they return a constant value.
#
# @example
#   # bad
#   if foo
#   do_foo
#   do_something_else
#   elsif bar
#   do_foo
#   do_something_else
#   end
#
#   # good
#   if foo || bar
#   do_foo
#   do_something_else
#   end
#
#   # bad
#   case x
#   when foo
#   do_foo
#   when bar
#   do_foo
#   else
#   do_something_else
#   end
#
#   # good
#   case x
#   when foo, bar
#   do_foo
#   else
#   do_something_else
#   end
#
#   # bad
#   begin
#   do_something
#   rescue FooError
#   handle_error
#   rescue BarError
#   handle_error
#   end
#
#   # good
#   begin
#   do_something
#   rescue FooError, BarError
#   handle_error
#   end
# @example IgnoreLiteralBranches: true
#   # good
#   case size
#   when "small" then 100
#   when "medium" then 250
#   when "large" then 1000
#   else 250
#   end
# @example IgnoreConstantBranches: true
#   # good
#   case size
#   when "small" then SMALL_SIZE
#   when "medium" then MEDIUM_SIZE
#   when "large" then LARGE_SIZE
#   else MEDIUM_SIZE
#   end
#
# source://rubocop//lib/rubocop/cop/lint/duplicate_branch.rb#86
class RuboCop::Cop::Lint::DuplicateBranch < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/lint/duplicate_branch.rb#89
  def on_branching_statement(node); end

  # source://rubocop//lib/rubocop/cop/lint/duplicate_branch.rb#89
  def on_case(node); end

  # source://rubocop//lib/rubocop/cop/lint/duplicate_branch.rb#89
  def on_case_match(node); end

  # source://rubocop//lib/rubocop/cop/lint/duplicate_branch.rb#89
  def on_if(node); end

  # source://rubocop//lib/rubocop/cop/lint/duplicate_branch.rb#89
  def on_rescue(node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/duplicate_branch.rb#117
  def branches(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/duplicate_branch.rb#121
  def consider_branch?(branch); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/duplicate_branch.rb#147
  def const_branch?(branch); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/duplicate_branch.rb#132
  def ignore_constant_branches?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/duplicate_branch.rb#128
  def ignore_literal_branches?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/duplicate_branch.rb#136
  def literal_branch?(branch); end

  # source://rubocop//lib/rubocop/cop/lint/duplicate_branch.rb#103
  def offense_range(duplicate_branch); end
end

# source://rubocop//lib/rubocop/cop/lint/duplicate_branch.rb#87
RuboCop::Cop::Lint::DuplicateBranch::MSG = T.let(T.unsafe(nil), String)

# Checks that there are no repeated conditions
# used in case 'when' expressions.
#
# @example
#
#   # bad
#
#   case x
#   when 'first'
#   do_something
#   when 'first'
#   do_something_else
#   end
# @example
#
#   # good
#
#   case x
#   when 'first'
#   do_something
#   when 'second'
#   do_something_else
#   end
#
# source://rubocop//lib/rubocop/cop/lint/duplicate_case_condition.rb#30
class RuboCop::Cop::Lint::DuplicateCaseCondition < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/lint/duplicate_case_condition.rb#33
  def on_case(case_node); end
end

# source://rubocop//lib/rubocop/cop/lint/duplicate_case_condition.rb#31
RuboCop::Cop::Lint::DuplicateCaseCondition::MSG = T.let(T.unsafe(nil), String)

# Checks that there are no repeated conditions used in if 'elsif'.
#
# @example
#   # bad
#   if x == 1
#   do_something
#   elsif x == 1
#   do_something_else
#   end
#
#   # good
#   if x == 1
#   do_something
#   elsif x == 2
#   do_something_else
#   end
#
# source://rubocop//lib/rubocop/cop/lint/duplicate_elsif_condition.rb#23
class RuboCop::Cop::Lint::DuplicateElsifCondition < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/lint/duplicate_elsif_condition.rb#26
  def on_if(node); end
end

# source://rubocop//lib/rubocop/cop/lint/duplicate_elsif_condition.rb#24
RuboCop::Cop::Lint::DuplicateElsifCondition::MSG = T.let(T.unsafe(nil), String)

# Checks for duplicated keys in hash literals.
#
# This cop mirrors a warning in Ruby 2.2.
#
# @example
#
#   # bad
#
#   hash = { food: 'apple', food: 'orange' }
# @example
#
#   # good
#
#   hash = { food: 'apple', other_food: 'orange' }
#
# source://rubocop//lib/rubocop/cop/lint/duplicate_hash_key.rb#21
class RuboCop::Cop::Lint::DuplicateHashKey < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Duplication

  # source://rubocop//lib/rubocop/cop/lint/duplicate_hash_key.rb#26
  def on_hash(node); end
end

# source://rubocop//lib/rubocop/cop/lint/duplicate_hash_key.rb#24
RuboCop::Cop::Lint::DuplicateHashKey::MSG = T.let(T.unsafe(nil), String)

# Checks for duplicated magic comments.
#
# @example
#
#   # bad
#
#   # encoding: ascii
#   # encoding: ascii
#
#   # good
#
#   # encoding: ascii
#
#   # bad
#
#   # frozen_string_literal: true
#   # frozen_string_literal: true
#
#   # good
#
#   # frozen_string_literal: true
#
# source://rubocop//lib/rubocop/cop/lint/duplicate_magic_comment.rb#28
class RuboCop::Cop::Lint::DuplicateMagicComment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/duplicate_magic_comment.rb#35
  def on_new_investigation; end

  private

  # source://rubocop//lib/rubocop/cop/lint/duplicate_magic_comment.rb#51
  def magic_comment_lines; end

  # source://rubocop//lib/rubocop/cop/lint/duplicate_magic_comment.rb#65
  def register_offense(range); end
end

# source://rubocop//lib/rubocop/cop/lint/duplicate_magic_comment.rb#33
RuboCop::Cop::Lint::DuplicateMagicComment::MSG = T.let(T.unsafe(nil), String)

# Checks for duplicated instance (or singleton) method
# definitions.
#
# @example
#
#   # bad
#
#   def foo
#   1
#   end
#
#   def foo
#   2
#   end
# @example
#
#   # bad
#
#   def foo
#   1
#   end
#
#   alias foo bar
# @example
#
#   # good
#
#   def foo
#   1
#   end
#
#   def bar
#   2
#   end
# @example
#
#   # good
#
#   def foo
#   1
#   end
#
#   alias bar foo
#
# source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#52
class RuboCop::Cop::Lint::DuplicateMethods < ::RuboCop::Cop::Base
  # @return [DuplicateMethods] a new instance of DuplicateMethods
  #
  # source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#57
  def initialize(config = T.unsafe(nil), options = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#98
  def alias_method?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#85
  def method_alias?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#89
  def on_alias(node); end

  # source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#63
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#72
  def on_defs(node); end

  # source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#104
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#103
  def sym_name(param0 = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#117
  def check_const_receiver(node, name, const_name); end

  # source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#124
  def check_self_receiver(node, name); end

  # source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#208
  def found_attr(node, args, readable: T.unsafe(nil), writable: T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#136
  def found_instance_method(node, name); end

  # source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#159
  def found_method(node, method_name); end

  # source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#149
  def found_sclass_method(node, name); end

  # source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#186
  def location(node); end

  # source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#218
  def lookup_constant(node, const_name); end

  # source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#131
  def message_for_dup(node, method_name, key); end

  # source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#178
  def method_key(node, method_name); end

  # source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#194
  def on_attr(node, attr_name, args); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#250
  def possible_dsl?(node); end

  # source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#236
  def qualified_name(enclosing, namespace, mod_name); end

  # source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#260
  def source_location(node); end
end

# source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#55
RuboCop::Cop::Lint::DuplicateMethods::DEF_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#53
RuboCop::Cop::Lint::DuplicateMethods::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#54
RuboCop::Cop::Lint::DuplicateMethods::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for duplicate elements in Regexp character classes.
#
# @example
#
#   # bad
#   r = /[xyx]/
#
#   # bad
#   r = /[0-9x0-9]/
#
#   # good
#   r = /[xy]/
#
#   # good
#   r = /[0-9x]/
#
# source://rubocop//lib/rubocop/cop/lint/duplicate_regexp_character_class_element.rb#21
class RuboCop::Cop::Lint::DuplicateRegexpCharacterClassElement < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/duplicate_regexp_character_class_element.rb#36
  def each_repeated_character_class_element_loc(node); end

  # source://rubocop//lib/rubocop/cop/lint/duplicate_regexp_character_class_element.rb#27
  def on_regexp(node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/duplicate_regexp_character_class_element.rb#83
  def interpolation_locs(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/duplicate_regexp_character_class_element.rb#65
  def skip_expression?(expr); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/duplicate_regexp_character_class_element.rb#78
  def start_with_escaped_zero_number?(current_child, next_child); end

  # Since we blank interpolations with a space for every char of the interpolation, we would
  # mark every space (except the first) as duplicate if we do not skip regexp_parser nodes
  # that are within an interpolation.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/duplicate_regexp_character_class_element.rb#72
  def within_interpolation?(node, child); end
end

# source://rubocop//lib/rubocop/cop/lint/duplicate_regexp_character_class_element.rb#25
RuboCop::Cop::Lint::DuplicateRegexpCharacterClassElement::MSG_REPEATED_ELEMENT = T.let(T.unsafe(nil), String)

# Checks for duplicate ``require``s and ``require_relative``s.
#
# @example
#   # bad
#   require 'foo'
#   require 'bar'
#   require 'foo'
#
#   # good
#   require 'foo'
#   require 'bar'
#
#   # good
#   require 'foo'
#   require_relative 'foo'
#
# source://rubocop//lib/rubocop/cop/lint/duplicate_require.rb#26
class RuboCop::Cop::Lint::DuplicateRequire < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/duplicate_require.rb#39
  def on_new_investigation; end

  # source://rubocop//lib/rubocop/cop/lint/duplicate_require.rb#45
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/lint/duplicate_require.rb#35
  def require_call?(param0 = T.unsafe(nil)); end
end

# source://rubocop//lib/rubocop/cop/lint/duplicate_require.rb#30
RuboCop::Cop::Lint::DuplicateRequire::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/duplicate_require.rb#31
RuboCop::Cop::Lint::DuplicateRequire::REQUIRE_METHODS = T.let(T.unsafe(nil), Set)

# source://rubocop//lib/rubocop/cop/lint/duplicate_require.rb#32
RuboCop::Cop::Lint::DuplicateRequire::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Set)

# Checks that there are no repeated exceptions
# used in 'rescue' expressions.
#
# @example
#   # bad
#   begin
#   something
#   rescue FirstException
#   handle_exception
#   rescue FirstException
#   handle_other_exception
#   end
#
#   # good
#   begin
#   something
#   rescue FirstException
#   handle_exception
#   rescue SecondException
#   handle_other_exception
#   end
#
# source://rubocop//lib/rubocop/cop/lint/duplicate_rescue_exception.rb#28
class RuboCop::Cop::Lint::DuplicateRescueException < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RescueNode

  # source://rubocop//lib/rubocop/cop/lint/duplicate_rescue_exception.rb#33
  def on_rescue(node); end
end

# source://rubocop//lib/rubocop/cop/lint/duplicate_rescue_exception.rb#31
RuboCop::Cop::Lint::DuplicateRescueException::MSG = T.let(T.unsafe(nil), String)

# Checks if each_with_object is called with an immutable
# argument. Since the argument is the object that the given block shall
# make calls on to build something based on the enumerable that
# each_with_object iterates over, an immutable argument makes no sense.
# It's definitely a bug.
#
# @example
#
#   # bad
#
#   sum = numbers.each_with_object(0) { |e, a| a += e }
# @example
#
#   # good
#
#   num = 0
#   sum = numbers.each_with_object(num) { |e, a| a += e }
#
# source://rubocop//lib/rubocop/cop/lint/each_with_object_argument.rb#24
class RuboCop::Cop::Lint::EachWithObjectArgument < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/lint/each_with_object_argument.rb#29
  def each_with_object?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/each_with_object_argument.rb#33
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/lint/each_with_object_argument.rb#33
  def on_send(node); end
end

# source://rubocop//lib/rubocop/cop/lint/each_with_object_argument.rb#25
RuboCop::Cop::Lint::EachWithObjectArgument::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/each_with_object_argument.rb#26
RuboCop::Cop::Lint::EachWithObjectArgument::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for odd `else` block layout - like
# having an expression on the same line as the `else` keyword,
# which is usually a mistake.
#
# Its autocorrection tweaks layout to keep the syntax. So, this autocorrection
# is compatible correction for bad case syntax, but if your code makes a mistake
# with `elsif` and `else`, you will have to correct it manually.
#
# @example
#
#   # bad
#
#   if something
#   # ...
#   else do_this
#   do_that
#   end
# @example
#
#   # good
#
#   # This code is compatible with the bad case. It will be autocorrected like this.
#   if something
#   # ...
#   else
#   do_this
#   do_that
#   end
#
#   # This code is incompatible with the bad case.
#   # If `do_this` is a condition, `elsif` should be used instead of `else`.
#   if something
#   # ...
#   elsif do_this
#   do_that
#   end
#
# source://rubocop//lib/rubocop/cop/lint/else_layout.rb#43
class RuboCop::Cop::Lint::ElseLayout < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/else_layout.rb#50
  def on_if(node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/else_layout.rb#81
  def autocorrect(corrector, node, first_else); end

  # source://rubocop//lib/rubocop/cop/lint/else_layout.rb#61
  def check(node); end

  # source://rubocop//lib/rubocop/cop/lint/else_layout.rb#71
  def check_else(node); end
end

# source://rubocop//lib/rubocop/cop/lint/else_layout.rb#48
RuboCop::Cop::Lint::ElseLayout::MSG = T.let(T.unsafe(nil), String)

# Checks for blocks without a body.
# Such empty blocks are typically an oversight or we should provide a comment
# be clearer what we're aiming for.
#
# Empty lambdas and procs are ignored by default.
#
# NOTE: For backwards compatibility, the configuration that allows/disallows
# empty lambdas and procs is called `AllowEmptyLambdas`, even though it also
# applies to procs.
#
# @example
#   # bad
#   items.each { |item| }
#
#   # good
#   items.each { |item| puts item }
# @example AllowComments: true (default)
#   # good
#   items.each do |item|
#   # TODO: implement later (inner comment)
#   end
#
#   items.each { |item| } # TODO: implement later (inline comment)
# @example AllowComments: false
#   # bad
#   items.each do |item|
#   # TODO: implement later (inner comment)
#   end
#
#   items.each { |item| } # TODO: implement later (inline comment)
# @example AllowEmptyLambdas: true (default)
#   # good
#   allow(subject).to receive(:callable).and_return(-> {})
#
#   placeholder = lambda do
#   end
#   (callable || placeholder).call
#
#   proc { }
#
#   Proc.new { }
# @example AllowEmptyLambdas: false
#   # bad
#   allow(subject).to receive(:callable).and_return(-> {})
#
#   placeholder = lambda do
#   end
#   (callable || placeholder).call
#
#   proc { }
#
#   Proc.new { }
#
# source://rubocop//lib/rubocop/cop/lint/empty_block.rb#63
class RuboCop::Cop::Lint::EmptyBlock < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/lint/empty_block.rb#66
  def on_block(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/empty_block.rb#76
  def allow_comment?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/empty_block.rb#83
  def allow_empty_lambdas?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/empty_block.rb#87
  def comment_disables_cop?(comment); end
end

# source://rubocop//lib/rubocop/cop/lint/empty_block.rb#64
RuboCop::Cop::Lint::EmptyBlock::MSG = T.let(T.unsafe(nil), String)

# Checks for classes and metaclasses without a body.
# Such empty classes and metaclasses are typically an oversight or we should provide a comment
# to be clearer what we're aiming for.
#
# @example
#   # bad
#   class Foo
#   end
#
#   class Bar
#   class << self
#   end
#   end
#
#   class << obj
#   end
#
#   # good
#   class Foo
#   def do_something
#   # ... code
#   end
#   end
#
#   class Bar
#   class << self
#   attr_reader :bar
#   end
#   end
#
#   class << obj
#   attr_reader :bar
#   end
# @example AllowComments: false (default)
#   # bad
#   class Foo
#   # TODO: implement later
#   end
#
#   class Bar
#   class << self
#   # TODO: implement later
#   end
#   end
#
#   class << obj
#   # TODO: implement later
#   end
# @example AllowComments: true
#   # good
#   class Foo
#   # TODO: implement later
#   end
#
#   class Bar
#   class << self
#   # TODO: implement later
#   end
#   end
#
#   class << obj
#   # TODO: implement later
#   end
#
# source://rubocop//lib/rubocop/cop/lint/empty_class.rb#72
class RuboCop::Cop::Lint::EmptyClass < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/lint/empty_class.rb#76
  def on_class(node); end

  # source://rubocop//lib/rubocop/cop/lint/empty_class.rb#81
  def on_sclass(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/empty_class.rb#87
  def body_or_allowed_comment_lines?(node); end
end

# source://rubocop//lib/rubocop/cop/lint/empty_class.rb#73
RuboCop::Cop::Lint::EmptyClass::CLASS_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/empty_class.rb#74
RuboCop::Cop::Lint::EmptyClass::METACLASS_MSG = T.let(T.unsafe(nil), String)

# Checks for the presence of `if`, `elsif` and `unless` branches without a body.
#
# NOTE: empty `else` branches are handled by `Style/EmptyElse`.
#
# @example
#   # bad
#   if condition
#   end
#
#   # bad
#   unless condition
#   end
#
#   # bad
#   if condition
#   do_something
#   elsif other_condition
#   end
#
#   # good
#   if condition
#   do_something
#   end
#
#   # good
#   unless condition
#   do_something
#   end
#
#   # good
#   if condition
#   do_something
#   elsif other_condition
#   do_something_else
#   end
# @example AllowComments: true (default)
#   # good
#   if condition
#   do_something
#   elsif other_condition
#   # noop
#   end
# @example AllowComments: false
#   # bad
#   if condition
#   do_something
#   elsif other_condition
#   # noop
#   end
#
# source://rubocop//lib/rubocop/cop/lint/empty_conditional_body.rb#63
class RuboCop::Cop::Lint::EmptyConditionalBody < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::CommentsHelp
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/empty_conditional_body.rb#70
  def on_if(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/empty_conditional_body.rb#156
  def all_branches_body_missing?(node); end

  # source://rubocop//lib/rubocop/cop/lint/empty_conditional_body.rb#83
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/lint/empty_conditional_body.rb#142
  def branch_range(node); end

  # source://rubocop//lib/rubocop/cop/lint/empty_conditional_body.rb#104
  def correct_other_branches(corrector, node); end

  # source://rubocop//lib/rubocop/cop/lint/empty_conditional_body.rb#162
  def deletion_range(range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/empty_conditional_body.rb#137
  def else_branch?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/empty_conditional_body.rb#131
  def empty_elsif_branch?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/empty_conditional_body.rb#123
  def empty_if_branch?(node); end

  # source://rubocop//lib/rubocop/cop/lint/empty_conditional_body.rb#89
  def remove_comments(corrector, node); end

  # source://rubocop//lib/rubocop/cop/lint/empty_conditional_body.rb#96
  def remove_empty_branch(corrector, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/empty_conditional_body.rb#116
  def require_other_branches_correction?(node); end
end

# source://rubocop//lib/rubocop/cop/lint/empty_conditional_body.rb#68
RuboCop::Cop::Lint::EmptyConditionalBody::MSG = T.let(T.unsafe(nil), String)

# Checks for empty `ensure` blocks
#
# @example
#
#   # bad
#
#   def some_method
#   do_something
#   ensure
#   end
# @example
#
#   # bad
#
#   begin
#   do_something
#   ensure
#   end
# @example
#
#   # good
#
#   def some_method
#   do_something
#   ensure
#   do_something_else
#   end
# @example
#
#   # good
#
#   begin
#   do_something
#   ensure
#   do_something_else
#   end
#
# source://rubocop//lib/rubocop/cop/lint/empty_ensure.rb#45
class RuboCop::Cop::Lint::EmptyEnsure < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/empty_ensure.rb#50
  def on_ensure(node); end
end

# source://rubocop//lib/rubocop/cop/lint/empty_ensure.rb#48
RuboCop::Cop::Lint::EmptyEnsure::MSG = T.let(T.unsafe(nil), String)

# Checks for the presence of empty expressions.
#
# @example
#
#   # bad
#
#   foo = ()
#   if ()
#   bar
#   end
# @example
#
#   # good
#
#   foo = (some_expression)
#   if (some_expression)
#   bar
#   end
#
# source://rubocop//lib/rubocop/cop/lint/empty_expression.rb#25
class RuboCop::Cop::Lint::EmptyExpression < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/lint/empty_expression.rb#28
  def on_begin(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/empty_expression.rb#36
  def empty_expression?(begin_node); end
end

# source://rubocop//lib/rubocop/cop/lint/empty_expression.rb#26
RuboCop::Cop::Lint::EmptyExpression::MSG = T.let(T.unsafe(nil), String)

# Enforces that Ruby source files are not empty.
#
# @example
#   # bad
#   # Empty file
#
#   # good
#   # File containing non commented source lines
# @example AllowComments: true (default)
#   # good
#   # File consisting only of comments
# @example AllowComments: false
#   # bad
#   # File consisting only of comments
#
# source://rubocop//lib/rubocop/cop/lint/empty_file.rb#23
class RuboCop::Cop::Lint::EmptyFile < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/lint/empty_file.rb#28
  def on_new_investigation; end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/empty_file.rb#42
  def contains_only_comments?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/empty_file.rb#38
  def empty_file?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/empty_file.rb#34
  def offending?; end
end

# source://rubocop//lib/rubocop/cop/lint/empty_file.rb#26
RuboCop::Cop::Lint::EmptyFile::MSG = T.let(T.unsafe(nil), String)

# Checks for the presence of `in` pattern branches without a body.
#
# @example
#
#   # bad
#   case condition
#   in [a]
#   do_something
#   in [a, b]
#   end
#
#   # good
#   case condition
#   in [a]
#   do_something
#   in [a, b]
#   nil
#   end
# @example AllowComments: true (default)
#
#   # good
#   case condition
#   in [a]
#   do_something
#   in [a, b]
#   # noop
#   end
# @example AllowComments: false
#
#   # bad
#   case condition
#   in [a]
#   do_something
#   in [a, b]
#   # noop
#   end
#
# source://rubocop//lib/rubocop/cop/lint/empty_in_pattern.rb#45
class RuboCop::Cop::Lint::EmptyInPattern < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::CommentsHelp
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop//lib/rubocop/cop/lint/empty_in_pattern.rb#53
  def on_case_match(node); end
end

# source://rubocop//lib/rubocop/cop/lint/empty_in_pattern.rb#49
RuboCop::Cop::Lint::EmptyInPattern::MSG = T.let(T.unsafe(nil), String)

# Checks for empty interpolation.
#
# @example
#
#   # bad
#
#   "result is #{}"
# @example
#
#   # good
#
#   "result is #{some_result}"
#
# source://rubocop//lib/rubocop/cop/lint/empty_interpolation.rb#19
class RuboCop::Cop::Lint::EmptyInterpolation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Interpolation
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/empty_interpolation.rb#25
  def on_interpolation(begin_node); end
end

# source://rubocop//lib/rubocop/cop/lint/empty_interpolation.rb#23
RuboCop::Cop::Lint::EmptyInterpolation::MSG = T.let(T.unsafe(nil), String)

# Checks for the presence of `when` branches without a body.
#
# @example
#
#   # bad
#   case foo
#   when bar
#   do_something
#   when baz
#   end
# @example
#
#   # good
#   case condition
#   when foo
#   do_something
#   when bar
#   nil
#   end
# @example AllowComments: true (default)
#
#   # good
#   case condition
#   when foo
#   do_something
#   when bar
#   # noop
#   end
# @example AllowComments: false
#
#   # bad
#   case condition
#   when foo
#   do_something
#   when bar
#   # do nothing
#   end
#
# source://rubocop//lib/rubocop/cop/lint/empty_when.rb#47
class RuboCop::Cop::Lint::EmptyWhen < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::CommentsHelp

  # source://rubocop//lib/rubocop/cop/lint/empty_when.rb#52
  def on_case(node); end
end

# source://rubocop//lib/rubocop/cop/lint/empty_when.rb#50
RuboCop::Cop::Lint::EmptyWhen::MSG = T.let(T.unsafe(nil), String)

# Checks for `return` from an `ensure` block.
# `return` from an ensure block is a dangerous code smell as it
# will take precedence over any exception being raised,
# and the exception will be silently thrown away as if it were rescued.
#
# If you want to rescue some (or all) exceptions, best to do it explicitly
#
# @example
#
#   # bad
#
#   def foo
#   do_something
#   ensure
#   cleanup
#   return self
#   end
# @example
#
#   # good
#
#   def foo
#   do_something
#   self
#   ensure
#   cleanup
#   end
#
#   # also good
#
#   def foo
#   begin
#   do_something
#   rescue SomeException
#   # Let's ignore this exception
#   end
#   self
#   ensure
#   cleanup
#   end
#
# source://rubocop//lib/rubocop/cop/lint/ensure_return.rb#47
class RuboCop::Cop::Lint::EnsureReturn < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/ensure_return.rb#53
  def on_ensure(node); end
end

# source://rubocop//lib/rubocop/cop/lint/ensure_return.rb#51
RuboCop::Cop::Lint::EnsureReturn::MSG = T.let(T.unsafe(nil), String)

# This cop emulates the following Ruby warnings in Ruby 2.6.
#
# [source,console]
# ----
# % cat example.rb
# ERB.new('hi', nil, '-', '@output_buffer')
# % ruby -rerb example.rb
# example.rb:1: warning: Passing safe_level with the 2nd argument of ERB.new is
# deprecated. Do not use it, and specify other arguments as keyword arguments.
# example.rb:1: warning: Passing trim_mode with the 3rd argument of ERB.new is
# deprecated. Use keyword argument like ERB.new(str, trim_mode:...) instead.
# example.rb:1: warning: Passing eoutvar with the 4th argument of ERB.new is
# deprecated. Use keyword argument like ERB.new(str, eoutvar: ...) instead.
# ----
#
# Now non-keyword arguments other than first one are softly deprecated
# and will be removed when Ruby 2.5 becomes EOL.
# `ERB.new` with non-keyword arguments is deprecated since ERB 2.2.0.
# Use `:trim_mode` and `:eoutvar` keyword arguments to `ERB.new`.
# This cop identifies places where `ERB.new(str, trim_mode, eoutvar)` can
# be replaced by `ERB.new(str, :trim_mode: trim_mode, eoutvar: eoutvar)`.
#
# @example
#   # Target codes supports Ruby 2.6 and higher only
#   # bad
#   ERB.new(str, nil, '-', '@output_buffer')
#
#   # good
#   ERB.new(str, trim_mode: '-', eoutvar: '@output_buffer')
#
#   # Target codes supports Ruby 2.5 and lower only
#   # good
#   ERB.new(str, nil, '-', '@output_buffer')
#
#   # Target codes supports Ruby 2.6, 2.5 and lower
#   # bad
#   ERB.new(str, nil, '-', '@output_buffer')
#
#   # good
#   # Ruby standard library style
#   # https://github.com/ruby/ruby/commit/3406c5d
#   if ERB.instance_method(:initialize).parameters.assoc(:key) # Ruby 2.6+
#   ERB.new(str, trim_mode: '-', eoutvar: '@output_buffer')
#   else
#   ERB.new(str, nil, '-', '@output_buffer')
#   end
#
#   # good
#   # Use `RUBY_VERSION` style
#   if RUBY_VERSION >= '2.6'
#   ERB.new(str, trim_mode: '-', eoutvar: '@output_buffer')
#   else
#   ERB.new(str, nil, '-', '@output_buffer')
#   end
#
# source://rubocop//lib/rubocop/cop/lint/erb_new_arguments.rb#62
class RuboCop::Cop::Lint::ErbNewArguments < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop//lib/rubocop/cop/lint/erb_new_arguments.rb#84
  def erb_new_with_non_keyword_arguments(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/erb_new_arguments.rb#89
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/erb_new_arguments.rb#154
  def arguments_range(node); end

  # source://rubocop//lib/rubocop/cop/lint/erb_new_arguments.rb#109
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/lint/erb_new_arguments.rb#124
  def build_kwargs(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/erb_new_arguments.rb#120
  def correct_arguments?(arguments); end

  # source://rubocop//lib/rubocop/cop/lint/erb_new_arguments.rb#141
  def override_by_legacy_args(kwargs, node); end
end

# source://rubocop//lib/rubocop/cop/lint/erb_new_arguments.rb#69
RuboCop::Cop::Lint::ErbNewArguments::MESSAGES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/erb_new_arguments.rb#81
RuboCop::Cop::Lint::ErbNewArguments::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Looks for uses of flip-flop operator
# based on the Ruby Style Guide.
#
# Here is the history of flip-flops in Ruby.
# flip-flop operator is deprecated in Ruby 2.6.0 and
# the deprecation has been reverted by Ruby 2.7.0 and
# backported to Ruby 2.6.
# See: https://bugs.ruby-lang.org/issues/5400
#
# @example
#   # bad
#   (1..20).each do |x|
#   puts x if (x == 5) .. (x == 10)
#   end
#
#   # good
#   (1..20).each do |x|
#   puts x if (x >= 5) && (x <= 10)
#   end
#
# source://rubocop//lib/rubocop/cop/lint/flip_flop.rb#25
class RuboCop::Cop::Lint::FlipFlop < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/lint/flip_flop.rb#32
  def on_eflipflop(node); end

  # source://rubocop//lib/rubocop/cop/lint/flip_flop.rb#28
  def on_iflipflop(node); end
end

# source://rubocop//lib/rubocop/cop/lint/flip_flop.rb#26
RuboCop::Cop::Lint::FlipFlop::MSG = T.let(T.unsafe(nil), String)

# Checks for the presence of precise comparison of floating point numbers.
#
# Floating point values are inherently inaccurate, and comparing them for exact equality
# is almost never the desired semantics. Comparison via the `==/!=` operators checks
# floating-point value representation to be exactly the same, which is very unlikely
# if you perform any arithmetic operations involving precision loss.
#
# @example
#   # bad
#   x == 0.1
#   x != 0.1
#
#   # good - using BigDecimal
#   x.to_d == 0.1.to_d
#
#   # good
#   (x - 0.1).abs < Float::EPSILON
#
#   # good
#   tolerance = 0.0001
#   (x - 0.1).abs < tolerance
#
#   # Or some other epsilon based type of comparison:
#   # https://www.embeddeduse.com/2019/08/26/qt-compare-two-floats/
#
# source://rubocop//lib/rubocop/cop/lint/float_comparison.rb#31
class RuboCop::Cop::Lint::FloatComparison < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/lint/float_comparison.rb#40
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/float_comparison.rb#79
  def check_numeric_returning_method(node); end

  # source://rubocop//lib/rubocop/cop/lint/float_comparison.rb#63
  def check_send(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/float_comparison.rb#47
  def float?(node); end
end

# source://rubocop//lib/rubocop/cop/lint/float_comparison.rb#34
RuboCop::Cop::Lint::FloatComparison::EQUALITY_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/float_comparison.rb#36
RuboCop::Cop::Lint::FloatComparison::FLOAT_INSTANCE_METHODS = T.let(T.unsafe(nil), Set)

# source://rubocop//lib/rubocop/cop/lint/float_comparison.rb#35
RuboCop::Cop::Lint::FloatComparison::FLOAT_RETURNING_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/float_comparison.rb#32
RuboCop::Cop::Lint::FloatComparison::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/float_comparison.rb#38
RuboCop::Cop::Lint::FloatComparison::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Identifies Float literals which are, like, really really really
# really really really really really big. Too big. No-one needs Floats
# that big. If you need a float that big, something is wrong with you.
#
# @example
#
#   # bad
#
#   float = 3.0e400
# @example
#
#   # good
#
#   float = 42.9
#
# source://rubocop//lib/rubocop/cop/lint/float_out_of_range.rb#21
class RuboCop::Cop::Lint::FloatOutOfRange < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/lint/float_out_of_range.rb#24
  def on_float(node); end
end

# source://rubocop//lib/rubocop/cop/lint/float_out_of_range.rb#22
RuboCop::Cop::Lint::FloatOutOfRange::MSG = T.let(T.unsafe(nil), String)

# This lint sees if there is a mismatch between the number of
# expected fields for format/sprintf/#% and what is actually
# passed as arguments.
#
# In addition it checks whether different formats are used in the same
# format string. Do not mix numbered, unnumbered, and named formats in
# the same format string.
#
# @example
#
#   # bad
#
#   format('A value: %s and another: %i', a_value)
# @example
#
#   # good
#
#   format('A value: %s and another: %i', a_value, another)
# @example
#
#   # bad
#
#   format('Unnumbered format: %s and numbered: %2$s', a_value, another)
# @example
#
#   # good
#
#   format('Numbered format: %1$s and numbered %2$s', a_value, another)
#
# source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#37
class RuboCop::Cop::Lint::FormatParameterMismatch < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#100
  def called_on_string?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#49
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#137
  def count_format_matches(node); end

  # source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#119
  def count_matches(node); end

  # source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#141
  def count_percent_matches(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#129
  def countable_format?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#133
  def countable_percent?(node); end

  # source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#153
  def expected_fields_count(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#168
  def format?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#146
  def format_method?(name, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#64
  def format_string?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#115
  def heredoc?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#68
  def invalid_format_string?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#91
  def matched_arguments_count?(expected, passed); end

  # source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#186
  def message(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#105
  def method_with_format_args?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#77
  def offending_node?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#176
  def percent?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#109
  def splat_args?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#172
  def sprintf?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#195
  def string_type?(node); end
end

# source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#44
RuboCop::Cop::Lint::FormatParameterMismatch::KERNEL = T.let(T.unsafe(nil), String)

# http://rubular.com/r/CvpbxkcTzy
#
# source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#39
RuboCop::Cop::Lint::FormatParameterMismatch::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#41
RuboCop::Cop::Lint::FormatParameterMismatch::MSG_INVALID = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#47
RuboCop::Cop::Lint::FormatParameterMismatch::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#45
RuboCop::Cop::Lint::FormatParameterMismatch::SHOVEL = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#46
RuboCop::Cop::Lint::FormatParameterMismatch::STRING_TYPES = T.let(T.unsafe(nil), Array)

# Prefer using `Hash#compare_by_identity` rather than using `object_id`
# for hash keys.
#
# This cop looks for hashes being keyed by objects' `object_id`, using
# one of these methods: `key?`, `has_key?`, `fetch`, `[]` and `[]=`.
#
# @example
#   # bad
#   hash = {}
#   hash[foo.object_id] = :bar
#   hash.key?(baz.object_id)
#
#   # good
#   hash = {}.compare_by_identity
#   hash[foo] = :bar
#   hash.key?(baz)
#
# source://rubocop//lib/rubocop/cop/lint/hash_compare_by_identity.rb#31
class RuboCop::Cop::Lint::HashCompareByIdentity < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/lint/hash_compare_by_identity.rb#37
  def id_as_hash_key?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/hash_compare_by_identity.rb#41
  def on_send(node); end
end

# source://rubocop//lib/rubocop/cop/lint/hash_compare_by_identity.rb#34
RuboCop::Cop::Lint::HashCompareByIdentity::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/hash_compare_by_identity.rb#32
RuboCop::Cop::Lint::HashCompareByIdentity::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for the ordering of a method call where
# the receiver of the call is a HEREDOC.
#
# @example
#   # bad
#   <<-SQL
#   bar
#   SQL
#   .strip_indent
#
#   <<-SQL
#   bar
#   SQL
#   .strip_indent
#   .trim
#
#   # good
#   <<~SQL
#   bar
#   SQL
#
#   <<~SQL.trim
#   bar
#   SQL
#
# source://rubocop//lib/rubocop/cop/lint/heredoc_method_call_position.rb#31
class RuboCop::Cop::Lint::HeredocMethodCallPosition < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/heredoc_method_call_position.rb#37
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/lint/heredoc_method_call_position.rb#37
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/heredoc_method_call_position.rb#97
  def all_on_same_line?(nodes); end

  # source://rubocop//lib/rubocop/cop/lint/heredoc_method_call_position.rb#50
  def autocorrect(corrector, node, heredoc); end

  # source://rubocop//lib/rubocop/cop/lint/heredoc_method_call_position.rb#77
  def call_after_heredoc_range(heredoc); end

  # source://rubocop//lib/rubocop/cop/lint/heredoc_method_call_position.rb#107
  def call_end_pos(node); end

  # source://rubocop//lib/rubocop/cop/lint/heredoc_method_call_position.rb#116
  def call_line_range(node); end

  # Returns nil if no range can be safely repositioned.
  #
  # source://rubocop//lib/rubocop/cop/lint/heredoc_method_call_position.rb#122
  def call_range_to_safely_reposition(node, heredoc); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/heredoc_method_call_position.rb#86
  def calls_on_multiple_lines?(node, _heredoc); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/heredoc_method_call_position.rb#82
  def correctly_positioned?(node, heredoc); end

  # source://rubocop//lib/rubocop/cop/lint/heredoc_method_call_position.rb#111
  def heredoc_begin_line_range(heredoc); end

  # source://rubocop//lib/rubocop/cop/lint/heredoc_method_call_position.rb#103
  def heredoc_end_pos(heredoc); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/heredoc_method_call_position.rb#73
  def heredoc_node?(node); end

  # source://rubocop//lib/rubocop/cop/lint/heredoc_method_call_position.rb#59
  def heredoc_node_descendent_receiver(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/heredoc_method_call_position.rb#67
  def send_node?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/heredoc_method_call_position.rb#146
  def trailing_comma?(call_source, call_line_source); end
end

# source://rubocop//lib/rubocop/cop/lint/heredoc_method_call_position.rb#35
RuboCop::Cop::Lint::HeredocMethodCallPosition::MSG = T.let(T.unsafe(nil), String)

# Prefer `equal?` over `==` when comparing `object_id`.
#
# `Object#equal?` is provided to compare objects for identity, and in contrast
# `Object#==` is provided for the purpose of doing value comparison.
#
# @example
#   # bad
#   foo.object_id == bar.object_id
#
#   # good
#   foo.equal?(bar)
#
# source://rubocop//lib/rubocop/cop/lint/identity_comparison.rb#19
class RuboCop::Cop::Lint::IdentityComparison < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/identity_comparison.rb#25
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/identity_comparison.rb#41
  def compare_between_object_id_by_double_equal?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/identity_comparison.rb#45
  def object_id_method?(node); end
end

# source://rubocop//lib/rubocop/cop/lint/identity_comparison.rb#22
RuboCop::Cop::Lint::IdentityComparison::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/identity_comparison.rb#23
RuboCop::Cop::Lint::IdentityComparison::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for implicit string concatenation of string literals
# which are on the same line.
#
# @example
#
#   # bad
#
#   array = ['Item 1' 'Item 2']
# @example
#
#   # good
#
#   array = ['Item 1Item 2']
#   array = ['Item 1' + 'Item 2']
#   array = [
#   'Item 1' \
#   'Item 2'
#   ]
#
# source://rubocop//lib/rubocop/cop/lint/implicit_string_concatenation.rb#25
class RuboCop::Cop::Lint::ImplicitStringConcatenation < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/lint/implicit_string_concatenation.rb#33
  def on_dstr(node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/implicit_string_concatenation.rb#83
  def display_str(node); end

  # source://rubocop//lib/rubocop/cop/lint/implicit_string_concatenation.rb#50
  def each_bad_cons(node); end

  # source://rubocop//lib/rubocop/cop/lint/implicit_string_concatenation.rb#65
  def ending_delimiter(str); end

  # source://rubocop//lib/rubocop/cop/lint/implicit_string_concatenation.rb#91
  def str_content(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/implicit_string_concatenation.rb#75
  def string_literal?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/implicit_string_concatenation.rb#79
  def string_literals?(node1, node2); end
end

# source://rubocop//lib/rubocop/cop/lint/implicit_string_concatenation.rb#28
RuboCop::Cop::Lint::ImplicitStringConcatenation::FOR_ARRAY = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/implicit_string_concatenation.rb#30
RuboCop::Cop::Lint::ImplicitStringConcatenation::FOR_METHOD = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/implicit_string_concatenation.rb#26
RuboCop::Cop::Lint::ImplicitStringConcatenation::MSG = T.let(T.unsafe(nil), String)

# This cop checks for `IO.select` that is incompatible with Fiber Scheduler since Ruby 3.0.
#
# NOTE: When the method is successful the return value of `IO.select` is `[[IO]]`,
# and the return value of `io.wait_readable` and `io.wait_writable` are `self`.
# They are not autocorrected when assigning a return value because these types are different.
# It's up to user how to handle the return value.
#
# @example
#
#   # bad
#   IO.select([io], [], [], timeout)
#
#   # good
#   io.wait_readable(timeout)
#
#   # bad
#   IO.select([], [io], [], timeout)
#
#   # good
#   io.wait_writable(timeout)
#
# source://rubocop//lib/rubocop/cop/lint/incompatible_io_select_with_fiber_scheduler.rb#32
class RuboCop::Cop::Lint::IncompatibleIoSelectWithFiberScheduler < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/incompatible_io_select_with_fiber_scheduler.rb#39
  def io_select(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/incompatible_io_select_with_fiber_scheduler.rb#44
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/incompatible_io_select_with_fiber_scheduler.rb#67
  def preferred_method(read, write, timeout); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/incompatible_io_select_with_fiber_scheduler.rb#61
  def scheduler_compatible?(io1, io2); end
end

# source://rubocop//lib/rubocop/cop/lint/incompatible_io_select_with_fiber_scheduler.rb#35
RuboCop::Cop::Lint::IncompatibleIoSelectWithFiberScheduler::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/incompatible_io_select_with_fiber_scheduler.rb#36
RuboCop::Cop::Lint::IncompatibleIoSelectWithFiberScheduler::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for `private` or `protected` access modifiers which are
# applied to a singleton method. These access modifiers do not make
# singleton methods private/protected. `private_class_method` can be
# used for that.
#
# @example
#
#   # bad
#
#   class C
#   private
#
#   def self.method
#   puts 'hi'
#   end
#   end
# @example
#
#   # good
#
#   class C
#   def self.method
#   puts 'hi'
#   end
#
#   private_class_method :method
#   end
# @example
#
#   # good
#
#   class C
#   class << self
#   private
#
#   def method
#   puts 'hi'
#   end
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/lint/ineffective_access_modifier.rb#48
class RuboCop::Cop::Lint::IneffectiveAccessModifier < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/lint/ineffective_access_modifier.rb#59
  def on_class(node); end

  # source://rubocop//lib/rubocop/cop/lint/ineffective_access_modifier.rb#59
  def on_module(node); end

  # source://rubocop//lib/rubocop/cop/lint/ineffective_access_modifier.rb#55
  def private_class_methods(param0); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/ineffective_access_modifier.rb#109
  def access_modifier?(node); end

  # source://rubocop//lib/rubocop/cop/lint/ineffective_access_modifier.rb#66
  def check_node(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/ineffective_access_modifier.rb#113
  def correct_visibility?(node, modifier, ignored_methods); end

  # source://rubocop//lib/rubocop/cop/lint/ineffective_access_modifier.rb#78
  def format_message(modifier); end

  # source://rubocop//lib/rubocop/cop/lint/ineffective_access_modifier.rb#91
  def ineffective_modifier(node, ignored_methods = T.unsafe(nil), modifier = T.unsafe(nil), &block); end

  # source://rubocop//lib/rubocop/cop/lint/ineffective_access_modifier.rb#74
  def private_class_method_names(node); end
end

# source://rubocop//lib/rubocop/cop/lint/ineffective_access_modifier.rb#51
RuboCop::Cop::Lint::IneffectiveAccessModifier::ALTERNATIVE_PRIVATE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/ineffective_access_modifier.rb#52
RuboCop::Cop::Lint::IneffectiveAccessModifier::ALTERNATIVE_PROTECTED = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/ineffective_access_modifier.rb#49
RuboCop::Cop::Lint::IneffectiveAccessModifier::MSG = T.let(T.unsafe(nil), String)

# Looks for error classes inheriting from `Exception`.
# It is configurable to suggest using either `StandardError` (default) or
# `RuntimeError` instead.
#
# @example EnforcedStyle: standard_error (default)
#   # bad
#
#   class C < Exception; end
#
#   C = Class.new(Exception)
#
#   # good
#
#   class C < StandardError; end
#
#   C = Class.new(StandardError)
# @example EnforcedStyle: runtime_error
#   # bad
#
#   class C < Exception; end
#
#   C = Class.new(Exception)
#
#   # good
#
#   class C < RuntimeError; end
#
#   C = Class.new(RuntimeError)
#
# source://rubocop//lib/rubocop/cop/lint/inherit_exception.rb#40
class RuboCop::Cop::Lint::InheritException < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/inherit_exception.rb#53
  def class_new_call?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/inherit_exception.rb#59
  def on_class(node); end

  # source://rubocop//lib/rubocop/cop/lint/inherit_exception.rb#69
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/inherit_exception.rb#86
  def exception_class?(class_node); end

  # source://rubocop//lib/rubocop/cop/lint/inherit_exception.rb#82
  def message(node); end

  # source://rubocop//lib/rubocop/cop/lint/inherit_exception.rb#90
  def preferred_base_class; end
end

# source://rubocop//lib/rubocop/cop/lint/inherit_exception.rb#44
RuboCop::Cop::Lint::InheritException::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/inherit_exception.rb#45
RuboCop::Cop::Lint::InheritException::PREFERRED_BASE_CLASS = T.let(T.unsafe(nil), Hash)

# source://rubocop//lib/rubocop/cop/lint/inherit_exception.rb#50
RuboCop::Cop::Lint::InheritException::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for interpolation in a single quoted string.
#
# @example
#
#   # bad
#
#   foo = 'something with #{interpolation} inside'
# @example
#
#   # good
#
#   foo = "something with #{interpolation} inside"
#
# source://rubocop//lib/rubocop/cop/lint/interpolation_check.rb#25
class RuboCop::Cop::Lint::InterpolationCheck < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/interpolation_check.rb#31
  def on_str(node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/interpolation_check.rb#42
  def autocorrect(corrector, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/interpolation_check.rb#53
  def heredoc?(node); end
end

# source://rubocop//lib/rubocop/cop/lint/interpolation_check.rb#28
RuboCop::Cop::Lint::InterpolationCheck::MSG = T.let(T.unsafe(nil), String)

# Checks uses of lambda without a literal block.
# It emulates the following warning in Ruby 3.0:
#
#   % ruby -vwe 'lambda(&proc {})'
#   ruby 3.0.0p0 (2020-12-25 revision 95aff21468) [x86_64-darwin19]
#   -e:1: warning: lambda without a literal block is deprecated; use the proc without
#   lambda instead
#
# This way, proc object is never converted to lambda.
# Autocorrection replaces with compatible proc argument.
#
# @example
#
#   # bad
#   lambda(&proc { do_something })
#   lambda(&Proc.new { do_something })
#
#   # good
#   proc { do_something }
#   Proc.new { do_something }
#   lambda { do_something } # If you use lambda.
#
# source://rubocop//lib/rubocop/cop/lint/lambda_without_literal_block.rb#28
class RuboCop::Cop::Lint::LambdaWithoutLiteralBlock < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/lambda_without_literal_block.rb#35
  def lambda_with_symbol_proc?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/lambda_without_literal_block.rb#39
  def on_send(node); end
end

# source://rubocop//lib/rubocop/cop/lint/lambda_without_literal_block.rb#31
RuboCop::Cop::Lint::LambdaWithoutLiteralBlock::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/lambda_without_literal_block.rb#32
RuboCop::Cop::Lint::LambdaWithoutLiteralBlock::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for literals used as the conditions or as
# operands in and/or expressions serving as the conditions of
# if/while/until/case-when/case-in.
#
# NOTE: Literals in `case-in` condition where the match variable is used in
# `in` are accepted as a pattern matching.
#
# @example
#
#   # bad
#   if 20
#   do_something
#   end
#
#   # bad
#   if some_var && true
#   do_something
#   end
#
#   # good
#   if some_var && some_condition
#   do_something
#   end
#
#   # good
#   # When using a boolean value for an infinite loop.
#   while true
#   break if condition
#   end
#
# source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#35
class RuboCop::Cop::Lint::LiteralAsCondition < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#93
  def message(node); end

  # source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#58
  def on_case(case_node); end

  # source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#73
  def on_case_match(case_match_node); end

  # source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#40
  def on_if(node); end

  # source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#87
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#51
  def on_until(node); end

  # source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#51
  def on_until_post(node); end

  # source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#44
  def on_while(node); end

  # source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#44
  def on_while_post(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#108
  def basic_literal?(node); end

  # source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#138
  def check_case(case_node); end

  # source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#99
  def check_for_literal(node); end

  # source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#120
  def check_node(node); end

  # source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#147
  def condition(node); end

  # source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#130
  def handle_node(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#116
  def primitive_array?(node); end

  # source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#155
  def when_conditions_range(when_node); end
end

# source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#38
RuboCop::Cop::Lint::LiteralAsCondition::MSG = T.let(T.unsafe(nil), String)

# Checks for interpolated literals.
#
# @example
#
#   # bad
#
#   "result is #{10}"
# @example
#
#   # good
#
#   "result is 10"
#
# source://rubocop//lib/rubocop/cop/lint/literal_in_interpolation.rb#19
class RuboCop::Cop::Lint::LiteralInInterpolation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Interpolation
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::PercentLiteral
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/literal_in_interpolation.rb#28
  def on_interpolation(begin_node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/literal_in_interpolation.rb#62
  def autocorrected_value(node); end

  # source://rubocop//lib/rubocop/cop/lint/literal_in_interpolation.rb#108
  def autocorrected_value_for_array(node); end

  # source://rubocop//lib/rubocop/cop/lint/literal_in_interpolation.rb#114
  def autocorrected_value_for_hash(node); end

  # source://rubocop//lib/rubocop/cop/lint/literal_in_interpolation.rb#84
  def autocorrected_value_for_string(node); end

  # source://rubocop//lib/rubocop/cop/lint/literal_in_interpolation.rb#92
  def autocorrected_value_for_symbol(node); end

  # source://rubocop//lib/rubocop/cop/lint/literal_in_interpolation.rb#125
  def autocorrected_value_in_hash(node); end

  # source://rubocop//lib/rubocop/cop/lint/literal_in_interpolation.rb#99
  def autocorrected_value_in_hash_for_symbol(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/literal_in_interpolation.rb#155
  def ends_heredoc_line?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/literal_in_interpolation.rb#163
  def in_array_percent_literal?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/literal_in_interpolation.rb#48
  def offending?(node); end

  # Does node print its own source when converted to a string?
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/literal_in_interpolation.rb#146
  def prints_as_self?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/literal_in_interpolation.rb#151
  def space_literal?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/literal_in_interpolation.rb#56
  def special_keyword?(node); end
end

# source://rubocop//lib/rubocop/cop/lint/literal_in_interpolation.rb#26
RuboCop::Cop::Lint::LiteralInInterpolation::COMPOSITE = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/literal_in_interpolation.rb#25
RuboCop::Cop::Lint::LiteralInInterpolation::MSG = T.let(T.unsafe(nil), String)

# Checks for uses of `begin...end while/until something`.
#
# @example
#
#   # bad
#
#   # using while
#   begin
#   do_something
#   end while some_condition
# @example
#
#   # bad
#
#   # using until
#   begin
#   do_something
#   end until some_condition
# @example
#
#   # good
#
#   # while replacement
#   loop do
#   do_something
#   break unless some_condition
#   end
# @example
#
#   # good
#
#   # until replacement
#   loop do
#   do_something
#   break if some_condition
#   end
#
# source://rubocop//lib/rubocop/cop/lint/loop.rb#50
class RuboCop::Cop::Lint::Loop < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/loop.rb#59
  def on_until_post(node); end

  # source://rubocop//lib/rubocop/cop/lint/loop.rb#55
  def on_while_post(node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/loop.rb#79
  def build_break_line(node); end

  # source://rubocop//lib/rubocop/cop/lint/loop.rb#75
  def keyword_and_condition_range(node); end

  # source://rubocop//lib/rubocop/cop/lint/loop.rb#65
  def register_offense(node); end
end

# source://rubocop//lib/rubocop/cop/lint/loop.rb#53
RuboCop::Cop::Lint::Loop::MSG = T.let(T.unsafe(nil), String)

# cop disables on wide ranges of code, that latter contributors to
# a file wouldn't be aware of.
#
# @example
#   # Lint/MissingCopEnableDirective:
#   #   MaximumRangeSize: .inf
#
#   # good
#   # rubocop:disable Layout/SpaceAroundOperators
#   x= 0
#   # rubocop:enable Layout/SpaceAroundOperators
#   # y = 1
#   # EOF
#
#   # bad
#   # rubocop:disable Layout/SpaceAroundOperators
#   x= 0
#   # EOF
# @example
#   # Lint/MissingCopEnableDirective:
#   #   MaximumRangeSize: 2
#
#   # good
#   # rubocop:disable Layout/SpaceAroundOperators
#   x= 0
#   # With the previous, there are 2 lines on which cop is disabled.
#   # rubocop:enable Layout/SpaceAroundOperators
#
#   # bad
#   # rubocop:disable Layout/SpaceAroundOperators
#   x= 0
#   x += 1
#   # Including this, that's 3 lines on which the cop is disabled.
#   # rubocop:enable Layout/SpaceAroundOperators
#
# source://rubocop//lib/rubocop/cop/lint/missing_cop_enable_directive.rb#45
class RuboCop::Cop::Lint::MissingCopEnableDirective < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/lint/missing_cop_enable_directive.rb#51
  def on_new_investigation; end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/missing_cop_enable_directive.rb#70
  def acceptable_range?(cop, line_range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/missing_cop_enable_directive.rb#104
  def department_enabled?(cop, comment); end

  # source://rubocop//lib/rubocop/cop/lint/missing_cop_enable_directive.rb#64
  def each_missing_enable; end

  # source://rubocop//lib/rubocop/cop/lint/missing_cop_enable_directive.rb#87
  def max_range; end

  # source://rubocop//lib/rubocop/cop/lint/missing_cop_enable_directive.rb#91
  def message(cop, comment, type = T.unsafe(nil)); end
end

# source://rubocop//lib/rubocop/cop/lint/missing_cop_enable_directive.rb#48
RuboCop::Cop::Lint::MissingCopEnableDirective::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/missing_cop_enable_directive.rb#49
RuboCop::Cop::Lint::MissingCopEnableDirective::MSG_BOUND = T.let(T.unsafe(nil), String)

# Checks for the presence of constructors and lifecycle callbacks
# without calls to `super`.
#
# This cop does not consider `method_missing` (and `respond_to_missing?`)
# because in some cases it makes sense to overtake what is considered a
# missing method. In other cases, the theoretical ideal handling could be
# challenging or verbose for no actual gain.
#
# @example
#   # bad
#   class Employee < Person
#   def initialize(name, salary)
#   @salary = salary
#   end
#   end
#
#   # good
#   class Employee < Person
#   def initialize(name, salary)
#   super(name)
#   @salary = salary
#   end
#   end
#
#   # bad
#   Employee = Class.new(Person) do
#   def initialize(name, salary)
#   @salary = salary
#   end
#   end
#
#   # good
#   Employee = Class.new(Person) do
#   def initialize(name, salary)
#   super(name)
#   @salary = salary
#   end
#   end
#
#   # bad
#   class Parent
#   def self.inherited(base)
#   do_something
#   end
#   end
#
#   # good
#   class Parent
#   def self.inherited(base)
#   super
#   do_something
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/lint/missing_super.rb#60
class RuboCop::Cop::Lint::MissingSuper < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/lint/missing_super.rb#74
  def class_new_block(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/missing_super.rb#80
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/lint/missing_super.rb#90
  def on_defs(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/missing_super.rb#102
  def callback_method_def?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/missing_super.rb#108
  def contains_super?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/missing_super.rb#112
  def inside_class_with_stateful_parent?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/missing_super.rb#98
  def offender?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/missing_super.rb#124
  def stateless_class?(node); end
end

# source://rubocop//lib/rubocop/cop/lint/missing_super.rb#71
RuboCop::Cop::Lint::MissingSuper::CALLBACKS = T.let(T.unsafe(nil), Set)

# source://rubocop//lib/rubocop/cop/lint/missing_super.rb#62
RuboCop::Cop::Lint::MissingSuper::CALLBACK_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/missing_super.rb#66
RuboCop::Cop::Lint::MissingSuper::CLASS_LIFECYCLE_CALLBACKS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/missing_super.rb#61
RuboCop::Cop::Lint::MissingSuper::CONSTRUCTOR_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/missing_super.rb#67
RuboCop::Cop::Lint::MissingSuper::METHOD_LIFECYCLE_CALLBACKS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/missing_super.rb#64
RuboCop::Cop::Lint::MissingSuper::STATELESS_CLASSES = T.let(T.unsafe(nil), Array)

# Do not mix named captures and numbered captures in a Regexp literal
# because numbered capture is ignored if they're mixed.
# Replace numbered captures with non-capturing groupings or
# named captures.
#
# @example
#   # bad
#   /(?<foo>FOO)(BAR)/
#
#   # good
#   /(?<foo>FOO)(?<bar>BAR)/
#
#   # good
#   /(?<foo>FOO)(?:BAR)/
#
#   # good
#   /(FOO)(BAR)/
#
# source://rubocop//lib/rubocop/cop/lint/mixed_regexp_capture_types.rb#24
class RuboCop::Cop::Lint::MixedRegexpCaptureTypes < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/lint/mixed_regexp_capture_types.rb#27
  def on_regexp(node); end
end

# source://rubocop//lib/rubocop/cop/lint/mixed_regexp_capture_types.rb#25
RuboCop::Cop::Lint::MixedRegexpCaptureTypes::MSG = T.let(T.unsafe(nil), String)

# In math and Python, we can use `x < y < z` style comparison to compare
# multiple value. However, we can't use the comparison in Ruby. However,
# the comparison is not syntax error. This cop checks the bad usage of
# comparison operators.
#
# @example
#
#   # bad
#   x < y < z
#   10 <= x <= 20
#
#   # good
#   x < y && y < z
#   10 <= x && x <= 20
#
# source://rubocop//lib/rubocop/cop/lint/multiple_comparison.rb#20
class RuboCop::Cop::Lint::MultipleComparison < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/multiple_comparison.rb#29
  def multiple_compare?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/multiple_comparison.rb#33
  def on_send(node); end
end

# source://rubocop//lib/rubocop/cop/lint/multiple_comparison.rb#24
RuboCop::Cop::Lint::MultipleComparison::COMPARISON_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/multiple_comparison.rb#23
RuboCop::Cop::Lint::MultipleComparison::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/multiple_comparison.rb#26
RuboCop::Cop::Lint::MultipleComparison::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/multiple_comparison.rb#25
RuboCop::Cop::Lint::MultipleComparison::SET_OPERATION_OPERATORS = T.let(T.unsafe(nil), Array)

# Checks for nested method definitions.
#
# @example AllowedPatterns: ['baz']
#   # good
#   def foo(obj)
#   obj.do_baz do
#   def bar
#   end
#   end
#   end
# @example
#
#   # good
#
#   def foo
#   bar = -> { puts 'hello' }
#   bar.call
#   end
# @example
#
#   # good
#
#   # `class_eval`, `instance_eval`, `module_eval`, `class_exec`, `instance_exec`, and
#   # `module_exec` blocks are allowed by default.
#
#   def foo
#   self.class.class_eval do
#   def bar
#   end
#   end
#   end
#
#   def foo
#   self.class.module_exec do
#   def bar
#   end
#   end
#   end
# @example
#
#   # good
#
#   def foo
#   class << self
#   def bar
#   end
#   end
#   end
# @example AllowedMethods: [] (default)
#   # bad
#   def do_something
#   has_many :articles do
#   def find_or_create_by_name(name)
#   end
#   end
#   end
# @example AllowedMethods: ['has_many']
#   # bad
#   def do_something
#   has_many :articles do
#   def find_or_create_by_name(name)
#   end
#   end
#   end
# @example AllowedPatterns: [] (default)
#   # bad
#   def foo(obj)
#   obj.do_baz do
#   def bar
#   end
#   end
#   end
# @example
#
#   # bad
#
#   # `bar` definition actually produces methods in the same scope
#   # as the outer `foo` method. Furthermore, the `bar` method
#   # will be redefined every time `foo` is invoked.
#   def foo
#   def bar
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/lint/nested_method_definition.rb#97
class RuboCop::Cop::Lint::NestedMethodDefinition < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::AllowedPattern

  # source://rubocop//lib/rubocop/cop/lint/nested_method_definition.rb#133
  def eval_call?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/nested_method_definition.rb#138
  def exec_call?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/nested_method_definition.rb#103
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/lint/nested_method_definition.rb#103
  def on_defs(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/nested_method_definition.rb#126
  def allowed_method_name?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/nested_method_definition.rb#121
  def scoping_method_call?(child); end
end

# source://rubocop//lib/rubocop/cop/lint/nested_method_definition.rb#101
RuboCop::Cop::Lint::NestedMethodDefinition::MSG = T.let(T.unsafe(nil), String)

# Checks for nested percent literals.
#
# @example
#
#   # bad
#
#   # The percent literal for nested_attributes is parsed as four tokens,
#   # yielding the array [:name, :content, :"%i[incorrectly", :"nested]"].
#   attributes = {
#   valid_attributes: %i[name content],
#   nested_attributes: %i[name content %i[incorrectly nested]]
#   }
#
#   # good
#
#   # Neither is incompatible with the bad case, but probably the intended code.
#   attributes = {
#   valid_attributes: %i[name content],
#   nested_attributes: [:name, :content, %i[incorrectly nested]]
#   }
#
#   attributes = {
#   valid_attributes: %i[name content],
#   nested_attributes: [:name, :content, [:incorrectly, :nested]]
#   }
#
# source://rubocop//lib/rubocop/cop/lint/nested_percent_literal.rb#32
class RuboCop::Cop::Lint::NestedPercentLiteral < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::PercentLiteral

  # source://rubocop//lib/rubocop/cop/lint/nested_percent_literal.rb#44
  def on_array(node); end

  # source://rubocop//lib/rubocop/cop/lint/nested_percent_literal.rb#48
  def on_percent_literal(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/nested_percent_literal.rb#54
  def contains_percent_literals?(node); end
end

# source://rubocop//lib/rubocop/cop/lint/nested_percent_literal.rb#35
RuboCop::Cop::Lint::NestedPercentLiteral::MSG = T.let(T.unsafe(nil), String)

# The array of regular expressions representing percent literals that,
# if found within a percent literal expression, will cause a
# NestedPercentLiteral violation to be emitted.
#
# source://rubocop//lib/rubocop/cop/lint/nested_percent_literal.rb#41
RuboCop::Cop::Lint::NestedPercentLiteral::PERCENT_LITERAL_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/nested_percent_literal.rb#42
RuboCop::Cop::Lint::NestedPercentLiteral::REGEXES = T.let(T.unsafe(nil), Array)

# Don't omit the accumulator when calling `next` in a `reduce` block.
#
# @example
#
#   # bad
#
#   result = (1..4).reduce(0) do |acc, i|
#   next if i.odd?
#   acc + i
#   end
# @example
#
#   # good
#
#   result = (1..4).reduce(0) do |acc, i|
#   next acc if i.odd?
#   acc + i
#   end
#
# source://rubocop//lib/rubocop/cop/lint/next_without_accumulator.rb#25
class RuboCop::Cop::Lint::NextWithoutAccumulator < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/lint/next_without_accumulator.rb#28
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/lint/next_without_accumulator.rb#51
  def on_block_body_of_reduce(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/next_without_accumulator.rb#38
  def on_numblock(node); end

  # source://rubocop//lib/rubocop/cop/lint/next_without_accumulator.rb#56
  def on_numblock_body_of_reduce(param0 = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/lint/next_without_accumulator.rb#60
  def parent_block_node(node); end

  # source://rubocop//lib/rubocop/cop/lint/next_without_accumulator.rb#64
  def parent_numblock_node(node); end
end

# source://rubocop//lib/rubocop/cop/lint/next_without_accumulator.rb#26
RuboCop::Cop::Lint::NextWithoutAccumulator::MSG = T.let(T.unsafe(nil), String)

# Checks for the presence of a `return` inside a `begin..end` block
# in assignment contexts.
# In this situation, the `return` will result in an exit from the current
# method, possibly leading to unexpected behavior.
#
# @example
#
#   # bad
#
#   @some_variable ||= begin
#   return some_value if some_condition_is_met
#
#   do_something
#   end
# @example
#
#   # good
#
#   @some_variable ||= begin
#   if some_condition_is_met
#   some_value
#   else
#   do_something
#   end
#   end
#
#   # good
#
#   some_variable = if some_condition_is_met
#   return if another_condition_is_met
#
#   some_value
#   else
#   do_something
#   end
#
# source://rubocop//lib/rubocop/cop/lint/no_return_in_begin_end_blocks.rb#43
class RuboCop::Cop::Lint::NoReturnInBeginEndBlocks < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/lint/no_return_in_begin_end_blocks.rb#46
  def on_lvasgn(node); end

  # source://rubocop//lib/rubocop/cop/lint/no_return_in_begin_end_blocks.rb#46
  def on_op_asgn(node); end

  # source://rubocop//lib/rubocop/cop/lint/no_return_in_begin_end_blocks.rb#46
  def on_or_asgn(node); end
end

# source://rubocop//lib/rubocop/cop/lint/no_return_in_begin_end_blocks.rb#44
RuboCop::Cop::Lint::NoReturnInBeginEndBlocks::MSG = T.let(T.unsafe(nil), String)

# Checks for non-atomic file operation.
# And then replace it with a nearly equivalent and atomic method.
#
# These can cause problems that are difficult to reproduce,
# especially in cases of frequent file operations in parallel,
# such as test runs with parallel_rspec.
#
# For examples: creating a directory if there is none, has the following problems
#
# An exception occurs when the directory didn't exist at the time of `exist?`,
# but someone else created it before `mkdir` was executed.
#
# Subsequent processes are executed without the directory that should be there
# when the directory existed at the time of `exist?`,
# but someone else deleted it shortly afterwards.
#
# @example
#   # bad - race condition with another process may result in an error in `mkdir`
#   unless Dir.exist?(path)
#   FileUtils.mkdir(path)
#   end
#
#   # good - atomic and idempotent creation
#   FileUtils.mkdir_p(path)
#
#   # bad - race condition with another process may result in an error in `remove`
#   if File.exist?(path)
#   FileUtils.remove(path)
#   end
#
#   # good - atomic and idempotent removal
#   FileUtils.rm_f(path)
#
# source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#44
class RuboCop::Cop::Lint::NonAtomicFileOperation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#75
  def explicit_not_force?(param0); end

  # source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#70
  def force?(param0); end

  # source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#79
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#65
  def receiver_and_method_name(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#60
  def send_exist_node(param0); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#96
  def allowable_use_with_if?(if_node); end

  # source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#120
  def autocorrect(corrector, node, range); end

  # source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#131
  def autocorrect_replace_method(corrector, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#148
  def force_method?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#156
  def force_method_name?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#152
  def force_option?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#90
  def if_node_child?(node); end

  # source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#111
  def message_change_force_method(node); end

  # source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#115
  def message_remove_file_exist_check(node); end

  # source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#100
  def register_offense(node, exist_node); end

  # source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#138
  def replacement_method(node); end
end

# source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#51
RuboCop::Cop::Lint::NonAtomicFileOperation::MAKE_FORCE_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#52
RuboCop::Cop::Lint::NonAtomicFileOperation::MAKE_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#50
RuboCop::Cop::Lint::NonAtomicFileOperation::MSG_CHANGE_FORCE_METHOD = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#48
RuboCop::Cop::Lint::NonAtomicFileOperation::MSG_REMOVE_FILE_EXIST_CHECK = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#53
RuboCop::Cop::Lint::NonAtomicFileOperation::REMOVE_FORCE_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#54
RuboCop::Cop::Lint::NonAtomicFileOperation::REMOVE_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#56
RuboCop::Cop::Lint::NonAtomicFileOperation::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# `Dir[...]` and `Dir.glob(...)` do not make any guarantees about
# the order in which files are returned. The final order is
# determined by the operating system and file system.
# This means that using them in cases where the order matters,
# such as requiring files, can lead to intermittent failures
# that are hard to debug. To ensure this doesn't happen,
# always sort the list.
#
# `Dir.glob` and `Dir[]` sort globbed results by default in Ruby 3.0.
# So all bad cases are acceptable when Ruby 3.0 or higher are used.
#
# NOTE: This cop will be deprecated and removed when supporting only Ruby 3.0 and higher.
#
# @example
#
#   # bad
#   Dir["./lib/**/*.rb"].each do |file|
#   require file
#   end
#
#   # good
#   Dir["./lib/**/*.rb"].sort.each do |file|
#   require file
#   end
#
#   # bad
#   Dir.glob(Rails.root.join(__dir__, 'test', '*.rb')) do |file|
#   require file
#   end
#
#   # good
#   Dir.glob(Rails.root.join(__dir__, 'test', '*.rb')).sort.each do |file|
#   require file
#   end
#
#   # bad
#   Dir['./lib/**/*.rb'].each(&method(:require))
#
#   # good
#   Dir['./lib/**/*.rb'].sort.each(&method(:require))
#
#   # bad
#   Dir.glob(Rails.root.join('test', '*.rb'), &method(:require))
#
#   # good
#   Dir.glob(Rails.root.join('test', '*.rb')).sort.each(&method(:require))
#
#   # good - Respect intent if `sort` keyword option is specified in Ruby 3.0 or higher.
#   Dir.glob(Rails.root.join(__dir__, 'test', '*.rb'), sort: false).each(&method(:require))
#
# source://rubocop//lib/rubocop/cop/lint/non_deterministic_require_order.rb#60
class RuboCop::Cop::Lint::NonDeterministicRequireOrder < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/non_deterministic_require_order.rb#174
  def loop_variable(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/non_deterministic_require_order.rb#157
  def method_require?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/non_deterministic_require_order.rb#65
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/lint/non_deterministic_require_order.rb#89
  def on_block_pass(node); end

  # source://rubocop//lib/rubocop/cop/lint/non_deterministic_require_order.rb#77
  def on_numblock(node); end

  # source://rubocop//lib/rubocop/cop/lint/non_deterministic_require_order.rb#147
  def unsorted_dir_block?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/non_deterministic_require_order.rb#152
  def unsorted_dir_each?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/non_deterministic_require_order.rb#168
  def unsorted_dir_each_pass?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/non_deterministic_require_order.rb#162
  def unsorted_dir_glob_pass?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/non_deterministic_require_order.rb#179
  def var_is_required?(param0, param1); end

  private

  # source://rubocop//lib/rubocop/cop/lint/non_deterministic_require_order.rb#107
  def correct_block(corrector, node); end

  # source://rubocop//lib/rubocop/cop/lint/non_deterministic_require_order.rb#117
  def correct_block_pass(corrector, node); end

  # Returns range of last argument including comma and whitespace.
  #
  # @return [Parser::Source::Range]
  #
  # source://rubocop//lib/rubocop/cop/lint/non_deterministic_require_order.rb#132
  def last_arg_range(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/non_deterministic_require_order.rb#138
  def unsorted_dir_loop?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/non_deterministic_require_order.rb#142
  def unsorted_dir_pass?(node); end
end

# source://rubocop//lib/rubocop/cop/lint/non_deterministic_require_order.rb#63
RuboCop::Cop::Lint::NonDeterministicRequireOrder::MSG = T.let(T.unsafe(nil), String)

# Checks for non-local exits from iterators without a return
# value. It registers an offense under these conditions:
#
# * No value is returned,
# * the block is preceded by a method chain,
# * the block has arguments,
# * the method which receives the block is not `define_method`
# or `define_singleton_method`,
# * the return is not contained in an inner scope, e.g. a lambda or a
# method definition.
#
# @example
#
#   class ItemApi
#   rescue_from ValidationError do |e| # non-iteration block with arg
#   return { message: 'validation error' } unless e.errors # allowed
#   error_array = e.errors.map do |error| # block with method chain
#   return if error.suppress? # warned
#   return "#{error.param}: invalid" unless error.message # allowed
#   "#{error.param}: #{error.message}"
#   end
#   { message: 'validation error', errors: error_array }
#   end
#
#   def update_items
#   transaction do # block without arguments
#   return unless update_necessary? # allowed
#   find_each do |item| # block without method chain
#   return if item.stock == 0 # false-negative...
#   item.update!(foobar: true)
#   end
#   end
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/lint/non_local_exit_from_iterator.rb#41
class RuboCop::Cop::Lint::NonLocalExitFromIterator < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/lint/non_local_exit_from_iterator.rb#77
  def chained_send?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/non_local_exit_from_iterator.rb#80
  def define_method?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/non_local_exit_from_iterator.rb#46
  def on_return(return_node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/non_local_exit_from_iterator.rb#72
  def return_value?(return_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/non_local_exit_from_iterator.rb#68
  def scoped_node?(node); end
end

# source://rubocop//lib/rubocop/cop/lint/non_local_exit_from_iterator.rb#42
RuboCop::Cop::Lint::NonLocalExitFromIterator::MSG = T.let(T.unsafe(nil), String)

# Warns the usage of unsafe number conversions. Unsafe
# number conversion can cause unexpected error if auto type conversion
# fails. Cop prefer parsing with number class instead.
#
# Conversion with `Integer`, `Float`, etc. will raise an `ArgumentError`
# if given input that is not numeric (eg. an empty string), whereas
# `to_i`, etc. will try to convert regardless of input (`''.to_i => 0`).
# As such, this cop is disabled by default because it's not necessarily
# always correct to raise if a value is not numeric.
#
# NOTE: Some values cannot be converted properly using one of the `Kernel`
# method (for instance, `Time` and `DateTime` values are allowed by this
# cop by default). Similarly, Rails' duration methods do not work well
# with `Integer()` and can be allowed with `AllowedMethods`. By default,
# there are no methods to allowed.
#
# @example
#
#   # bad
#
#   '10'.to_i
#   '10.2'.to_f
#   '10'.to_c
#   '1/3'.to_r
#   ['1', '2', '3'].map(&:to_i)
#   foo.try(:to_f)
#   bar.send(:to_c)
#
#   # good
#
#   Integer('10', 10)
#   Float('10.2')
#   Complex('10')
#   Rational('1/3')
#   ['1', '2', '3'].map { |i| Integer(i, 10) }
#   foo.try { |i| Float(i) }
#   bar.send { |i| Complex(i) }
# @example AllowedMethods: [] (default)
#
#   # bad
#   10.minutes.to_i
# @example AllowedMethods: [minutes]
#
#   # good
#   10.minutes.to_i
# @example AllowedPatterns: [] (default)
#
#   # bad
#   10.minutes.to_i
# @example AllowedPatterns: ['min*']
#
#   # good
#   10.minutes.to_i
# @example IgnoredClasses: [Time, DateTime] (default)
#
#   # good
#   Time.now.to_datetime.to_i
#
# source://rubocop//lib/rubocop/cop/lint/number_conversion.rb#73
class RuboCop::Cop::Lint::NumberConversion < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::AllowedPattern
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/number_conversion.rb#102
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/lint/number_conversion.rb#92
  def to_method(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/number_conversion.rb#97
  def to_method_symbol(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/number_conversion.rb#155
  def allow_receiver?(receiver); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/number_conversion.rb#167
  def allowed_method_name?(name); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/number_conversion.rb#177
  def conversion_method?(method_name); end

  # source://rubocop//lib/rubocop/cop/lint/number_conversion.rb#141
  def correct_method(node, receiver); end

  # source://rubocop//lib/rubocop/cop/lint/number_conversion.rb#145
  def correct_sym_method(to_method); end

  # source://rubocop//lib/rubocop/cop/lint/number_conversion.rb#124
  def handle_as_symbol(node); end

  # source://rubocop//lib/rubocop/cop/lint/number_conversion.rb#109
  def handle_conversion_method(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/number_conversion.rb#185
  def ignored_class?(name); end

  # source://rubocop//lib/rubocop/cop/lint/number_conversion.rb#181
  def ignored_classes; end

  # source://rubocop//lib/rubocop/cop/lint/number_conversion.rb#150
  def remove_parentheses(corrector, node); end

  # source://rubocop//lib/rubocop/cop/lint/number_conversion.rb#171
  def top_receiver(node); end
end

# source://rubocop//lib/rubocop/cop/lint/number_conversion.rb#88
RuboCop::Cop::Lint::NumberConversion::CONVERSION_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/number_conversion.rb#78
RuboCop::Cop::Lint::NumberConversion::CONVERSION_METHOD_CLASS_MAPPING = T.let(T.unsafe(nil), Hash)

# source://rubocop//lib/rubocop/cop/lint/number_conversion.rb#89
RuboCop::Cop::Lint::NumberConversion::METHODS = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/number_conversion.rb#84
RuboCop::Cop::Lint::NumberConversion::MSG = T.let(T.unsafe(nil), String)

# Checks for uses of numbered parameter assignment.
# It emulates the following warning in Ruby 2.7:
#
#   % ruby -ve '_1 = :value'
#   ruby 2.7.2p137 (2020-10-01 revision 5445e04352) [x86_64-darwin19]
#   -e:1: warning: `_1' is reserved for numbered parameter; consider another name
#
# Assigning to a numbered parameter (from `_1` to `_9`) causes an error in Ruby 3.0.
#
#   % ruby -ve '_1 = :value'
#   ruby 3.0.0p0 (2020-12-25 revision 95aff21468) [x86_64-darwin19]
#   -e:1: _1 is reserved for numbered parameter
#
# NOTE: The parametered parameters are from `_1` to `_9`. This cop checks `_0`, and over `_10`
# as well to prevent confusion.
#
# @example
#
#   # bad
#   _1 = :value
#
#   # good
#   non_numbered_parameter_name = :value
#
# source://rubocop//lib/rubocop/cop/lint/numbered_parameter_assignment.rb#30
class RuboCop::Cop::Lint::NumberedParameterAssignment < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/lint/numbered_parameter_assignment.rb#35
  def on_lvasgn(node); end
end

# source://rubocop//lib/rubocop/cop/lint/numbered_parameter_assignment.rb#32
RuboCop::Cop::Lint::NumberedParameterAssignment::LVAR_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/numbered_parameter_assignment.rb#33
RuboCop::Cop::Lint::NumberedParameterAssignment::NUMBERED_PARAMETER_RANGE = T.let(T.unsafe(nil), Range)

# source://rubocop//lib/rubocop/cop/lint/numbered_parameter_assignment.rb#31
RuboCop::Cop::Lint::NumberedParameterAssignment::NUM_PARAM_MSG = T.let(T.unsafe(nil), String)

# Checks for unintended or-assignment to a constant.
#
# Constants should always be assigned in the same location. And its value
# should always be the same. If constants are assigned in multiple
# locations, the result may vary depending on the order of `require`.
#
# @example
#
#   # bad
#   CONST ||= 1
#
#   # good
#   CONST = 1
#
# source://rubocop//lib/rubocop/cop/lint/or_assignment_to_constant.rb#24
class RuboCop::Cop::Lint::OrAssignmentToConstant < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/or_assignment_to_constant.rb#29
  def on_or_asgn(node); end
end

# source://rubocop//lib/rubocop/cop/lint/or_assignment_to_constant.rb#27
RuboCop::Cop::Lint::OrAssignmentToConstant::MSG = T.let(T.unsafe(nil), String)

# Checks the proper ordering of magic comments and whether
# a magic comment is not placed before a shebang.
#
# @example
#   # bad
#
#   # frozen_string_literal: true
#   # encoding: ascii
#   p [''.frozen?, ''.encoding] #=> [true, #<Encoding:UTF-8>]
#
#   # good
#
#   # encoding: ascii
#   # frozen_string_literal: true
#   p [''.frozen?, ''.encoding] #=> [true, #<Encoding:US-ASCII>]
#
#   # good
#
#   #!/usr/bin/env ruby
#   # encoding: ascii
#   # frozen_string_literal: true
#   p [''.frozen?, ''.encoding] #=> [true, #<Encoding:US-ASCII>]
#
# source://rubocop//lib/rubocop/cop/lint/ordered_magic_comments.rb#33
class RuboCop::Cop::Lint::OrderedMagicComments < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::FrozenStringLiteral
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/ordered_magic_comments.rb#39
  def on_new_investigation; end

  private

  # source://rubocop//lib/rubocop/cop/lint/ordered_magic_comments.rb#56
  def autocorrect(corrector, encoding_line, frozen_string_literal_line); end

  # source://rubocop//lib/rubocop/cop/lint/ordered_magic_comments.rb#64
  def magic_comment_lines; end
end

# source://rubocop//lib/rubocop/cop/lint/ordered_magic_comments.rb#37
RuboCop::Cop::Lint::OrderedMagicComments::MSG = T.let(T.unsafe(nil), String)

# Looks for references of Regexp captures that are out of range
# and thus always returns nil.
#
# @example
#
#   /(foo)bar/ =~ 'foobar'
#
#   # bad - always returns nil
#
#   puts $2 # => nil
#
#   # good
#
#   puts $1 # => foo
#
# source://rubocop//lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#38
class RuboCop::Cop::Lint::OutOfRangeRegexpRef < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#55
  def after_send(node); end

  # source://rubocop//lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#71
  def on_in_pattern(node); end

  # source://rubocop//lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#51
  def on_match_with_lvasgn(node); end

  # source://rubocop//lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#47
  def on_new_investigation; end

  # source://rubocop//lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#77
  def on_nth_ref(node); end

  # source://rubocop//lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#65
  def on_when(node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#102
  def check_regexp(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#122
  def nth_ref_receiver?(send_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#113
  def regexp_first_argument?(send_node); end

  # source://rubocop//lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#93
  def regexp_patterns(in_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#118
  def regexp_receiver?(send_node); end
end

# source://rubocop//lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#39
RuboCop::Cop::Lint::OutOfRangeRegexpRef::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#42
RuboCop::Cop::Lint::OutOfRangeRegexpRef::REGEXP_ARGUMENT_METHODS = T.let(T.unsafe(nil), Set)

# source://rubocop//lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#44
RuboCop::Cop::Lint::OutOfRangeRegexpRef::REGEXP_CAPTURE_METHODS = T.let(T.unsafe(nil), Set)

# source://rubocop//lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#41
RuboCop::Cop::Lint::OutOfRangeRegexpRef::REGEXP_RECEIVER_METHODS = T.let(T.unsafe(nil), Set)

# source://rubocop//lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#45
RuboCop::Cop::Lint::OutOfRangeRegexpRef::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Set)

# Checks for space between the name of a called method and a left
# parenthesis.
#
# @example
#
#   # bad
#   do_something (foo)
#
#   # good
#   do_something(foo)
#   do_something (2 + 3) * 4
#   do_something (foo * bar).baz
#
# source://rubocop//lib/rubocop/cop/lint/parentheses_as_grouped_expression.rb#18
class RuboCop::Cop::Lint::ParenthesesAsGroupedExpression < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/parentheses_as_grouped_expression.rb#24
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/lint/parentheses_as_grouped_expression.rb#24
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/parentheses_as_grouped_expression.rb#61
  def chained_calls?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/parentheses_as_grouped_expression.rb#49
  def first_argument_block_type?(first_arg); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/parentheses_as_grouped_expression.rb#57
  def first_argument_starts_with_left_parenthesis?(node); end

  # source://rubocop//lib/rubocop/cop/lint/parentheses_as_grouped_expression.rb#86
  def space_range(expr, space_length); end

  # source://rubocop//lib/rubocop/cop/lint/parentheses_as_grouped_expression.rb#70
  def spaces_before_left_parenthesis(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/parentheses_as_grouped_expression.rb#66
  def ternary_expression?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/parentheses_as_grouped_expression.rb#39
  def valid_context?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/parentheses_as_grouped_expression.rb#53
  def valid_first_argument?(first_arg); end
end

# source://rubocop//lib/rubocop/cop/lint/parentheses_as_grouped_expression.rb#22
RuboCop::Cop::Lint::ParenthesesAsGroupedExpression::MSG = T.let(T.unsafe(nil), String)

# Checks for quotes and commas in %w, e.g. `%w('foo', "bar")`
#
# It is more likely that the additional characters are unintended (for
# example, mistranslating an array of literals to percent string notation)
# rather than meant to be part of the resulting strings.
#
# @example
#
#   # bad
#
#   %w('foo', "bar")
# @example
#
#   # good
#
#   %w(foo bar)
#
# source://rubocop//lib/rubocop/cop/lint/percent_string_array.rb#33
class RuboCop::Cop::Lint::PercentStringArray < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::PercentLiteral
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/percent_string_array.rb#44
  def on_array(node); end

  # source://rubocop//lib/rubocop/cop/lint/percent_string_array.rb#48
  def on_percent_literal(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/percent_string_array.rb#65
  def contains_quotes_or_commas?(node); end
end

# source://rubocop//lib/rubocop/cop/lint/percent_string_array.rb#38
RuboCop::Cop::Lint::PercentStringArray::LEADING_QUOTE = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/lint/percent_string_array.rb#41
RuboCop::Cop::Lint::PercentStringArray::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/percent_string_array.rb#37
RuboCop::Cop::Lint::PercentStringArray::QUOTES_AND_COMMAS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/percent_string_array.rb#39
RuboCop::Cop::Lint::PercentStringArray::TRAILING_QUOTE = T.let(T.unsafe(nil), Regexp)

# Checks for colons and commas in %i, e.g. `%i(:foo, :bar)`
#
# It is more likely that the additional characters are unintended (for
# example, mistranslating an array of literals to percent string notation)
# rather than meant to be part of the resulting symbols.
#
# @example
#
#   # bad
#
#   %i(:foo, :bar)
# @example
#
#   # good
#
#   %i(foo bar)
#
# source://rubocop//lib/rubocop/cop/lint/percent_symbol_array.rb#23
class RuboCop::Cop::Lint::PercentSymbolArray < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::PercentLiteral
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/percent_symbol_array.rb#30
  def on_array(node); end

  # source://rubocop//lib/rubocop/cop/lint/percent_symbol_array.rb#34
  def on_percent_literal(node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/percent_symbol_array.rb#42
  def autocorrect(corrector, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/percent_symbol_array.rb#52
  def contains_colons_or_commas?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/percent_symbol_array.rb#62
  def non_alphanumeric_literal?(literal); end
end

# source://rubocop//lib/rubocop/cop/lint/percent_symbol_array.rb#27
RuboCop::Cop::Lint::PercentSymbolArray::MSG = T.let(T.unsafe(nil), String)

# Checks for `raise` or `fail` statements which are
# raising `Exception` class.
#
# You can specify a module name that will be an implicit namespace
# using `AllowedImplicitNamespaces` option. The cop cause a false positive
# for namespaced `Exception` when a namespace is omitted. This option can
# prevent the false positive by specifying a namespace to be omitted for
# `Exception`. Alternatively, make `Exception` a fully qualified class
# name with an explicit namespace.
#
# @example
#   # bad
#   raise Exception, 'Error message here'
#
#   # good
#   raise StandardError, 'Error message here'
# @example AllowedImplicitNamespaces: ['Gem']
#   # good
#   module Gem
#   def self.foo
#   raise Exception # This exception means `Gem::Exception`.
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/lint/raise_exception.rb#34
class RuboCop::Cop::Lint::RaiseException < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/raise_exception.rb#41
  def exception?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/raise_exception.rb#46
  def exception_new_with_message?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/raise_exception.rb#51
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/raise_exception.rb#85
  def allow_implicit_namespaces; end

  # source://rubocop//lib/rubocop/cop/lint/raise_exception.rb#57
  def check(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/raise_exception.rb#73
  def implicit_namespace?(node); end
end

# source://rubocop//lib/rubocop/cop/lint/raise_exception.rb#37
RuboCop::Cop::Lint::RaiseException::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/raise_exception.rb#38
RuboCop::Cop::Lint::RaiseException::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for `rand(1)` calls.
# Such calls always return `0`.
#
# @example
#
#   # bad
#
#   rand 1
#   Kernel.rand(-1)
#   rand 1.0
#   rand(-1.0)
# @example
#
#   # good
#
#   0 # just use 0 instead
#
# source://rubocop//lib/rubocop/cop/lint/rand_one.rb#23
class RuboCop::Cop::Lint::RandOne < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/lint/rand_one.rb#32
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/lint/rand_one.rb#28
  def rand_one?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/lint/rand_one.rb#40
  def message(node); end
end

# source://rubocop//lib/rubocop/cop/lint/rand_one.rb#24
RuboCop::Cop::Lint::RandOne::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/rand_one.rb#25
RuboCop::Cop::Lint::RandOne::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# removed without causing any offenses to be reported. It's implemented
# as a cop in that it inherits from the Cop base class and calls
# add_offense. The unusual part of its implementation is that it doesn't
# have any on_* methods or an investigate method. This means that it
# doesn't take part in the investigation phase when the other cops do
# their work. Instead, it waits until it's called in a later stage of the
# execution. The reason it can't be implemented as a normal cop is that
# it depends on the results of all other cops to do its work.
#
# @example
#   # bad
#   # rubocop:disable Layout/LineLength
#   x += 1
#   # rubocop:enable Layout/LineLength
#
#   # good
#   x += 1
#
# source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#28
class RuboCop::Cop::Lint::RedundantCopDisableDirective < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # @return [RedundantCopDisableDirective] a new instance of RedundantCopDisableDirective
  #
  # source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#37
  def initialize(config = T.unsafe(nil), options = T.unsafe(nil), offenses = T.unsafe(nil)); end

  # Returns the value of attribute offenses_to_check.
  #
  # source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#35
  def offenses_to_check; end

  # Sets the attribute offenses_to_check
  #
  # @param value the value to set the attribute offenses_to_check to.
  #
  # source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#35
  def offenses_to_check=(_arg0); end

  # source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#42
  def on_new_investigation; end

  private

  # source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#323
  def add_department_marker(department); end

  # source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#229
  def add_offense_for_entire_comment(comment, cops); end

  # source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#244
  def add_offense_for_some_cops(comment, cops); end

  # source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#219
  def add_offenses(redundant_cops); end

  # source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#306
  def all_cop_names; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#190
  def all_disabled?(comment); end

  # source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#69
  def comment_range_with_surrounding_space(directive_comment_range, line_comment_range); end

  # source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#57
  def cop_disabled_line_ranges; end

  # source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#264
  def cop_range(comment, cop); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#210
  def department_disabled?(cop, comment); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#315
  def department_marker?(department); end

  # source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#293
  def describe(cop); end

  # source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#215
  def directive_count(comment); end

  # source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#92
  def directive_range_in_list(range, ranges); end

  # source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#61
  def disabled_ranges; end

  # source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#132
  def each_already_disabled(cop, line_ranges); end

  # source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#113
  def each_line_range(cop, line_ranges); end

  # source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#106
  def each_redundant_disable(&block); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#310
  def ends_its_line?(range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#202
  def expected_final_disable?(cop, line_range); end

  # source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#166
  def find_redundant_all(range, next_range); end

  # source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#161
  def find_redundant_cop(cop, range); end

  # source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#176
  def find_redundant_department(cop, range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#182
  def followed_ranges?(range, next_range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#194
  def ignore_offense?(line_range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#258
  def leave_free_comment?(comment, range); end

  # source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#271
  def matching_range(haystack, needle); end

  # source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#302
  def message(cop_names); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#65
  def previous_line_blank?(range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#186
  def range_with_offense?(range, offenses = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#319
  def remove_department_marker(department); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#279
  def trailing_range?(ranges, range); end
end

# source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#32
RuboCop::Cop::Lint::RedundantCopDisableDirective::COP_NAME = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#33
RuboCop::Cop::Lint::RedundantCopDisableDirective::DEPARTMENT_MARKER = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#287
RuboCop::Cop::Lint::RedundantCopDisableDirective::SIMILAR_COP_NAMES_CACHE = T.let(T.unsafe(nil), Hash)

# removed.
#
# that cop checks whether any cop was actually enabled.
#
# @example
#   # bad
#   foo = 1
#   # rubocop:enable Layout/LineLength
#
#   # good
#   foo = 1
# @example
#   # bad
#   # rubocop:disable Style/StringLiterals
#   foo = "1"
#   # rubocop:enable Style/StringLiterals
#   baz
#   # rubocop:enable all
#
#   # good
#   # rubocop:disable Style/StringLiterals
#   foo = "1"
#   # rubocop:enable all
#   baz
#
# source://rubocop//lib/rubocop/cop/lint/redundant_cop_enable_directive.rb#37
class RuboCop::Cop::Lint::RedundantCopEnableDirective < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SurroundingSpace
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/redundant_cop_enable_directive.rb#44
  def on_new_investigation; end

  private

  # source://rubocop//lib/rubocop/cop/lint/redundant_cop_enable_directive.rb#120
  def all_or_name(name); end

  # source://rubocop//lib/rubocop/cop/lint/redundant_cop_enable_directive.rb#76
  def comment_start(comment); end

  # source://rubocop//lib/rubocop/cop/lint/redundant_cop_enable_directive.rb#80
  def cop_name_indention(comment, name); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/redundant_cop_enable_directive.rb#124
  def department?(directive, name); end

  # source://rubocop//lib/rubocop/cop/lint/redundant_cop_enable_directive.rb#71
  def range_of_offense(comment, name); end

  # source://rubocop//lib/rubocop/cop/lint/redundant_cop_enable_directive.rb#95
  def range_to_remove(begin_pos, end_pos, comment); end

  # source://rubocop//lib/rubocop/cop/lint/redundant_cop_enable_directive.rb#84
  def range_with_comma(comment, name); end

  # If the list of cops is comma-separated, but without a empty space after the comma,
  # we should **not** remove the prepending empty space, thus begin_pos += 1
  #
  # source://rubocop//lib/rubocop/cop/lint/redundant_cop_enable_directive.rb#114
  def range_with_comma_after(comment, start, begin_pos, end_pos); end

  # source://rubocop//lib/rubocop/cop/lint/redundant_cop_enable_directive.rb#108
  def range_with_comma_before(start, begin_pos, end_pos); end

  # source://rubocop//lib/rubocop/cop/lint/redundant_cop_enable_directive.rb#53
  def register_offense(comment, cop_names); end
end

# source://rubocop//lib/rubocop/cop/lint/redundant_cop_enable_directive.rb#42
RuboCop::Cop::Lint::RedundantCopEnableDirective::MSG = T.let(T.unsafe(nil), String)

# Sort globbed results by default in Ruby 3.0.
# This cop checks for redundant `sort` method to `Dir.glob` and `Dir[]`.
#
# @example
#
#   # bad
#   Dir.glob('./lib/**/*.rb').sort.each do |file|
#   end
#
#   Dir['./lib/**/*.rb'].sort.each do |file|
#   end
#
#   # good
#   Dir.glob('./lib/**/*.rb').each do |file|
#   end
#
#   Dir['./lib/**/*.rb'].each do |file|
#   end
#
# source://rubocop//lib/rubocop/cop/lint/redundant_dir_glob_sort.rb#30
class RuboCop::Cop::Lint::RedundantDirGlobSort < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop//lib/rubocop/cop/lint/redundant_dir_glob_sort.rb#40
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/redundant_dir_glob_sort.rb#56
  def multiple_argument?(glob_method); end
end

# source://rubocop//lib/rubocop/cop/lint/redundant_dir_glob_sort.rb#38
RuboCop::Cop::Lint::RedundantDirGlobSort::GLOB_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/redundant_dir_glob_sort.rb#36
RuboCop::Cop::Lint::RedundantDirGlobSort::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/redundant_dir_glob_sort.rb#37
RuboCop::Cop::Lint::RedundantDirGlobSort::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for unnecessary `require` statement.
#
# The following features are unnecessary `require` statement because
# they are already loaded. e.g. Ruby 2.2:
#
#   ruby -ve 'p $LOADED_FEATURES.reject { |feature| %r|/| =~ feature }'
#   ruby 2.2.8p477 (2017-09-14 revision 59906) [x86_64-darwin13]
#   ["enumerator.so", "rational.so", "complex.so", "thread.rb"]
#
# Below are the features that each `TargetRubyVersion` targets.
#
#   * 2.0+ ... `enumerator`
#   * 2.1+ ... `thread`
#   * 2.2+ ... Add `rational` and `complex` above
#   * 2.5+ ... Add `pp` above
#   * 2.7+ ... Add `ruby2_keywords` above
#   * 3.1+ ... Add `fiber` above
#   * 3.2+ ... `set`
#
# This cop target those features.
#
# @example
#   # bad
#   require 'unloaded_feature'
#   require 'thread'
#
#   # good
#   require 'unloaded_feature'
#
# source://rubocop//lib/rubocop/cop/lint/redundant_require_statement.rb#34
class RuboCop::Cop::Lint::RedundantRequireStatement < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/redundant_require_statement.rb#52
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/lint/redundant_require_statement.rb#47
  def redundant_require_statement?(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/redundant_require_statement.rb#71
  def redundant_feature?(feature_name); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/redundant_require_statement.rb#82
  def use_pretty_print_method?; end
end

# source://rubocop//lib/rubocop/cop/lint/redundant_require_statement.rb#38
RuboCop::Cop::Lint::RedundantRequireStatement::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/redundant_require_statement.rb#41
RuboCop::Cop::Lint::RedundantRequireStatement::PRETTY_PRINT_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/redundant_require_statement.rb#39
RuboCop::Cop::Lint::RedundantRequireStatement::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/redundant_require_statement.rb#40
RuboCop::Cop::Lint::RedundantRequireStatement::RUBY_22_LOADED_FEATURES = T.let(T.unsafe(nil), Array)

# Checks for redundant safe navigation calls.
# `instance_of?`, `kind_of?`, `is_a?`, `eql?`, `respond_to?`, and `equal?` methods
# are checked by default. These are customizable with `AllowedMethods` option.
#
# The `AllowedMethods` option specifies nil-safe methods,
# in other words, it is a method that is allowed to skip safe navigation.
# Note that the `AllowedMethod` option is not an option that specifies methods
# for which to suppress (allow) this cop's check.
#
# In the example below, the safe navigation operator (`&.`) is unnecessary
# because `NilClass` has methods like `respond_to?` and `is_a?`.
#
# @example
#   # bad
#   do_something if attrs&.respond_to?(:[])
#
#   # good
#   do_something if attrs.respond_to?(:[])
#
#   # bad
#   while node&.is_a?(BeginNode)
#   node = node.parent
#   end
#
#   # good
#   while node.is_a?(BeginNode)
#   node = node.parent
#   end
#
#   # good - without `&.` this will always return `true`
#   foo&.respond_to?(:to_a)
# @example AllowedMethods: [nil_safe_method]
#   # bad
#   do_something if attrs&.nil_safe_method(:[])
#
#   # good
#   do_something if attrs.nil_safe_method(:[])
#   do_something if attrs&.not_nil_safe_method(:[])
#
# source://rubocop//lib/rubocop/cop/lint/redundant_safe_navigation.rb#51
class RuboCop::Cop::Lint::RedundantSafeNavigation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/redundant_safe_navigation.rb#65
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/lint/redundant_safe_navigation.rb#61
  def respond_to_nil_specific_method?(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/redundant_safe_navigation.rb#75
  def check?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/redundant_safe_navigation.rb#85
  def condition?(parent, node); end
end

# source://rubocop//lib/rubocop/cop/lint/redundant_safe_navigation.rb#56
RuboCop::Cop::Lint::RedundantSafeNavigation::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/redundant_safe_navigation.rb#58
RuboCop::Cop::Lint::RedundantSafeNavigation::NIL_SPECIFIC_METHODS = T.let(T.unsafe(nil), Set)

# Checks for unneeded usages of splat expansion
#
# @example
#
#   # bad
#   a = *[1, 2, 3]
#   a = *'a'
#   a = *1
#   ['a', 'b', *%w(c d e), 'f', 'g']
#
#   # good
#   c = [1, 2, 3]
#   a = *c
#   a, b = *c
#   a, *b = *c
#   a = *1..10
#   a = ['a']
#   ['a', 'b', 'c', 'd', 'e', 'f', 'g']
#
#   # bad
#   do_something(*['foo', 'bar', 'baz'])
#
#   # good
#   do_something('foo', 'bar', 'baz')
#
#   # bad
#   begin
#   foo
#   rescue *[StandardError, ApplicationError]
#   bar
#   end
#
#   # good
#   begin
#   foo
#   rescue StandardError, ApplicationError
#   bar
#   end
#
#   # bad
#   case foo
#   when *[1, 2, 3]
#   bar
#   else
#   baz
#   end
#
#   # good
#   case foo
#   when 1, 2, 3
#   bar
#   else
#   baz
#   end
# @example AllowPercentLiteralArrayArgument: true (default)
#
#   # good
#   do_something(*%w[foo bar baz])
# @example AllowPercentLiteralArrayArgument: false
#
#   # bad
#   do_something(*%w[foo bar baz])
#
# source://rubocop//lib/rubocop/cop/lint/redundant_splat_expansion.rb#71
class RuboCop::Cop::Lint::RedundantSplatExpansion < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/redundant_splat_expansion.rb#83
  def array_new?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/redundant_splat_expansion.rb#91
  def literal_expansion(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/redundant_splat_expansion.rb#95
  def on_splat(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/redundant_splat_expansion.rb#203
  def allow_percent_literal_array_argument?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/redundant_splat_expansion.rb#131
  def array_new_inside_array_literal?(array_new_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/redundant_splat_expansion.rb#155
  def array_splat?(node); end

  # source://rubocop//lib/rubocop/cop/lint/redundant_splat_expansion.rb#112
  def autocorrect(corrector, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/redundant_splat_expansion.rb#159
  def method_argument?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/redundant_splat_expansion.rb#163
  def part_of_an_array?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/redundant_splat_expansion.rb#170
  def redundant_brackets?(node); end

  # source://rubocop//lib/rubocop/cop/lint/redundant_splat_expansion.rb#118
  def redundant_splat_expansion(node); end

  # source://rubocop//lib/rubocop/cop/lint/redundant_splat_expansion.rb#178
  def remove_brackets(array); end

  # source://rubocop//lib/rubocop/cop/lint/redundant_splat_expansion.rb#138
  def replacement_range_and_content(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/redundant_splat_expansion.rb#196
  def use_percent_literal_array_argument?(node); end
end

# source://rubocop//lib/rubocop/cop/lint/redundant_splat_expansion.rb#75
RuboCop::Cop::Lint::RedundantSplatExpansion::ARRAY_PARAM_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/redundant_splat_expansion.rb#80
RuboCop::Cop::Lint::RedundantSplatExpansion::ASSIGNMENT_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/redundant_splat_expansion.rb#74
RuboCop::Cop::Lint::RedundantSplatExpansion::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/redundant_splat_expansion.rb#79
RuboCop::Cop::Lint::RedundantSplatExpansion::PERCENT_CAPITAL_I = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/redundant_splat_expansion.rb#77
RuboCop::Cop::Lint::RedundantSplatExpansion::PERCENT_CAPITAL_W = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/redundant_splat_expansion.rb#78
RuboCop::Cop::Lint::RedundantSplatExpansion::PERCENT_I = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/redundant_splat_expansion.rb#76
RuboCop::Cop::Lint::RedundantSplatExpansion::PERCENT_W = T.let(T.unsafe(nil), String)

# Checks for string conversion in string interpolation,
# which is redundant.
#
# @example
#
#   # bad
#
#   "result is #{something.to_s}"
# @example
#
#   # good
#
#   "result is #{something}"
#
# source://rubocop//lib/rubocop/cop/lint/redundant_string_coercion.rb#20
class RuboCop::Cop::Lint::RedundantStringCoercion < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Interpolation
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/redundant_string_coercion.rb#30
  def on_interpolation(begin_node); end

  # source://rubocop//lib/rubocop/cop/lint/redundant_string_coercion.rb#28
  def to_s_without_args?(param0 = T.unsafe(nil)); end
end

# source://rubocop//lib/rubocop/cop/lint/redundant_string_coercion.rb#24
RuboCop::Cop::Lint::RedundantStringCoercion::MSG_DEFAULT = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/redundant_string_coercion.rb#25
RuboCop::Cop::Lint::RedundantStringCoercion::MSG_SELF = T.let(T.unsafe(nil), String)

# Checks for redundant `with_index`.
#
# @example
#   # bad
#   ary.each_with_index do |v|
#   v
#   end
#
#   # good
#   ary.each do |v|
#   v
#   end
#
#   # bad
#   ary.each.with_index do |v|
#   v
#   end
#
#   # good
#   ary.each do |v|
#   v
#   end
#
# source://rubocop//lib/rubocop/cop/lint/redundant_with_index.rb#29
class RuboCop::Cop::Lint::RedundantWithIndex < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/redundant_with_index.rb#36
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/lint/redundant_with_index.rb#36
  def on_numblock(node); end

  # source://rubocop//lib/rubocop/cop/lint/redundant_with_index.rb#56
  def redundant_with_index?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/lint/redundant_with_index.rb#66
  def message(node); end

  # source://rubocop//lib/rubocop/cop/lint/redundant_with_index.rb#74
  def with_index_range(send); end
end

# source://rubocop//lib/rubocop/cop/lint/redundant_with_index.rb#33
RuboCop::Cop::Lint::RedundantWithIndex::MSG_EACH_WITH_INDEX = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/redundant_with_index.rb#34
RuboCop::Cop::Lint::RedundantWithIndex::MSG_WITH_INDEX = T.let(T.unsafe(nil), String)

# Checks for redundant `with_object`.
#
# @example
#   # bad
#   ary.each_with_object([]) do |v|
#   v
#   end
#
#   # good
#   ary.each do |v|
#   v
#   end
#
#   # bad
#   ary.each.with_object([]) do |v|
#   v
#   end
#
#   # good
#   ary.each do |v|
#   v
#   end
#
# source://rubocop//lib/rubocop/cop/lint/redundant_with_object.rb#29
class RuboCop::Cop::Lint::RedundantWithObject < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/redundant_with_object.rb#36
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/lint/redundant_with_object.rb#36
  def on_numblock(node); end

  # source://rubocop//lib/rubocop/cop/lint/redundant_with_object.rb#56
  def redundant_with_object?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/lint/redundant_with_object.rb#65
  def message(node); end

  # source://rubocop//lib/rubocop/cop/lint/redundant_with_object.rb#73
  def with_object_range(send); end
end

# source://rubocop//lib/rubocop/cop/lint/redundant_with_object.rb#33
RuboCop::Cop::Lint::RedundantWithObject::MSG_EACH_WITH_OBJECT = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/redundant_with_object.rb#34
RuboCop::Cop::Lint::RedundantWithObject::MSG_WITH_OBJECT = T.let(T.unsafe(nil), String)

# Checks if `include` or `prepend` is called in `refine` block.
# These methods are deprecated and should be replaced with `Refinement#import_methods`.
#
# It emulates deprecation warnings in Ruby 3.1.
#
# @example
#
#   # bad
#   refine Foo do
#   include Bar
#   end
#
#   # bad
#   refine Foo do
#   prepend Bar
#   end
#
#   # good
#   refine Foo do
#   import_methods Bar
#   end
#
# source://rubocop//lib/rubocop/cop/lint/refinement_import_methods.rb#34
class RuboCop::Cop::Lint::RefinementImportMethods < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop//lib/rubocop/cop/lint/refinement_import_methods.rb#42
  def on_send(node); end
end

# source://rubocop//lib/rubocop/cop/lint/refinement_import_methods.rb#37
RuboCop::Cop::Lint::RefinementImportMethods::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/refinement_import_methods.rb#38
RuboCop::Cop::Lint::RefinementImportMethods::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for regexp literals used as `match-current-line`.
# If a regexp literal is in condition, the regexp matches `$_` implicitly.
#
# @example
#   # bad
#   if /foo/
#   do_something
#   end
#
#   # good
#   if /foo/ =~ $_
#   do_something
#   end
#
# source://rubocop//lib/rubocop/cop/lint/regexp_as_condition.rb#19
class RuboCop::Cop::Lint::RegexpAsCondition < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/regexp_as_condition.rb#26
  def on_match_current_line(node); end
end

# source://rubocop//lib/rubocop/cop/lint/regexp_as_condition.rb#23
RuboCop::Cop::Lint::RegexpAsCondition::MSG = T.let(T.unsafe(nil), String)

# Checks for expressions where there is a call to a predicate
# method with at least one argument, where no parentheses are used around
# the parameter list, and a boolean operator, && or ||, is used in the
# last argument.
#
# The idea behind warning for these constructs is that the user might
# be under the impression that the return value from the method call is
# an operand of &&/||.
#
# @example
#
#   # bad
#
#   if day.is? :tuesday && month == :jan
#   # ...
#   end
# @example
#
#   # good
#
#   if day.is?(:tuesday) && month == :jan
#   # ...
#   end
#
# source://rubocop//lib/rubocop/cop/lint/require_parentheses.rb#30
class RuboCop::Cop::Lint::RequireParentheses < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/lint/require_parentheses.rb#35
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/lint/require_parentheses.rb#35
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/require_parentheses.rb#58
  def check_predicate(predicate, node); end

  # source://rubocop//lib/rubocop/cop/lint/require_parentheses.rb#48
  def check_ternary(ternary, node); end
end

# source://rubocop//lib/rubocop/cop/lint/require_parentheses.rb#33
RuboCop::Cop::Lint::RequireParentheses::MSG = T.let(T.unsafe(nil), String)

# Checks that a range literal is enclosed in parentheses when the end of the range is
# at a line break.
#
# NOTE: The following is maybe intended for `(42..)`. But, compatible is `42..do_something`.
# So, this cop does not provide autocorrection because it is left to user.
#
# [source,ruby]
# ----
# case condition
# when 42..
#   do_something
# end
# ----
#
# @example
#
#   # bad - Represents `(1..42)`, not endless range.
#   1..
#   42
#
#   # good - It's incompatible, but your intentions when using endless range may be:
#   (1..)
#   42
#
#   # good
#   1..42
#
#   # good
#   (1..42)
#
#   # good
#   (1..
#   42)
#
# source://rubocop//lib/rubocop/cop/lint/require_range_parentheses.rb#40
class RuboCop::Cop::Lint::RequireRangeParentheses < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/lint/require_range_parentheses.rb#43
  def on_erange(node); end

  # source://rubocop//lib/rubocop/cop/lint/require_range_parentheses.rb#43
  def on_irange(node); end
end

# source://rubocop//lib/rubocop/cop/lint/require_range_parentheses.rb#41
RuboCop::Cop::Lint::RequireRangeParentheses::MSG = T.let(T.unsafe(nil), String)

# Checks for uses a file requiring itself with `require_relative`.
#
# @example
#
#   # bad
#
#   # foo.rb
#   require_relative 'foo'
#   require_relative 'bar'
#
#   # good
#
#   # foo.rb
#   require_relative 'bar'
#
# source://rubocop//lib/rubocop/cop/lint/require_relative_self_path.rb#21
class RuboCop::Cop::Lint::RequireRelativeSelfPath < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/require_relative_self_path.rb#28
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/require_relative_self_path.rb#44
  def remove_ext(file_path); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/require_relative_self_path.rb#40
  def same_file?(file_path, required_feature); end
end

# source://rubocop//lib/rubocop/cop/lint/require_relative_self_path.rb#25
RuboCop::Cop::Lint::RequireRelativeSelfPath::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/require_relative_self_path.rb#26
RuboCop::Cop::Lint::RequireRelativeSelfPath::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for `rescue` blocks targeting the Exception class.
#
# @example
#
#   # bad
#
#   begin
#   do_something
#   rescue Exception
#   handle_exception
#   end
# @example
#
#   # good
#
#   begin
#   do_something
#   rescue ArgumentError
#   handle_exception
#   end
#
# source://rubocop//lib/rubocop/cop/lint/rescue_exception.rb#27
class RuboCop::Cop::Lint::RescueException < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/lint/rescue_exception.rb#30
  def on_resbody(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/rescue_exception.rb#39
  def targets_exception?(rescue_arg_node); end
end

# source://rubocop//lib/rubocop/cop/lint/rescue_exception.rb#28
RuboCop::Cop::Lint::RescueException::MSG = T.let(T.unsafe(nil), String)

# Check for arguments to `rescue` that will result in a `TypeError`
# if an exception is raised.
#
# @example
#   # bad
#   begin
#   bar
#   rescue nil
#   baz
#   end
#
#   # bad
#   def foo
#   bar
#   rescue 1, 'a', "#{b}", 0.0, [], {}
#   baz
#   end
#
#   # good
#   begin
#   bar
#   rescue
#   baz
#   end
#
#   # good
#   def foo
#   bar
#   rescue NameError
#   baz
#   end
#
# source://rubocop//lib/rubocop/cop/lint/rescue_type.rb#37
class RuboCop::Cop::Lint::RescueType < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/rescue_type.rb#60
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/lint/rescue_type.rb#44
  def on_resbody(node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/rescue_type.rb#71
  def correction(*exceptions); end

  # source://rubocop//lib/rubocop/cop/lint/rescue_type.rb#82
  def invalid_exceptions(exceptions); end

  # source://rubocop//lib/rubocop/cop/lint/rescue_type.rb#78
  def valid_exceptions(exceptions); end
end

# source://rubocop//lib/rubocop/cop/lint/rescue_type.rb#42
RuboCop::Cop::Lint::RescueType::INVALID_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/rescue_type.rb#40
RuboCop::Cop::Lint::RescueType::MSG = T.let(T.unsafe(nil), String)

# Checks for the use of a return with a value in a context
# where the value will be ignored. (initialize and setter methods)
#
# @example
#
#   # bad
#   def initialize
#   foo
#   return :qux if bar?
#   baz
#   end
#
#   def foo=(bar)
#   return 42
#   end
# @example
#
#   # good
#   def initialize
#   foo
#   return if bar?
#   baz
#   end
#
#   def foo=(bar)
#   return
#   end
#
# source://rubocop//lib/rubocop/cop/lint/return_in_void_context.rb#34
class RuboCop::Cop::Lint::ReturnInVoidContext < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/lint/return_in_void_context.rb#37
  def on_return(return_node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/return_in_void_context.rb#53
  def non_void_context(return_node); end
end

# source://rubocop//lib/rubocop/cop/lint/return_in_void_context.rb#35
RuboCop::Cop::Lint::ReturnInVoidContext::MSG = T.let(T.unsafe(nil), String)

# The safe navigation operator returns nil if the receiver is
# nil. If you chain an ordinary method call after a safe
# navigation operator, it raises NoMethodError. We should use a
# safe navigation operator after a safe navigation operator.
# This cop checks for the problem outlined above.
#
# @example
#
#   # bad
#
#   x&.foo.bar
#   x&.foo + bar
#   x&.foo[bar]
# @example
#
#   # good
#
#   x&.foo&.bar
#   x&.foo || bar
#
# source://rubocop//lib/rubocop/cop/lint/safe_navigation_chain.rb#26
class RuboCop::Cop::Lint::SafeNavigationChain < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::NilMethods
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop//lib/rubocop/cop/lint/safe_navigation_chain.rb#37
  def bad_method?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/safe_navigation_chain.rb#44
  def on_send(node); end

  private

  # @param offense_range [Parser::Source::Range]
  # @param send_node [RuboCop::AST::SendNode]
  # @return [String]
  #
  # source://rubocop//lib/rubocop/cop/lint/safe_navigation_chain.rb#63
  def add_safe_navigation_operator(offense_range:, send_node:); end

  # @param corrector [RuboCop::Cop::Corrector]
  # @param offense_range [Parser::Source::Range]
  # @param send_node [RuboCop::AST::SendNode]
  #
  # source://rubocop//lib/rubocop/cop/lint/safe_navigation_chain.rb#82
  def autocorrect(corrector, offense_range:, send_node:); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/safe_navigation_chain.rb#92
  def brackets?(send_node); end
end

# source://rubocop//lib/rubocop/cop/lint/safe_navigation_chain.rb#33
RuboCop::Cop::Lint::SafeNavigationChain::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/safe_navigation_chain.rb#34
RuboCop::Cop::Lint::SafeNavigationChain::PLUS_MINUS_METHODS = T.let(T.unsafe(nil), Array)

# Check to make sure that if safe navigation is used for a method
# call in an `&&` or `||` condition that safe navigation is used for all
# method calls on that same object.
#
# @example
#   # bad
#   foo&.bar && foo.baz
#
#   # bad
#   foo.bar || foo&.baz
#
#   # bad
#   foo&.bar && (foobar.baz || foo.baz)
#
#   # good
#   foo.bar && foo.baz
#
#   # good
#   foo&.bar || foo&.baz
#
#   # good
#   foo&.bar && (foobar.baz || foo&.baz)
#
# source://rubocop//lib/rubocop/cop/lint/safe_navigation_consistency.rb#29
class RuboCop::Cop::Lint::SafeNavigationConsistency < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::NilMethods
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/safe_navigation_consistency.rb#42
  def check(node); end

  # source://rubocop//lib/rubocop/cop/lint/safe_navigation_consistency.rb#36
  def on_csend(node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/safe_navigation_consistency.rb#61
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/lint/safe_navigation_consistency.rb#67
  def location(node, unsafe_method_call); end

  # source://rubocop//lib/rubocop/cop/lint/safe_navigation_consistency.rb#71
  def top_conditional_ancestor(node); end

  # source://rubocop//lib/rubocop/cop/lint/safe_navigation_consistency.rb#82
  def unsafe_method_calls(method_calls, safe_nav_receiver); end
end

# source://rubocop//lib/rubocop/cop/lint/safe_navigation_consistency.rb#34
RuboCop::Cop::Lint::SafeNavigationConsistency::MSG = T.let(T.unsafe(nil), String)

# Checks to make sure safe navigation isn't used with `empty?` in
# a conditional.
#
# While the safe navigation operator is generally a good idea, when
# checking `foo&.empty?` in a conditional, `foo` being `nil` will actually
# do the opposite of what the author intends.
#
# @example
#   # bad
#   return if foo&.empty?
#   return unless foo&.empty?
#
#   # good
#   return if foo && foo.empty?
#   return unless foo && foo.empty?
#
# source://rubocop//lib/rubocop/cop/lint/safe_navigation_with_empty.rb#22
class RuboCop::Cop::Lint::SafeNavigationWithEmpty < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/safe_navigation_with_empty.rb#32
  def on_if(node); end

  # source://rubocop//lib/rubocop/cop/lint/safe_navigation_with_empty.rb#28
  def safe_navigation_empty_in_conditional?(param0 = T.unsafe(nil)); end
end

# source://rubocop//lib/rubocop/cop/lint/safe_navigation_with_empty.rb#25
RuboCop::Cop::Lint::SafeNavigationWithEmpty::MSG = T.let(T.unsafe(nil), String)

# Checks if a file which has a shebang line as
# its first line is granted execute permission.
#
# @example
#   # bad
#
#   # A file which has a shebang line as its first line is not
#   # granted execute permission.
#
#   #!/usr/bin/env ruby
#   puts 'hello, world'
#
#   # good
#
#   # A file which has a shebang line as its first line is
#   # granted execute permission.
#
#   #!/usr/bin/env ruby
#   puts 'hello, world'
#
#   # good
#
#   # A file which has not a shebang line as its first line is not
#   # granted execute permission.
#
#   puts 'hello, world'
#
# source://rubocop//lib/rubocop/cop/lint/script_permission.rb#33
class RuboCop::Cop::Lint::ScriptPermission < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/script_permission.rb#39
  def on_new_investigation; end

  private

  # source://rubocop//lib/rubocop/cop/lint/script_permission.rb#55
  def autocorrect(comment); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/script_permission.rb#59
  def executable?(processed_source); end

  # source://rubocop//lib/rubocop/cop/lint/script_permission.rb#66
  def format_message_from(processed_source); end
end

# source://rubocop//lib/rubocop/cop/lint/script_permission.rb#36
RuboCop::Cop::Lint::ScriptPermission::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/script_permission.rb#37
RuboCop::Cop::Lint::ScriptPermission::SHEBANG = T.let(T.unsafe(nil), String)

# Checks for self-assignments.
#
# @example
#   # bad
#   foo = foo
#   foo, bar = foo, bar
#   Foo = Foo
#
#   # good
#   foo = bar
#   foo, bar = bar, foo
#   Foo = Bar
#
# source://rubocop//lib/rubocop/cop/lint/self_assignment.rb#19
class RuboCop::Cop::Lint::SelfAssignment < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/lint/self_assignment.rb#53
  def on_and_asgn(node); end

  # source://rubocop//lib/rubocop/cop/lint/self_assignment.rb#41
  def on_casgn(node); end

  # source://rubocop//lib/rubocop/cop/lint/self_assignment.rb#29
  def on_cvasgn(node); end

  # source://rubocop//lib/rubocop/cop/lint/self_assignment.rb#29
  def on_gvasgn(node); end

  # source://rubocop//lib/rubocop/cop/lint/self_assignment.rb#29
  def on_ivasgn(node); end

  # source://rubocop//lib/rubocop/cop/lint/self_assignment.rb#29
  def on_lvasgn(node); end

  # source://rubocop//lib/rubocop/cop/lint/self_assignment.rb#49
  def on_masgn(node); end

  # source://rubocop//lib/rubocop/cop/lint/self_assignment.rb#53
  def on_or_asgn(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/self_assignment.rb#61
  def multiple_self_assignment?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/self_assignment.rb#71
  def rhs_matches_lhs?(rhs, lhs); end
end

# source://rubocop//lib/rubocop/cop/lint/self_assignment.rb#22
RuboCop::Cop::Lint::SelfAssignment::ASSIGNMENT_TYPE_TO_RHS_TYPE = T.let(T.unsafe(nil), Hash)

# source://rubocop//lib/rubocop/cop/lint/self_assignment.rb#20
RuboCop::Cop::Lint::SelfAssignment::MSG = T.let(T.unsafe(nil), String)

# This cop checks for `send`, `public_send`, and `__send__` methods
# when using mix-in.
#
# `include` and `prepend` methods were private methods until Ruby 2.0,
# they were mixed-in via `send` method. This cop uses Ruby 2.1 or
# higher style that can be called by public methods.
# And `extend` method that was originally a public method is also targeted
# for style unification.
#
# @example
#   # bad
#   Foo.send(:include, Bar)
#   Foo.send(:prepend, Bar)
#   Foo.send(:extend, Bar)
#
#   # bad
#   Foo.public_send(:include, Bar)
#   Foo.public_send(:prepend, Bar)
#   Foo.public_send(:extend, Bar)
#
#   # bad
#   Foo.__send__(:include, Bar)
#   Foo.__send__(:prepend, Bar)
#   Foo.__send__(:extend, Bar)
#
#   # good
#   Foo.include Bar
#   Foo.prepend Bar
#   Foo.extend Bar
#
# source://rubocop//lib/rubocop/cop/lint/send_with_mixin_argument.rb#37
class RuboCop::Cop::Lint::SendWithMixinArgument < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/send_with_mixin_argument.rb#54
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/lint/send_with_mixin_argument.rb#47
  def send_with_mixin_argument?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/lint/send_with_mixin_argument.rb#68
  def bad_location(node); end

  # source://rubocop//lib/rubocop/cop/lint/send_with_mixin_argument.rb#74
  def message(method, module_name, bad_method); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/send_with_mixin_argument.rb#78
  def mixin_method?(node); end
end

# source://rubocop//lib/rubocop/cop/lint/send_with_mixin_argument.rb#42
RuboCop::Cop::Lint::SendWithMixinArgument::MIXIN_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/send_with_mixin_argument.rb#41
RuboCop::Cop::Lint::SendWithMixinArgument::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/send_with_mixin_argument.rb#44
RuboCop::Cop::Lint::SendWithMixinArgument::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/send_with_mixin_argument.rb#43
RuboCop::Cop::Lint::SendWithMixinArgument::SEND_METHODS = T.let(T.unsafe(nil), Array)

# Checks for shadowed arguments.
#
# This cop has `IgnoreImplicitReferences` configuration option.
# It means argument shadowing is used in order to pass parameters
# to zero arity `super` when `IgnoreImplicitReferences` is `true`.
#
# @example
#
#   # bad
#   do_something do |foo|
#   foo = 42
#   puts foo
#   end
#
#   def do_something(foo)
#   foo = 42
#   puts foo
#   end
#
#   # good
#   do_something do |foo|
#   foo = foo + 42
#   puts foo
#   end
#
#   def do_something(foo)
#   foo = foo + 42
#   puts foo
#   end
#
#   def do_something(foo)
#   puts foo
#   end
# @example IgnoreImplicitReferences: false (default)
#
#   # bad
#   def do_something(foo)
#   foo = 42
#   super
#   end
#
#   def do_something(foo)
#   foo = super
#   bar
#   end
# @example IgnoreImplicitReferences: true
#
#   # good
#   def do_something(foo)
#   foo = 42
#   super
#   end
#
#   def do_something(foo)
#   foo = super
#   bar
#   end
#
# source://rubocop//lib/rubocop/cop/lint/shadowed_argument.rb#66
class RuboCop::Cop::Lint::ShadowedArgument < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/lint/shadowed_argument.rb#76
  def after_leaving_scope(scope, _variable_table); end

  # source://rubocop//lib/rubocop/cop/lint/shadowed_argument.rb#70
  def uses_var?(param0, param1); end

  private

  # Get argument references without assignments' references
  #
  # source://rubocop//lib/rubocop/cop/lint/shadowed_argument.rb#160
  def argument_references(argument); end

  # Find the first argument assignment, which doesn't reference the
  # argument at the rhs. If the assignment occurs inside a branch or
  # block, it is impossible to tell whether it's executed, so precise
  # shadowing location is not known.
  #
  # source://rubocop//lib/rubocop/cop/lint/shadowed_argument.rb#120
  def assignment_without_argument_usage(argument); end

  # source://rubocop//lib/rubocop/cop/lint/shadowed_argument.rb#82
  def check_argument(argument); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/shadowed_argument.rb#170
  def ignore_implicit_references?; end

  # Check whether the given node is nested into block or conditional.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/shadowed_argument.rb#151
  def node_within_block_or_conditional?(node, stop_search_node); end

  # source://rubocop//lib/rubocop/cop/lint/shadowed_argument.rb#143
  def reference_pos(node); end

  # source://rubocop//lib/rubocop/cop/lint/shadowed_argument.rb#95
  def shadowing_assignment(argument); end

  class << self
    # source://rubocop//lib/rubocop/cop/lint/shadowed_argument.rb#72
    def joining_forces; end
  end
end

# source://rubocop//lib/rubocop/cop/lint/shadowed_argument.rb#67
RuboCop::Cop::Lint::ShadowedArgument::MSG = T.let(T.unsafe(nil), String)

# Checks for a rescued exception that get shadowed by a
# less specific exception being rescued before a more specific
# exception is rescued.
#
# An exception is considered shadowed if it is rescued after its
# ancestor is, or if it and its ancestor are both rescued in the
# same `rescue` statement. In both cases, the more specific rescue is
# unnecessary because it is covered by rescuing the less specific
# exception. (ie. `rescue Exception, StandardError` has the same behavior
# whether `StandardError` is included or not, because all ``StandardError``s
# are rescued by `rescue Exception`).
#
# @example
#
#   # bad
#
#   begin
#   something
#   rescue Exception
#   handle_exception
#   rescue StandardError
#   handle_standard_error
#   end
#
#   # bad
#   begin
#   something
#   rescue Exception, StandardError
#   handle_error
#   end
#
#   # good
#
#   begin
#   something
#   rescue StandardError
#   handle_standard_error
#   rescue Exception
#   handle_exception
#   end
#
#   # good, however depending on runtime environment.
#   #
#   # This is a special case for system call errors.
#   # System dependent error code depends on runtime environment.
#   # For example, whether `Errno::EAGAIN` and `Errno::EWOULDBLOCK` are
#   # the same error code or different error code depends on environment.
#   # This good case is for `Errno::EAGAIN` and `Errno::EWOULDBLOCK` with
#   # the same error code.
#   begin
#   something
#   rescue Errno::EAGAIN, Errno::EWOULDBLOCK
#   handle_standard_error
#   end
#
# source://rubocop//lib/rubocop/cop/lint/shadowed_exception.rb#61
class RuboCop::Cop::Lint::ShadowedException < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RescueNode
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/lint/shadowed_exception.rb#67
  def on_rescue(node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/shadowed_exception.rb#101
  def compare_exceptions(exception, other_exception); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/shadowed_exception.rb#94
  def contains_multiple_levels_of_exceptions?(group); end

  # source://rubocop//lib/rubocop/cop/lint/shadowed_exception.rb#119
  def evaluate_exceptions(group); end

  # source://rubocop//lib/rubocop/cop/lint/shadowed_exception.rb#158
  def find_shadowing_rescue(rescues); end

  # source://rubocop//lib/rubocop/cop/lint/shadowed_exception.rb#84
  def offense_range(rescues); end

  # source://rubocop//lib/rubocop/cop/lint/shadowed_exception.rb#90
  def rescued_groups_for(rescues); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/shadowed_exception.rb#143
  def sorted?(rescued_groups); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/shadowed_exception.rb#115
  def system_call_err?(error); end
end

# source://rubocop//lib/rubocop/cop/lint/shadowed_exception.rb#65
RuboCop::Cop::Lint::ShadowedException::MSG = T.let(T.unsafe(nil), String)

# Checks for the use of local variable names from an outer scope
# in block arguments or block-local variables. This mirrors the warning
# given by `ruby -cw` prior to Ruby 2.6:
# "shadowing outer local variable - foo".
#
# NOTE: Shadowing of variables in block passed to `Ractor.new` is allowed
# because `Ractor` should not access outer variables.
# eg. following style is encouraged:
#
#   [source,ruby]
#   ----
#   worker_id, pipe = env
#   Ractor.new(worker_id, pipe) do |worker_id, pipe|
#   end
#   ----
#
# @example
#
#   # bad
#
#   def some_method
#   foo = 1
#
#   2.times do |foo| # shadowing outer `foo`
#   do_something(foo)
#   end
#   end
# @example
#
#   # good
#
#   def some_method
#   foo = 1
#
#   2.times do |bar|
#   do_something(bar)
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/lint/shadowing_outer_local_variable.rb#45
class RuboCop::Cop::Lint::ShadowingOuterLocalVariable < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/lint/shadowing_outer_local_variable.rb#57
  def before_declaring_variable(variable, variable_table); end

  # source://rubocop//lib/rubocop/cop/lint/shadowing_outer_local_variable.rb#93
  def find_conditional_node_from_ascendant(node); end

  # source://rubocop//lib/rubocop/cop/lint/shadowing_outer_local_variable.rb#49
  def ractor_block?(param0 = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/shadowing_outer_local_variable.rb#69
  def same_conditions_node_different_branch?(variable, outer_local_variable); end

  # source://rubocop//lib/rubocop/cop/lint/shadowing_outer_local_variable.rb#83
  def variable_node(variable); end

  class << self
    # source://rubocop//lib/rubocop/cop/lint/shadowing_outer_local_variable.rb#53
    def joining_forces; end
  end
end

# source://rubocop//lib/rubocop/cop/lint/shadowing_outer_local_variable.rb#46
RuboCop::Cop::Lint::ShadowingOuterLocalVariable::MSG = T.let(T.unsafe(nil), String)

# Checks unexpected overrides of the `Struct` built-in methods
# via `Struct.new`.
#
# @example
#   # bad
#   Bad = Struct.new(:members, :clone, :count)
#   b = Bad.new([], true, 1)
#   b.members #=> [] (overriding `Struct#members`)
#   b.clone #=> true (overriding `Object#clone`)
#   b.count #=> 1 (overriding `Enumerable#count`)
#
#   # good
#   Good = Struct.new(:id, :name)
#   g = Good.new(1, "foo")
#   g.members #=> [:id, :name]
#   g.clone #=> #<struct Good id=1, name="foo">
#   g.count #=> 2
#
# source://rubocop//lib/rubocop/cop/lint/struct_new_override.rb#24
class RuboCop::Cop::Lint::StructNewOverride < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/lint/struct_new_override.rb#38
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/lint/struct_new_override.rb#33
  def struct_new(param0 = T.unsafe(nil)); end
end

# source://rubocop//lib/rubocop/cop/lint/struct_new_override.rb#25
RuboCop::Cop::Lint::StructNewOverride::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/struct_new_override.rb#27
RuboCop::Cop::Lint::StructNewOverride::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/struct_new_override.rb#30
RuboCop::Cop::Lint::StructNewOverride::STRUCT_MEMBER_NAME_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/struct_new_override.rb#29
RuboCop::Cop::Lint::StructNewOverride::STRUCT_METHOD_NAMES = T.let(T.unsafe(nil), Array)

# Checks for `rescue` blocks with no body.
#
# @example
#
#   # bad
#   def some_method
#   do_something
#   rescue
#   end
#
#   # bad
#   begin
#   do_something
#   rescue
#   end
#
#   # good
#   def some_method
#   do_something
#   rescue
#   handle_exception
#   end
#
#   # good
#   begin
#   do_something
#   rescue
#   handle_exception
#   end
# @example AllowComments: true (default)
#
#   # good
#   def some_method
#   do_something
#   rescue
#   # do nothing
#   end
#
#   # good
#   begin
#   do_something
#   rescue
#   # do nothing
#   end
# @example AllowComments: false
#
#   # bad
#   def some_method
#   do_something
#   rescue
#   # do nothing
#   end
#
#   # bad
#   begin
#   do_something
#   rescue
#   # do nothing
#   end
# @example AllowNil: true (default)
#
#   # good
#   def some_method
#   do_something
#   rescue
#   nil
#   end
#
#   # good
#   begin
#   do_something
#   rescue
#   # do nothing
#   end
#
#   # good
#   do_something rescue nil
# @example AllowNil: false
#
#   # bad
#   def some_method
#   do_something
#   rescue
#   nil
#   end
#
#   # bad
#   begin
#   do_something
#   rescue
#   nil
#   end
#
#   # bad
#   do_something rescue nil
#
# source://rubocop//lib/rubocop/cop/lint/suppressed_exception.rb#105
class RuboCop::Cop::Lint::SuppressedException < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/lint/suppressed_exception.rb#108
  def on_resbody(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/suppressed_exception.rb#118
  def comment_between_rescue_and_end?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/suppressed_exception.rb#126
  def nil_body?(node); end
end

# source://rubocop//lib/rubocop/cop/lint/suppressed_exception.rb#106
RuboCop::Cop::Lint::SuppressedException::MSG = T.let(T.unsafe(nil), String)

# Checks for uses of literal strings converted to
# a symbol where a literal symbol could be used instead.
#
# There are two possible styles for this cop.
# `strict` (default) will register an offense for any incorrect usage.
# `consistent` additionally requires hashes to use the same style for
# every symbol key (ie. if any symbol key needs to be quoted it requires
# all keys to be quoted).
#
# @example
#   # bad
#   'string'.to_sym
#   :symbol.to_sym
#   'underscored_string'.to_sym
#   :'underscored_symbol'
#   'hyphenated-string'.to_sym
#
#   # good
#   :string
#   :symbol
#   :underscored_string
#   :underscored_symbol
#   :'hyphenated-string'
# @example EnforcedStyle: strict (default)
#
#   # bad
#   {
#   'a': 1,
#   "b": 2,
#   'c-d': 3
#   }
#
#   # good (don't quote keys that don't require quoting)
#   {
#   a: 1,
#   b: 2,
#   'c-d': 3
#   }
# @example EnforcedStyle: consistent
#
#   # bad
#   {
#   a: 1,
#   'b-c': 2
#   }
#
#   # good (quote all keys if any need quoting)
#   {
#   'a': 1,
#   'b-c': 2
#   }
#
#   # good (no quoting required)
#   {
#   a: 1,
#   b: 2
#   }
#
# source://rubocop//lib/rubocop/cop/lint/symbol_conversion.rb#66
class RuboCop::Cop::Lint::SymbolConversion < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::SymbolHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/symbol_conversion.rb#100
  def on_hash(node); end

  # source://rubocop//lib/rubocop/cop/lint/symbol_conversion.rb#76
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/lint/symbol_conversion.rb#83
  def on_sym(node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/symbol_conversion.rb#142
  def correct_hash_key(node); end

  # source://rubocop//lib/rubocop/cop/lint/symbol_conversion.rb#161
  def correct_inconsistent_hash_keys(keys); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/symbol_conversion.rb#134
  def in_alias?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/symbol_conversion.rb#138
  def in_percent_literal_array?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/symbol_conversion.rb#121
  def properly_quoted?(source, value); end

  # source://rubocop//lib/rubocop/cop/lint/symbol_conversion.rb#117
  def register_offense(node, correction:, message: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/symbol_conversion.rb#130
  def requires_quotes?(sym_node); end
end

# source://rubocop//lib/rubocop/cop/lint/symbol_conversion.rb#71
RuboCop::Cop::Lint::SymbolConversion::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/symbol_conversion.rb#72
RuboCop::Cop::Lint::SymbolConversion::MSG_CONSISTENCY = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/symbol_conversion.rb#74
RuboCop::Cop::Lint::SymbolConversion::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Repacks Parser's diagnostics/errors
# into RuboCop's offenses.
#
# source://rubocop//lib/rubocop/cop/lint/syntax.rb#8
class RuboCop::Cop::Lint::Syntax < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/lint/syntax.rb#9
  def on_other_file; end

  private

  # source://rubocop//lib/rubocop/cop/lint/syntax.rb#19
  def add_offense_from_diagnostic(diagnostic, ruby_version); end

  # source://rubocop//lib/rubocop/cop/lint/syntax.rb#26
  def add_offense_from_error(error); end

  # source://rubocop//lib/rubocop/cop/lint/syntax.rb#31
  def beautify_message(message); end

  # source://rubocop//lib/rubocop/cop/lint/syntax.rb#37
  def find_severity(_range, _severity); end
end

# Ensures that `to_enum`/`enum_for`, called for the current method,
# has correct arguments.
#
# @example
#   # bad
#   def foo(x, y = 1)
#   return to_enum(__callee__, x) # `y` is missing
#   end
#
#   # good
#   def foo(x, y = 1)
#   # Alternatives to `__callee__` are `__method__` and `:foo`.
#   return to_enum(__callee__, x, y)
#   end
#
#   # good
#   def foo(x, y = 1)
#   # It is also allowed if it is wrapped in some method like Sorbet.
#   return to_enum(T.must(__callee__), x, y)
#   end
#
# source://rubocop//lib/rubocop/cop/lint/to_enum_arguments.rb#27
class RuboCop::Cop::Lint::ToEnumArguments < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/lint/to_enum_arguments.rb#33
  def enum_conversion_call?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/to_enum_arguments.rb#38
  def method_name?(param0 = T.unsafe(nil), param1); end

  # source://rubocop//lib/rubocop/cop/lint/to_enum_arguments.rb#47
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/lint/to_enum_arguments.rb#43
  def passing_keyword_arg?(param0 = T.unsafe(nil), param1); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/to_enum_arguments.rb#78
  def argument_match?(send_arg, def_arg); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/to_enum_arguments.rb#63
  def arguments_match?(arguments, def_node); end
end

# source://rubocop//lib/rubocop/cop/lint/to_enum_arguments.rb#28
RuboCop::Cop::Lint::ToEnumArguments::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/to_enum_arguments.rb#30
RuboCop::Cop::Lint::ToEnumArguments::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks to make sure `#to_json` includes an optional argument.
# When overriding `#to_json`, callers may invoke JSON
# generation via `JSON.generate(your_obj)`.  Since `JSON#generate` allows
# for an optional argument, your method should too.
#
# @example
#   class Point
#   attr_reader :x, :y
#
#   # bad, incorrect arity
#   def to_json
#   JSON.generate([x, y])
#   end
#
#   # good, preserving args
#   def to_json(*args)
#   JSON.generate([x, y], *args)
#   end
#
#   # good, discarding args
#   def to_json(*_args)
#   JSON.generate([x, y])
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/lint/to_json.rb#31
class RuboCop::Cop::Lint::ToJSON < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/to_json.rb#36
  def on_def(node); end
end

# source://rubocop//lib/rubocop/cop/lint/to_json.rb#34
RuboCop::Cop::Lint::ToJSON::MSG = T.let(T.unsafe(nil), String)

# Checks for top level return with arguments. If there is a
# top-level return statement with an argument, then the argument is
# always ignored. This is detected automatically since Ruby 2.7.
#
# @example
#
#   # Detected since Ruby 2.7
#   return 1 # 1 is always ignored.
#
# source://rubocop//lib/rubocop/cop/lint/top_level_return_with_argument.rb#14
class RuboCop::Cop::Lint::TopLevelReturnWithArgument < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/lint/top_level_return_with_argument.rb#21
  def on_return(return_node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/top_level_return_with_argument.rb#27
  def ancestors_valid?(return_node); end
end

# This cop works by validating the ancestors of the return node. A
# top-level return node's ancestors should not be of block, def, or
# defs type.
#
# source://rubocop//lib/rubocop/cop/lint/top_level_return_with_argument.rb#19
RuboCop::Cop::Lint::TopLevelReturnWithArgument::MSG = T.let(T.unsafe(nil), String)

# Checks for trailing commas in attribute declarations, such as
# `#attr_reader`. Leaving a trailing comma will nullify the next method
# definition by overriding it with a getter method.
#
# @example
#
#   # bad
#   class Foo
#   attr_reader :foo,
#
#   def bar
#   puts "Unreachable."
#   end
#   end
#
#   # good
#   class Foo
#   attr_reader :foo
#
#   def bar
#   puts "No problem!"
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/lint/trailing_comma_in_attribute_declaration.rb#30
class RuboCop::Cop::Lint::TrailingCommaInAttributeDeclaration < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/trailing_comma_in_attribute_declaration.rb#36
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/trailing_comma_in_attribute_declaration.rb#46
  def trailing_comma_range(node); end
end

# source://rubocop//lib/rubocop/cop/lint/trailing_comma_in_attribute_declaration.rb#34
RuboCop::Cop::Lint::TrailingCommaInAttributeDeclaration::MSG = T.let(T.unsafe(nil), String)

# Checks for "triple quotes" (strings delimited by any odd number
# of quotes greater than 1).
#
# Ruby allows multiple strings to be implicitly concatenated by just
# being adjacent in a statement (ie. `"foo""bar" == "foobar"`). This sometimes
# gives the impression that there is something special about triple quotes, but
# in fact it is just extra unnecessary quotes and produces the same string. Each
# pair of quotes produces an additional concatenated empty string, so the result
# is still only the "actual" string within the delimiters.
#
# NOTE: Although this cop is called triple quotes, the same behavior is present
# for strings delimited by 5, 7, etc. quotation marks.
#
# @example
#   # bad
#   """
#   A string
#   """
#
#   # bad
#   '''
#   A string
#   '''
#
#   # good
#   "
#   A string
#   "
#
#   # good
#   <<STRING
#   A string
#   STRING
#
#   # good (but not the same spacing as the bad case)
#   'A string'
#
# source://rubocop//lib/rubocop/cop/lint/triple_quotes.rb#42
class RuboCop::Cop::Lint::TripleQuotes < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/triple_quotes.rb#47
  def on_dstr(node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/triple_quotes.rb#65
  def empty_str_nodes(node); end
end

# source://rubocop//lib/rubocop/cop/lint/triple_quotes.rb#45
RuboCop::Cop::Lint::TripleQuotes::MSG = T.let(T.unsafe(nil), String)

# Checks for underscore-prefixed variables that are actually
# used.
#
# Since block keyword arguments cannot be arbitrarily named at call
# sites, the `AllowKeywordBlockArguments` will allow use of underscore-
# prefixed block keyword arguments.
#
# @example AllowKeywordBlockArguments: false (default)
#
#   # bad
#
#   [1, 2, 3].each do |_num|
#   do_something(_num)
#   end
#
#   query(:sales) do |_id:, revenue:, cost:|
#   {_id: _id, profit: revenue - cost}
#   end
#
#   # good
#
#   [1, 2, 3].each do |num|
#   do_something(num)
#   end
#
#   [1, 2, 3].each do |_num|
#   do_something # not using `_num`
#   end
# @example AllowKeywordBlockArguments: true
#
#   # good
#
#   query(:sales) do |_id:, revenue:, cost:|
#   {_id: _id, profit: revenue - cost}
#   end
#
# source://rubocop//lib/rubocop/cop/lint/underscore_prefixed_variable_name.rb#43
class RuboCop::Cop::Lint::UnderscorePrefixedVariableName < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/lint/underscore_prefixed_variable_name.rb#50
  def after_leaving_scope(scope, _variable_table); end

  # source://rubocop//lib/rubocop/cop/lint/underscore_prefixed_variable_name.rb#54
  def check_variable(variable); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/underscore_prefixed_variable_name.rb#72
  def allowed_keyword_block_argument?(variable); end

  class << self
    # source://rubocop//lib/rubocop/cop/lint/underscore_prefixed_variable_name.rb#46
    def joining_forces; end
  end
end

# source://rubocop//lib/rubocop/cop/lint/underscore_prefixed_variable_name.rb#44
RuboCop::Cop::Lint::UnderscorePrefixedVariableName::MSG = T.let(T.unsafe(nil), String)

# Checks for a block that is known to need more positional
# block arguments than are given (by default this is configured for
# `Enumerable` methods needing 2 arguments). Optional arguments are allowed,
# although they don't generally make sense as the default value will
# be used. Blocks that have no receiver, or take splatted arguments
# (ie. `*args`) are always accepted.
#
# Keyword arguments (including `**kwargs`) do not get counted towards
# this, as they are not used by the methods in question.
#
# Method names and their expected arity can be configured like this:
#
# [source,yaml]
# ----
# Methods:
#   inject: 2
#   reduce: 2
# ----
#
# @example
#   # bad
#   values.reduce {}
#   values.min { |a| a }
#   values.sort { |a; b| a + b }
#
#   # good
#   values.reduce { |memo, obj| memo << obj }
#   values.min { |a, b| a <=> b }
#   values.sort { |*x| x[0] <=> x[1] }
#
# source://rubocop//lib/rubocop/cop/lint/unexpected_block_arity.rb#41
class RuboCop::Cop::Lint::UnexpectedBlockArity < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/lint/unexpected_block_arity.rb#44
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/lint/unexpected_block_arity.rb#44
  def on_numblock(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/unexpected_block_arity.rb#63
  def acceptable?(node); end

  # source://rubocop//lib/rubocop/cop/lint/unexpected_block_arity.rb#75
  def arg_count(node); end

  # source://rubocop//lib/rubocop/cop/lint/unexpected_block_arity.rb#71
  def expected_arity(method); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/unexpected_block_arity.rb#67
  def included_method?(name); end

  # source://rubocop//lib/rubocop/cop/lint/unexpected_block_arity.rb#59
  def methods; end
end

# source://rubocop//lib/rubocop/cop/lint/unexpected_block_arity.rb#42
RuboCop::Cop::Lint::UnexpectedBlockArity::MSG = T.let(T.unsafe(nil), String)

# Checks for using Fixnum or Bignum constant.
#
# @example
#
#   # bad
#
#   1.is_a?(Fixnum)
#   1.is_a?(Bignum)
# @example
#
#   # good
#
#   1.is_a?(Integer)
#
# source://rubocop//lib/rubocop/cop/lint/unified_integer.rb#20
class RuboCop::Cop::Lint::UnifiedInteger < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/unified_integer.rb#26
  def fixnum_or_bignum_const(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/unified_integer.rb#30
  def on_const(node); end
end

# source://rubocop//lib/rubocop/cop/lint/unified_integer.rb#23
RuboCop::Cop::Lint::UnifiedInteger::MSG = T.let(T.unsafe(nil), String)

# Looks for `reduce` or `inject` blocks where the value returned (implicitly or
# explicitly) does not include the accumulator. A block is considered valid as
# long as at least one return value includes the accumulator.
#
# If the accumulator is not included in the return value, then the entire
# block will just return a transformation of the last element value, and
# could be rewritten as such without a loop.
#
# Also catches instances where an index of the accumulator is returned, as
# this may change the type of object being retained.
#
# NOTE: For the purpose of reducing false positives, this cop only flags
# returns in `reduce` blocks where the element is the only variable in
# the expression (since we will not be able to tell what other variables
# relate to via static analysis).
#
# @example
#
#   # bad
#   (1..4).reduce(0) do |acc, el|
#   el * 2
#   end
#
#   # bad, may raise a NoMethodError after the first iteration
#   %w(a b c).reduce({}) do |acc, letter|
#   acc[letter] = true
#   end
#
#   # good
#   (1..4).reduce(0) do |acc, el|
#   acc + el * 2
#   end
#
#   # good, element is returned but modified using the accumulator
#   values.reduce do |acc, el|
#   el << acc
#   el
#   end
#
#   # good, returns the accumulator instead of the index
#   %w(a b c).reduce({}) do |acc, letter|
#   acc[letter] = true
#   acc
#   end
#
#   # good, at least one branch returns the accumulator
#   values.reduce(nil) do |result, value|
#   break result if something?
#   value
#   end
#
#   # good, recursive
#   keys.reduce(self) { |result, key| result[key] }
#
#   # ignored as the return value cannot be determined
#   enum.reduce do |acc, el|
#   x = foo(acc, el)
#   bar(x)
#   end
#
# source://rubocop//lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#65
class RuboCop::Cop::Lint::UnmodifiedReduceAccumulator < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#78
  def accumulator_index?(param0 = T.unsafe(nil), param1); end

  # source://rubocop//lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#83
  def element_modified?(param0, param1); end

  # source://rubocop//lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#104
  def expression_values(param0); end

  # source://rubocop//lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#93
  def lvar_used?(param0 = T.unsafe(nil), param1); end

  # source://rubocop//lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#115
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#115
  def on_numblock(node); end

  # source://rubocop//lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#70
  def reduce_with_block?(param0 = T.unsafe(nil)); end

  private

  # Determine if a return value is acceptable for the purposes of this cop
  # If it is an expression containing the accumulator, it is acceptable
  # Otherwise, it is only unacceptable if it contains the iterated element, since we
  # otherwise do not have enough information to prevent false positives.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#190
  def acceptable_return?(return_val, element_name); end

  # Exclude `begin` nodes inside a `dstr` from being collected by `return_values`
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#198
  def allowed_type?(parent_node); end

  # source://rubocop//lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#158
  def block_arg_name(node, index); end

  # source://rubocop//lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#141
  def check_return_values(block_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#175
  def potential_offense?(return_values, block_body, element_name, accumulator_name); end

  # Return values in a block are either the value given to next,
  # the last line of a multiline block, or the only line of the block
  #
  # source://rubocop//lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#127
  def return_values(block_body_node); end

  # Look for an index of the accumulator being returned, except where the index
  # is the element.
  # This is always an offense, in order to try to catch potential exceptions
  # due to type mismatches
  #
  # source://rubocop//lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#166
  def returned_accumulator_index(return_values, accumulator_name, element_name); end

  # If the accumulator is used in any return value, the node is acceptable since
  # the accumulator has a chance to change each iteration
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#182
  def returns_accumulator_anywhere?(return_values, accumulator_name); end
end

# source://rubocop//lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#66
RuboCop::Cop::Lint::UnmodifiedReduceAccumulator::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#67
RuboCop::Cop::Lint::UnmodifiedReduceAccumulator::MSG_INDEX = T.let(T.unsafe(nil), String)

# Checks for unreachable code.
# The check are based on the presence of flow of control
# statement in non-final position in `begin` (implicit) blocks.
#
# @example
#
#   # bad
#
#   def some_method
#   return
#   do_something
#   end
#
#   # bad
#
#   def some_method
#   if cond
#   return
#   else
#   return
#   end
#   do_something
#   end
# @example
#
#   # good
#
#   def some_method
#   do_something
#   end
#
# source://rubocop//lib/rubocop/cop/lint/unreachable_code.rb#37
class RuboCop::Cop::Lint::UnreachableCode < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/lint/unreachable_code.rb#55
  def flow_command?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/unreachable_code.rb#40
  def on_begin(node); end

  # source://rubocop//lib/rubocop/cop/lint/unreachable_code.rb#40
  def on_kwbegin(node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/unreachable_code.rb#87
  def check_case(node); end

  # source://rubocop//lib/rubocop/cop/lint/unreachable_code.rb#81
  def check_if(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/unreachable_code.rb#65
  def flow_expression?(node); end
end

# source://rubocop//lib/rubocop/cop/lint/unreachable_code.rb#38
RuboCop::Cop::Lint::UnreachableCode::MSG = T.let(T.unsafe(nil), String)

# Checks for loops that will have at most one iteration.
#
# A loop that can never reach the second iteration is a possible error in the code.
# In rare cases where only one iteration (or at most one iteration) is intended behavior,
# the code should be refactored to use `if` conditionals.
#
# NOTE: Block methods that are used with ``Enumerable``s are considered to be loops.
#
# `AllowedPatterns` can be used to match against the block receiver in order to allow
# code that would otherwise be registered as an offense (eg. `times` used not in an
# `Enumerable` context).
#
# @example
#   # bad
#   while node
#   do_something(node)
#   node = node.parent
#   break
#   end
#
#   # good
#   while node
#   do_something(node)
#   node = node.parent
#   end
#
#   # bad
#   def verify_list(head)
#   item = head
#   begin
#   if verify(item)
#   return true
#   else
#   return false
#   end
#   end while(item)
#   end
#
#   # good
#   def verify_list(head)
#   item = head
#   begin
#   if verify(item)
#   item = item.next
#   else
#   return false
#   end
#   end while(item)
#
#   true
#   end
#
#   # bad
#   def find_something(items)
#   items.each do |item|
#   if something?(item)
#   return item
#   else
#   raise NotFoundError
#   end
#   end
#   end
#
#   # good
#   def find_something(items)
#   items.each do |item|
#   if something?(item)
#   return item
#   end
#   end
#   raise NotFoundError
#   end
#
#   # bad
#   2.times { raise ArgumentError }
# @example AllowedPatterns: ['(exactly|at_least|at_most)\(\d+\)\.times'] (default)
#
#   # good
#   exactly(2).times { raise StandardError }
#
# source://rubocop//lib/rubocop/cop/lint/unreachable_loop.rb#86
class RuboCop::Cop::Lint::UnreachableLoop < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::AllowedPattern

  # source://rubocop//lib/rubocop/cop/lint/unreachable_loop.rb#143
  def break_command?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/unreachable_loop.rb#100
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/lint/unreachable_loop.rb#92
  def on_for(node); end

  # source://rubocop//lib/rubocop/cop/lint/unreachable_loop.rb#104
  def on_numblock(node); end

  # source://rubocop//lib/rubocop/cop/lint/unreachable_loop.rb#92
  def on_until(node); end

  # source://rubocop//lib/rubocop/cop/lint/unreachable_loop.rb#92
  def on_until_post(node); end

  # source://rubocop//lib/rubocop/cop/lint/unreachable_loop.rb#92
  def on_while(node); end

  # source://rubocop//lib/rubocop/cop/lint/unreachable_loop.rb#92
  def on_while_post(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/unreachable_loop.rb#153
  def break_statement?(node); end

  # source://rubocop//lib/rubocop/cop/lint/unreachable_loop.rb#119
  def check(node); end

  # source://rubocop//lib/rubocop/cop/lint/unreachable_loop.rb#176
  def check_case(node); end

  # source://rubocop//lib/rubocop/cop/lint/unreachable_loop.rb#170
  def check_if(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/unreachable_loop.rb#194
  def conditional_continue_keyword?(break_statement); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/unreachable_loop.rb#110
  def loop_method?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/unreachable_loop.rb#184
  def preceded_by_continue_statement?(break_statement); end

  # source://rubocop//lib/rubocop/cop/lint/unreachable_loop.rb#130
  def statements(node); end
end

# source://rubocop//lib/rubocop/cop/lint/unreachable_loop.rb#90
RuboCop::Cop::Lint::UnreachableLoop::CONTINUE_KEYWORDS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/unreachable_loop.rb#89
RuboCop::Cop::Lint::UnreachableLoop::MSG = T.let(T.unsafe(nil), String)

# Common functionality for cops handling unused arguments.
#
# source://rubocop//lib/rubocop/cop/mixin/unused_argument.rb#7
module RuboCop::Cop::Lint::UnusedArgument
  extend ::RuboCop::AST::NodePattern::Macros

  # source://rubocop//lib/rubocop/cop/mixin/unused_argument.rb#10
  def after_leaving_scope(scope, _variable_table); end

  private

  # source://rubocop//lib/rubocop/cop/mixin/unused_argument.rb#16
  def check_argument(variable); end
end

# Checks for unused block arguments.
#
# @example
#   # bad
#   do_something do |used, unused|
#   puts used
#   end
#
#   do_something do |bar|
#   puts :foo
#   end
#
#   define_method(:foo) do |bar|
#   puts :baz
#   end
#
#   # good
#   do_something do |used, _unused|
#   puts used
#   end
#
#   do_something do
#   puts :foo
#   end
#
#   define_method(:foo) do |_bar|
#   puts :baz
#   end
# @example IgnoreEmptyBlocks: true (default)
#   # good
#   do_something { |unused| }
# @example IgnoreEmptyBlocks: false
#   # bad
#   do_something { |unused| }
# @example AllowUnusedKeywordArguments: false (default)
#   # bad
#   do_something do |unused: 42|
#   foo
#   end
# @example AllowUnusedKeywordArguments: true
#   # good
#   do_something do |unused: 42|
#   foo
#   end
#
# source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#55
class RuboCop::Cop::Lint::UnusedBlockArgument < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Lint::UnusedArgument
  extend ::RuboCop::Cop::AutoCorrector

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#162
  def allow_unused_keyword_arguments?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#81
  def allowed_block?(variable); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#85
  def allowed_keyword_argument?(variable); end

  # source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#99
  def augment_message(message, variable); end

  # source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#65
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#69
  def check_argument(variable); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#149
  def define_method_call?(variable); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#156
  def empty_block?(variable); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#166
  def ignore_empty_blocks?; end

  # source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#89
  def message(variable); end

  # source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#132
  def message_for_lambda(variable, all_arguments); end

  # source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#120
  def message_for_normal_block(variable, all_arguments); end

  # source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#144
  def message_for_underscore_prefix(variable); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#77
  def used_block_local?(variable); end

  # source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#112
  def variable_type(variable); end

  class << self
    # source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#59
    def joining_forces; end
  end
end

# Checks for unused method arguments.
#
# @example
#   # bad
#   def some_method(used, unused, _unused_but_allowed)
#   puts used
#   end
#
#   # good
#   def some_method(used, _unused, _unused_but_allowed)
#   puts used
#   end
# @example AllowUnusedKeywordArguments: false (default)
#   # bad
#   def do_something(used, unused: 42)
#   used
#   end
# @example AllowUnusedKeywordArguments: true
#   # good
#   def do_something(used, unused: 42)
#   used
#   end
# @example IgnoreEmptyMethods: true (default)
#   # good
#   def do_something(unused)
#   end
# @example IgnoreEmptyMethods: false
#   # bad
#   def do_something(unused)
#   end
# @example IgnoreNotImplementedMethods: true (default)
#   # good
#   def do_something(unused)
#   raise NotImplementedError
#   end
#
#   def do_something_else(unused)
#   fail "TODO"
#   end
# @example IgnoreNotImplementedMethods: false
#   # bad
#   def do_something(unused)
#   raise NotImplementedError
#   end
#
#   def do_something_else(unused)
#   fail "TODO"
#   end
#
# source://rubocop//lib/rubocop/cop/lint/unused_method_argument.rb#61
class RuboCop::Cop::Lint::UnusedMethodArgument < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Lint::UnusedArgument
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/unused_method_argument.rb#66
  def not_implemented?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/lint/unused_method_argument.rb#81
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/lint/unused_method_argument.rb#85
  def check_argument(variable); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/unused_method_argument.rb#93
  def ignored_method?(body); end

  # source://rubocop//lib/rubocop/cop/lint/unused_method_argument.rb#98
  def message(variable); end

  class << self
    # source://rubocop//lib/rubocop/cop/lint/unused_method_argument.rb#71
    def autocorrect_incompatible_with; end

    # source://rubocop//lib/rubocop/cop/lint/unused_method_argument.rb#75
    def joining_forces; end
  end
end

# Identifies places where `URI.escape` can be replaced by
# `CGI.escape`, `URI.encode_www_form`, or `URI.encode_www_form_component`
# depending on your specific use case.
# Also this cop identifies places where `URI.unescape` can be replaced by
# `CGI.unescape`, `URI.decode_www_form`,
# or `URI.decode_www_form_component` depending on your specific use case.
#
# @example
#   # bad
#   URI.escape('http://example.com')
#   URI.encode('http://example.com')
#
#   # good
#   CGI.escape('http://example.com')
#   URI.encode_www_form([['example', 'param'], ['lang', 'en']])
#   URI.encode_www_form(page: 10, locale: 'en')
#   URI.encode_www_form_component('http://example.com')
#
#   # bad
#   URI.unescape(enc_uri)
#   URI.decode(enc_uri)
#
#   # good
#   CGI.unescape(enc_uri)
#   URI.decode_www_form(enc_uri)
#   URI.decode_www_form_component(enc_uri)
#
# source://rubocop//lib/rubocop/cop/lint/uri_escape_unescape.rb#32
class RuboCop::Cop::Lint::UriEscapeUnescape < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/lint/uri_escape_unescape.rb#57
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/lint/uri_escape_unescape.rb#51
  def uri_escape_unescape?(param0 = T.unsafe(nil)); end
end

# source://rubocop//lib/rubocop/cop/lint/uri_escape_unescape.rb#33
RuboCop::Cop::Lint::UriEscapeUnescape::ALTERNATE_METHODS_OF_URI_ESCAPE = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/uri_escape_unescape.rb#38
RuboCop::Cop::Lint::UriEscapeUnescape::ALTERNATE_METHODS_OF_URI_UNESCAPE = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/uri_escape_unescape.rb#47
RuboCop::Cop::Lint::UriEscapeUnescape::METHOD_NAMES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/uri_escape_unescape.rb#44
RuboCop::Cop::Lint::UriEscapeUnescape::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/uri_escape_unescape.rb#48
RuboCop::Cop::Lint::UriEscapeUnescape::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Identifies places where `URI.regexp` is obsolete and should
# not be used. Instead, use `URI::DEFAULT_PARSER.make_regexp`.
#
# @example
#   # bad
#   URI.regexp('http://example.com')
#
#   # good
#   URI::DEFAULT_PARSER.make_regexp('http://example.com')
#
# source://rubocop//lib/rubocop/cop/lint/uri_regexp.rb#16
class RuboCop::Cop::Lint::UriRegexp < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/uri_regexp.rb#23
  def on_send(node); end
end

# source://rubocop//lib/rubocop/cop/lint/uri_regexp.rb#19
RuboCop::Cop::Lint::UriRegexp::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/uri_regexp.rb#21
RuboCop::Cop::Lint::UriRegexp::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/uri_regexp.rb#20
RuboCop::Cop::Lint::UriRegexp::URI_CONSTANTS = T.let(T.unsafe(nil), Array)

# Checks for redundant access modifiers, including those with no
# code, those which are repeated, and leading `public` modifiers in a
# class or module body. Conditionally-defined methods are considered as
# always being defined, and thus access modifiers guarding such methods
# are not redundant.
#
# This cop has `ContextCreatingMethods` option. The default setting value
# is an empty array that means no method is specified.
# This setting is an array of methods which, when called, are known to
# create its own context in the module's current access context.
#
# It also has `MethodCreatingMethods` option. The default setting value
# is an empty array that means no method is specified.
# This setting is an array of methods which, when called, are known to
# create other methods in the module's current access context.
#
# @example
#   # bad
#   class Foo
#   public # this is redundant (default access is public)
#
#   def method
#   end
#   end
#
#   # bad
#   class Foo
#   # The following is redundant (methods defined on the class'
#   # singleton class are not affected by the private modifier)
#   private
#
#   def self.method3
#   end
#   end
#
#   # bad
#   class Foo
#   protected
#
#   define_method(:method2) do
#   end
#
#   protected # this is redundant (repeated from previous modifier)
#
#   [1,2,3].each do |i|
#   define_method("foo#{i}") do
#   end
#   end
#   end
#
#   # bad
#   class Foo
#   private # this is redundant (no following methods are defined)
#   end
#
#   # good
#   class Foo
#   private # this is not redundant (a method is defined)
#
#   def method2
#   end
#   end
#
#   # good
#   class Foo
#   # The following is not redundant (conditionally defined methods are
#   # considered as always defining a method)
#   private
#
#   if condition?
#   def method
#   end
#   end
#   end
#
#   # good
#   class Foo
#   protected # this is not redundant (a method is defined)
#
#   define_method(:method2) do
#   end
#   end
# @example ContextCreatingMethods: concerning
#   # Lint/UselessAccessModifier:
#   #   ContextCreatingMethods:
#   #     - concerning
#
#   # good
#   require 'active_support/concern'
#   class Foo
#   concerning :Bar do
#   def some_public_method
#   end
#
#   private
#
#   def some_private_method
#   end
#   end
#
#   # this is not redundant because `concerning` created its own context
#   private
#
#   def some_other_private_method
#   end
#   end
# @example MethodCreatingMethods: delegate
#   # Lint/UselessAccessModifier:
#   #   MethodCreatingMethods:
#   #     - delegate
#
#   # good
#   require 'active_support/core_ext/module/delegation'
#   class Foo
#   # this is not redundant because `delegate` creates methods
#   private
#
#   delegate :method_a, to: :method_b
#   end
#
# source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#127
class RuboCop::Cop::Lint::UselessAccessModifier < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#166
  def class_or_instance_eval?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#161
  def dynamic_method_definition?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#139
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#133
  def on_class(node); end

  # source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#133
  def on_module(node); end

  # source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#139
  def on_numblock(node); end

  # source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#133
  def on_sclass(node); end

  # source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#156
  def static_method_definition?(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#182
  def access_modifier?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#280
  def any_context_creating_methods?(child); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#257
  def any_method_definition?(child); end

  # source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#149
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#196
  def check_child_nodes(node, unused, cur_vis); end

  # source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#226
  def check_new_visibility(node, unused, new_vis, cur_vis); end

  # source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#170
  def check_node(node); end

  # source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#186
  def check_scope(node); end

  # source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#215
  def check_send_node(node, cur_vis, unused); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#274
  def eval_call?(child); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#247
  def included_block?(block_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#251
  def method_definition?(child); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#270
  def start_of_new_scope?(child); end
end

# source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#131
RuboCop::Cop::Lint::UselessAccessModifier::MSG = T.let(T.unsafe(nil), String)

# Checks for every useless assignment to local variable in every
# scope.
# The basic idea for this cop was from the warning of `ruby -cw`:
#
#   assigned but unused variable - foo
#
# Currently this cop has advanced logic that detects unreferenced
# reassignments and properly handles varied cases such as branch, loop,
# rescue, ensure, etc.
#
# @example
#
#   # bad
#
#   def some_method
#   some_var = 1
#   do_something
#   end
# @example
#
#   # good
#
#   def some_method
#   some_var = 1
#   do_something(some_var)
#   end
#
# source://rubocop//lib/rubocop/cop/lint/useless_assignment.rb#33
class RuboCop::Cop::Lint::UselessAssignment < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/lint/useless_assignment.rb#40
  def after_leaving_scope(scope, _variable_table); end

  # source://rubocop//lib/rubocop/cop/lint/useless_assignment.rb#44
  def check_for_unused_assignments(variable); end

  # source://rubocop//lib/rubocop/cop/lint/useless_assignment.rb#108
  def collect_variable_like_names(scope); end

  # source://rubocop//lib/rubocop/cop/lint/useless_assignment.rb#62
  def message_for_useless_assignment(assignment); end

  # source://rubocop//lib/rubocop/cop/lint/useless_assignment.rb#68
  def message_specification(assignment, variable); end

  # source://rubocop//lib/rubocop/cop/lint/useless_assignment.rb#78
  def multiple_assignment_message(variable_name); end

  # source://rubocop//lib/rubocop/cop/lint/useless_assignment.rb#83
  def operator_assignment_message(scope, assignment); end

  # TODO: More precise handling (rescue, ensure, nested begin, etc.)
  #
  # source://rubocop//lib/rubocop/cop/lint/useless_assignment.rb#98
  def return_value_node_of_scope(scope); end

  # source://rubocop//lib/rubocop/cop/lint/useless_assignment.rb#91
  def similar_name_message(variable); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/useless_assignment.rb#117
  def variable_like_method_invocation?(node); end

  class << self
    # source://rubocop//lib/rubocop/cop/lint/useless_assignment.rb#36
    def joining_forces; end
  end
end

# source://rubocop//lib/rubocop/cop/lint/useless_assignment.rb#34
RuboCop::Cop::Lint::UselessAssignment::MSG = T.let(T.unsafe(nil), String)

# Checks for useless `else` in `begin..end` without `rescue`.
#
# NOTE: This syntax is no longer valid on Ruby 2.6 or higher.
#
# @example
#
#   # bad
#
#   begin
#   do_something
#   else
#   do_something_else # This will never be run.
#   end
# @example
#
#   # good
#
#   begin
#   do_something
#   rescue
#   handle_errors
#   else
#   do_something_else
#   end
#
# source://rubocop//lib/rubocop/cop/lint/useless_else_without_rescue.rb#31
class RuboCop::Cop::Lint::UselessElseWithoutRescue < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/lint/useless_else_without_rescue.rb#34
  def on_new_investigation; end
end

# source://rubocop//lib/rubocop/cop/lint/useless_else_without_rescue.rb#32
RuboCop::Cop::Lint::UselessElseWithoutRescue::MSG = T.let(T.unsafe(nil), String)

# Checks for useless method definitions, specifically: empty constructors
# and methods just delegating to `super`.
#
# @example
#   # bad
#   def initialize
#   super
#   end
#
#   def method
#   super
#   end
#
#   # good - with default arguments
#   def initialize(x = Object.new)
#   super
#   end
#
#   # good
#   def initialize
#   super
#   initialize_internals
#   end
#
#   def method(*args)
#   super(:extra_arg, *args)
#   end
#
# source://rubocop//lib/rubocop/cop/lint/useless_method_definition.rb#38
class RuboCop::Cop::Lint::UselessMethodDefinition < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/useless_method_definition.rb#43
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/lint/useless_method_definition.rb#43
  def on_defs(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/useless_method_definition.rb#65
  def delegating?(node, def_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/useless_method_definition.rb#57
  def method_definition_with_modifier?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/useless_method_definition.rb#61
  def use_rest_or_optional_args?(node); end
end

# source://rubocop//lib/rubocop/cop/lint/useless_method_definition.rb#41
RuboCop::Cop::Lint::UselessMethodDefinition::MSG = T.let(T.unsafe(nil), String)

# Checks for useless `rescue`s, which only reraise rescued exceptions.
#
# @example
#   # bad
#   def foo
#   do_something
#   rescue
#   raise
#   end
#
#   # bad
#   def foo
#   do_something
#   rescue => e
#   raise # or 'raise e', or 'raise $!', or 'raise $ERROR_INFO'
#   end
#
#   # good
#   def foo
#   do_something
#   rescue
#   do_cleanup
#   raise
#   end
#
#   # bad (latest rescue)
#   def foo
#   do_something
#   rescue ArgumentError
#   # noop
#   rescue
#   raise
#   end
#
#   # good (not the latest rescue)
#   def foo
#   do_something
#   rescue ArgumentError
#   raise
#   rescue
#   # noop
#   end
#
# source://rubocop//lib/rubocop/cop/lint/useless_rescue.rb#49
class RuboCop::Cop::Lint::UselessRescue < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/lint/useless_rescue.rb#52
  def on_rescue(node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/useless_rescue.rb#83
  def exception_objects(resbody_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/useless_rescue.rb#60
  def only_reraising?(resbody_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/useless_rescue.rb#75
  def use_exception_variable_in_ensure?(resbody_node); end
end

# source://rubocop//lib/rubocop/cop/lint/useless_rescue.rb#50
RuboCop::Cop::Lint::UselessRescue::MSG = T.let(T.unsafe(nil), String)

# Looks for `ruby2_keywords` calls for methods that do not need it.
#
# `ruby2_keywords` should only be called on methods that accept an argument splat
# (`\*args`) but do not explicit keyword arguments (`k:` or `k: true`) or
# a keyword splat (`**kwargs`).
#
# @example
#   # good (splat argument without keyword arguments)
#   ruby2_keywords def foo(*args); end
#
#   # bad (no arguments)
#   ruby2_keywords def foo; end
#
#   # good
#   def foo; end
#
#   # bad (positional argument)
#   ruby2_keywords def foo(arg); end
#
#   # good
#   def foo(arg); end
#
#   # bad (double splatted argument)
#   ruby2_keywords def foo(**args); end
#
#   # good
#   def foo(**args); end
#
#   # bad (keyword arguments)
#   ruby2_keywords def foo(i:, j:); end
#
#   # good
#   def foo(i:, j:); end
#
#   # bad (splat argument with keyword arguments)
#   ruby2_keywords def foo(*args, i:, j:); end
#
#   # good
#   def foo(*args, i:, j:); end
#
#   # bad (splat argument with double splat)
#   ruby2_keywords def foo(*args, **kwargs); end
#
#   # good
#   def foo(*args, **kwargs); end
#
#   # bad (ruby2_keywords given a symbol)
#   def foo; end
#   ruby2_keywords :foo
#
#   # good
#   def foo; end
#
#   # bad (ruby2_keywords with dynamic method)
#   define_method(:foo) { |arg| }
#   ruby2_keywords :foo
#
#   # good
#   define_method(:foo) { |arg| }
#
# source://rubocop//lib/rubocop/cop/lint/useless_ruby2_keywords.rb#66
class RuboCop::Cop::Lint::UselessRuby2Keywords < ::RuboCop::Cop::Base
  # Looks for statically or dynamically defined methods with a given name
  #
  # source://rubocop//lib/rubocop/cop/lint/useless_ruby2_keywords.rb#72
  def method_definition(param0 = T.unsafe(nil), param1); end

  # source://rubocop//lib/rubocop/cop/lint/useless_ruby2_keywords.rb#79
  def on_send(node); end

  private

  # `ruby2_keywords` is only allowed if there's a `restarg` and no keyword arguments
  #
  # source://rubocop//lib/rubocop/cop/lint/useless_ruby2_keywords.rb#118
  def allowed_arguments(arguments); end

  # source://rubocop//lib/rubocop/cop/lint/useless_ruby2_keywords.rb#109
  def find_method_definition(node, method_name); end

  # source://rubocop//lib/rubocop/cop/lint/useless_ruby2_keywords.rb#91
  def inspect_def(node, def_node); end

  # source://rubocop//lib/rubocop/cop/lint/useless_ruby2_keywords.rb#97
  def inspect_sym(node, sym_node); end
end

# source://rubocop//lib/rubocop/cop/lint/useless_ruby2_keywords.rb#67
RuboCop::Cop::Lint::UselessRuby2Keywords::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/useless_ruby2_keywords.rb#68
RuboCop::Cop::Lint::UselessRuby2Keywords::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for setter call to local variable as the final
# expression of a function definition.
#
# @example
#
#   # bad
#
#   def something
#   x = Something.new
#   x.attr = 5
#   end
# @example
#
#   # good
#
#   def something
#   x = Something.new
#   x.attr = 5
#   x
#   end
#
# source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#35
class RuboCop::Cop::Lint::UselessSetterCall < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#41
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#41
  def on_defs(node); end

  # source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#63
  def setter_call_to_local_variable?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#67
  def last_expression(body); end
end

# source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#39
RuboCop::Cop::Lint::UselessSetterCall::ASSIGNMENT_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#38
RuboCop::Cop::Lint::UselessSetterCall::MSG = T.let(T.unsafe(nil), String)

# This class tracks variable assignments in a method body
# and if a variable contains object passed as argument at the end of
# the method.
#
# source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#76
class RuboCop::Cop::Lint::UselessSetterCall::MethodVariableTracker
  # @return [MethodVariableTracker] a new instance of MethodVariableTracker
  #
  # source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#77
  def initialize(body_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#163
  def constructor?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#82
  def contain_local_object?(variable_name); end

  # source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#152
  def process_assignment(asgn_node, rhs_node); end

  # source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#100
  def process_assignment_node(node); end

  # source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#142
  def process_binary_operator_assignment(op_asgn_node); end

  # source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#133
  def process_logical_operator_assignment(asgn_node); end

  # source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#114
  def process_multiple_assignment(masgn_node); end

  # source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#92
  def scan(node, &block); end
end

# Checks for uses of `Integer#times` that will never yield
# (when the integer <= 0) or that will only ever yield once
# (`1.times`).
#
# @example
#   # bad
#   -5.times { do_something }
#   0.times { do_something }
#   1.times { do_something  }
#   1.times { |i| do_something(i) }
#
#   # good
#   do_something
#   do_something(1)
#
# source://rubocop//lib/rubocop/cop/lint/useless_times.rb#24
class RuboCop::Cop::Lint::UselessTimes < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/lint/useless_times.rb#37
  def block_arg(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/lint/useless_times.rb#42
  def block_reassigns_arg?(param0, param1); end

  # source://rubocop//lib/rubocop/cop/lint/useless_times.rb#46
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/lint/useless_times.rb#32
  def times_call?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/lint/useless_times.rb#62
  def autocorrect(corrector, count, node, proc_name); end

  # source://rubocop//lib/rubocop/cop/lint/useless_times.rb#84
  def autocorrect_block(corrector, node); end

  # source://rubocop//lib/rubocop/cop/lint/useless_times.rb#80
  def autocorrect_block_pass(corrector, node, proc_name); end

  # source://rubocop//lib/rubocop/cop/lint/useless_times.rb#94
  def fix_indentation(source, range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/useless_times.rb#72
  def never_process?(count, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/useless_times.rb#106
  def own_line?(node); end

  # source://rubocop//lib/rubocop/cop/lint/useless_times.rb#76
  def remove_node(corrector, node); end
end

# source://rubocop//lib/rubocop/cop/lint/useless_times.rb#28
RuboCop::Cop::Lint::UselessTimes::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/useless_times.rb#29
RuboCop::Cop::Lint::UselessTimes::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for operators, variables, literals, lambda, proc and nonmutating
# methods used in void context.
#
# @example CheckForMethodsWithNoSideEffects: false (default)
#   # bad
#   def some_method
#   some_num * 10
#   do_something
#   end
#
#   def some_method(some_var)
#   some_var
#   do_something
#   end
# @example CheckForMethodsWithNoSideEffects: true
#   # bad
#   def some_method(some_array)
#   some_array.sort
#   do_something(some_array)
#   end
#
#   # good
#   def some_method
#   do_something
#   some_num * 10
#   end
#
#   def some_method(some_var)
#   do_something
#   some_var
#   end
#
#   def some_method(some_array)
#   some_array.sort!
#   do_something(some_array)
#   end
#
# source://rubocop//lib/rubocop/cop/lint/void.rb#43
class RuboCop::Cop::Lint::Void < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/lint/void.rb#76
  def on_begin(node); end

  # source://rubocop//lib/rubocop/cop/lint/void.rb#67
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/lint/void.rb#76
  def on_kwbegin(node); end

  # source://rubocop//lib/rubocop/cop/lint/void.rb#67
  def on_numblock(node); end

  private

  # source://rubocop//lib/rubocop/cop/lint/void.rb#83
  def check_begin(node); end

  # source://rubocop//lib/rubocop/cop/lint/void.rb#89
  def check_expression(expr); end

  # source://rubocop//lib/rubocop/cop/lint/void.rb#112
  def check_literal(node); end

  # source://rubocop//lib/rubocop/cop/lint/void.rb#130
  def check_nonmutating(node); end

  # source://rubocop//lib/rubocop/cop/lint/void.rb#118
  def check_self(node); end

  # source://rubocop//lib/rubocop/cop/lint/void.rb#106
  def check_var(node); end

  # source://rubocop//lib/rubocop/cop/lint/void.rb#124
  def check_void_expression(node); end

  # source://rubocop//lib/rubocop/cop/lint/void.rb#100
  def check_void_op(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/lint/void.rb#145
  def in_void_context?(node); end
end

# source://rubocop//lib/rubocop/cop/lint/void.rb#51
RuboCop::Cop::Lint::Void::BINARY_OPERATORS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/void.rb#48
RuboCop::Cop::Lint::Void::EXPRESSION_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/void.rb#46
RuboCop::Cop::Lint::Void::LIT_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/void.rb#62
RuboCop::Cop::Lint::Void::METHODS_REPLACEABLE_BY_EACH = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/void.rb#64
RuboCop::Cop::Lint::Void::NONMUTATING_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/void.rb#55
RuboCop::Cop::Lint::Void::NONMUTATING_METHODS_WITH_BANG_VERSION = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/void.rb#49
RuboCop::Cop::Lint::Void::NONMUTATING_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/void.rb#53
RuboCop::Cop::Lint::Void::OPERATORS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/void.rb#44
RuboCop::Cop::Lint::Void::OP_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/void.rb#47
RuboCop::Cop::Lint::Void::SELF_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/void.rb#52
RuboCop::Cop::Lint::Void::UNARY_OPERATORS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/lint/void.rb#45
RuboCop::Cop::Lint::Void::VAR_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/lint/void.rb#54
RuboCop::Cop::Lint::Void::VOID_CONTEXT_TYPES = T.let(T.unsafe(nil), Array)

# Common functionality for obtaining source ranges from regexp matches
#
# source://rubocop//lib/rubocop/cop/mixin/match_range.rb#6
module RuboCop::Cop::MatchRange
  include ::RuboCop::Cop::RangeHelp

  private

  # Return a new `Range` covering the first matching group number for each
  # match of `regex` inside `range`
  #
  # source://rubocop//lib/rubocop/cop/mixin/match_range.rb#13
  def each_match_range(range, regex); end

  # For a `match` inside `range`, return a new `Range` covering the match
  #
  # source://rubocop//lib/rubocop/cop/mixin/match_range.rb#18
  def match_range(range, match); end
end

# Message Annotator class annotates a basic offense message
# based on params passed into initializer.
#
#  #=> 'Cop/CopName: message (http://example.org/styleguide)'
#
# @example
#   RuboCop::Cop::MessageAnnotator.new(
#   config, cop_name, cop_config, @options
#   ).annotate('message')
# @see #initialize
#
# source://rubocop//lib/rubocop/cop/message_annotator.rb#15
class RuboCop::Cop::MessageAnnotator
  # @option cop_config
  # @option cop_config
  # @option cop_config
  # @option options
  # @option options
  # @option options
  # @option options
  # @param config [RuboCop::Config] Check configs for all cops
  #   @note Message Annotator specifically checks the
  #   following config options for_all_cops
  #   :StyleGuideBaseURL [String] URL for styleguide
  #   :DisplayStyleGuide [Boolean] Include styleguide and reference URLs
  #   :ExtraDetails [Boolean] Include cop details
  #   :DisplayCopNames [Boolean] Include cop name
  # @param cop_name [String] for specific cop name
  # @param cop_config [Hash] configs for specific cop, from config#for_cop
  # @param options [Hash, nil] optional
  # @return [MessageAnnotator] a new instance of MessageAnnotator
  #
  # source://rubocop//lib/rubocop/cop/message_annotator.rb#47
  def initialize(config, cop_name, cop_config, options); end

  # Returns the annotated message,
  # based on params passed into initializer
  #
  # @return [String] annotated message
  #
  # source://rubocop//lib/rubocop/cop/message_annotator.rb#58
  def annotate(message); end

  # Returns the value of attribute config.
  #
  # source://rubocop//lib/rubocop/cop/message_annotator.rb#16
  def config; end

  # Returns the value of attribute cop_config.
  #
  # source://rubocop//lib/rubocop/cop/message_annotator.rb#16
  def cop_config; end

  # Returns the value of attribute cop_name.
  #
  # source://rubocop//lib/rubocop/cop/message_annotator.rb#16
  def cop_name; end

  # Returns the value of attribute options.
  #
  # source://rubocop//lib/rubocop/cop/message_annotator.rb#16
  def options; end

  # source://rubocop//lib/rubocop/cop/message_annotator.rb#68
  def urls; end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/message_annotator.rb#111
  def debug?; end

  # source://rubocop//lib/rubocop/cop/message_annotator.rb#124
  def details; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/message_annotator.rb#115
  def display_cop_names?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/message_annotator.rb#98
  def display_style_guide?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/message_annotator.rb#107
  def extra_details?; end

  # source://rubocop//lib/rubocop/cop/message_annotator.rb#102
  def reference_urls; end

  # Returns the base style guide URL from AllCops or the specific department
  #
  # @return [String] style guide URL
  #
  # source://rubocop//lib/rubocop/cop/message_annotator.rb#91
  def style_guide_base_url; end

  # source://rubocop//lib/rubocop/cop/message_annotator.rb#74
  def style_guide_url; end

  class << self
    # Returns the value of attribute style_guide_urls.
    #
    # source://rubocop//lib/rubocop/cop/message_annotator.rb#21
    def style_guide_urls; end
  end
end

# This module handles measurement and reporting of complexity in methods.
#
# @api private
#
# source://rubocop//lib/rubocop/cop/mixin/method_complexity.rb#8
module RuboCop::Cop::MethodComplexity
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::AllowedPattern
  include ::RuboCop::Cop::Metrics::Utils::RepeatedCsendDiscount
  extend ::RuboCop::AST::NodePattern::Macros
  extend ::RuboCop::ExcludeLimit

  # source://rubocop//lib/rubocop/cop/mixin/method_complexity.rb#37
  def define_method?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/exclude_limit.rb#11
  def max=(value); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/mixin/method_complexity.rb#24
  def on_block(node); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/mixin/method_complexity.rb#17
  def on_def(node); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/mixin/method_complexity.rb#17
  def on_defs(node); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/mixin/method_complexity.rb#24
  def on_numblock(node); end

  private

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/mixin/method_complexity.rb#42
  def check_complexity(node, method_name); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/mixin/method_complexity.rb#61
  def complexity(body); end
end

# Common code for cops that deal with preferred methods.
#
# source://rubocop//lib/rubocop/cop/mixin/method_preference.rb#6
module RuboCop::Cop::MethodPreference
  private

  # source://rubocop//lib/rubocop/cop/mixin/method_preference.rb#25
  def default_cop_config; end

  # source://rubocop//lib/rubocop/cop/mixin/method_preference.rb#9
  def preferred_method(method); end

  # source://rubocop//lib/rubocop/cop/mixin/method_preference.rb#13
  def preferred_methods; end
end

# source://rubocop//lib/rubocop/cop/metrics/utils/repeated_csend_discount.rb#5
module RuboCop::Cop::Metrics; end

# Checks that the ABC size of methods is not higher than the
# configured maximum. The ABC size is based on assignments, branches
# (method calls), and conditions. See http://c2.com/cgi/wiki?AbcMetric
# and https://en.wikipedia.org/wiki/ABC_Software_Metric.
#
# Interpreting ABC size:
#
# * <= 17 satisfactory
# * 18..30 unsatisfactory
# * > 30 dangerous
#
# You can have repeated "attributes" calls count as a single "branch".
# For this purpose, attributes are any method with no argument; no attempt
# is meant to distinguish actual `attr_reader` from other methods.
#
# This cop also takes into account `AllowedMethods` (defaults to `[]`)
# And `AllowedPatterns` (defaults to `[]`)
#
# @example CountRepeatedAttributes: false (default is true)
#
#   # `model` and `current_user`, referenced 3 times each,
#   # are each counted as only 1 branch each if
#   # `CountRepeatedAttributes` is set to 'false'
#
#   def search
#   @posts = model.active.visible_by(current_user)
#   .search(params[:q])
#   @posts = model.some_process(@posts, current_user)
#   @posts = model.another_process(@posts, current_user)
#
#   render 'pages/search/page'
#   end
#
# source://rubocop//lib/rubocop/cop/metrics/abc_size.rb#39
class RuboCop::Cop::Metrics::AbcSize < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::AllowedPattern
  include ::RuboCop::Cop::Metrics::Utils::RepeatedCsendDiscount
  include ::RuboCop::Cop::MethodComplexity

  private

  # source://rubocop//lib/rubocop/cop/metrics/abc_size.rb#47
  def complexity(node); end
end

# source://rubocop//lib/rubocop/cop/metrics/abc_size.rb#42
RuboCop::Cop::Metrics::AbcSize::MSG = T.let(T.unsafe(nil), String)

# Checks if the length of a block exceeds some maximum value.
# Comment lines can optionally be ignored.
# The maximum allowed length is configurable.
# The cop can be configured to ignore blocks passed to certain methods.
#
# You can set constructs you want to fold with `CountAsOne`.
# Available are: 'array', 'hash', 'heredoc', and 'method_call'. Each construct
# will be counted as one line regardless of its actual size.
#
#
# NOTE: The `ExcludedMethods` configuration is deprecated and only kept
# for backwards compatibility. Please use `AllowedMethods` and `AllowedPatterns`
# instead. By default, there are no methods to allowed.
#
# NOTE: This cop does not apply for `Struct` definitions.
#
# @example CountAsOne: ['array', 'heredoc', 'method_call']
#
#   something do
#   array = [         # +1
#   1,
#   2
#   ]
#
#   hash = {          # +3
#   key: 'value'
#   }
#
#   msg = <<~HEREDOC  # +1
#   Heredoc
#   content.
#   HEREDOC
#
#   foo(              # +1
#   1,
#   2
#   )
#   end                 # 6 points
#
# source://rubocop//lib/rubocop/cop/metrics/block_length.rb#44
class RuboCop::Cop::Metrics::BlockLength < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::AllowedPattern

  # source://rubocop//lib/rubocop/cop/metrics/block_length.rb#51
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/metrics/block_length.rb#51
  def on_numblock(node); end

  private

  # source://rubocop//lib/rubocop/cop/metrics/block_length.rb#80
  def cop_label; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/metrics/block_length.rb#62
  def method_receiver_excluded?(node); end
end

# source://rubocop//lib/rubocop/cop/metrics/block_length.rb#49
RuboCop::Cop::Metrics::BlockLength::LABEL = T.let(T.unsafe(nil), String)

# Checks for excessive nesting of conditional and looping
# constructs.
#
# You can configure if blocks are considered using the `CountBlocks`
# option. When set to `false` (the default) blocks are not counted
# towards the nesting level. Set to `true` to count blocks as well.
#
# The maximum level of nesting allowed is configurable.
#
# source://rubocop//lib/rubocop/cop/metrics/block_nesting.rb#14
class RuboCop::Cop::Metrics::BlockNesting < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/exclude_limit.rb#11
  def max=(value); end

  # source://rubocop//lib/rubocop/cop/metrics/block_nesting.rb#19
  def on_new_investigation; end

  private

  # source://rubocop//lib/rubocop/cop/metrics/block_nesting.rb#28
  def check_nesting_level(node, max, current_level); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/metrics/block_nesting.rb#44
  def consider_node?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/metrics/block_nesting.rb#54
  def count_blocks?; end

  # source://rubocop//lib/rubocop/cop/metrics/block_nesting.rb#50
  def message(max); end
end

# source://rubocop//lib/rubocop/cop/metrics/block_nesting.rb#15
RuboCop::Cop::Metrics::BlockNesting::NESTING_BLOCKS = T.let(T.unsafe(nil), Array)

# Checks if the length of a class exceeds some maximum value.
# Comment lines can optionally be ignored.
# The maximum allowed length is configurable.
#
# You can set constructs you want to fold with `CountAsOne`.
# Available are: 'array', 'hash', 'heredoc', and 'method_call'. Each construct
# will be counted as one line regardless of its actual size.
#
# NOTE: This cop also applies for `Struct` definitions.
#
# @example CountAsOne: ['array', 'heredoc', 'method_call']
#
#   class Foo
#   ARRAY = [         # +1
#   1,
#   2
#   ]
#
#   HASH = {          # +3
#   key: 'value'
#   }
#
#   MSG = <<~HEREDOC  # +1
#   Heredoc
#   content.
#   HEREDOC
#
#   foo(              # +1
#   1,
#   2
#   )
#   end                 # 6 points
#
# source://rubocop//lib/rubocop/cop/metrics/class_length.rb#39
class RuboCop::Cop::Metrics::ClassLength < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::CodeLength

  # source://rubocop//lib/rubocop/cop/metrics/class_length.rb#46
  def on_casgn(node); end

  # source://rubocop//lib/rubocop/cop/metrics/class_length.rb#42
  def on_class(node); end

  private

  # source://rubocop//lib/rubocop/cop/metrics/class_length.rb#64
  def message(length, max_length); end
end

# Checks for literals with extremely many entries. This is indicative of
# configuration or data that may be better extracted somewhere else, like
# a database, fetched from an API, or read from a non-code file (CSV,
# JSON, YAML, etc.).
#
# @example
#   # bad
#   # Huge Array literal
#   [1, 2, '...', 999_999_999]
#
#   # bad
#   # Huge Hash literal
#   { 1 => 1, 2 => 2, '...' => '...', 999_999_999 => 999_999_999}
#
#   # bad
#   # Huge Set "literal"
#   Set[1, 2, '...', 999_999_999]
#
#   # good
#   # Reasonably sized Array literal
#   [1, 2, '...', 10]
#
#   # good
#   # Reading huge Array from external data source
#   # File.readlines('numbers.txt', chomp: true).map!(&:to_i)
#
#   # good
#   # Reasonably sized Hash literal
#   { 1 => 1, 2 => 2, '...' => '...', 10 => 10}
#
#   # good
#   # Reading huge Hash from external data source
#   CSV.foreach('numbers.csv', headers: true).each_with_object({}) do |row, hash|
#   hash[row["key"].to_i] = row["value"].to_i
#   end
#
#   # good
#   # Reasonably sized Set "literal"
#   Set[1, 2, '...', 10]
#
#   # good
#   # Reading huge Set from external data source
#   SomeFramework.config_for(:something)[:numbers].to_set
#
# source://rubocop//lib/rubocop/cop/metrics/collection_literal_length.rb#50
class RuboCop::Cop::Metrics::CollectionLiteralLength < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/metrics/collection_literal_length.rb#55
  def on_array(node); end

  # source://rubocop//lib/rubocop/cop/metrics/collection_literal_length.rb#55
  def on_hash(node); end

  # source://rubocop//lib/rubocop/cop/metrics/collection_literal_length.rb#60
  def on_index(node); end

  # source://rubocop//lib/rubocop/cop/metrics/collection_literal_length.rb#64
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/metrics/collection_literal_length.rb#70
  def collection_threshold; end
end

# source://rubocop//lib/rubocop/cop/metrics/collection_literal_length.rb#51
RuboCop::Cop::Metrics::CollectionLiteralLength::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/metrics/collection_literal_length.rb#53
RuboCop::Cop::Metrics::CollectionLiteralLength::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks that the cyclomatic complexity of methods is not higher
# than the configured maximum. The cyclomatic complexity is the number of
# linearly independent paths through a method. The algorithm counts
# decision points and adds one.
#
# An if statement (or unless or ?:) increases the complexity by one. An
# else branch does not, since it doesn't add a decision point. The &&
# operator (or keyword and) can be converted to a nested if statement,
# and ||/or is shorthand for a sequence of ifs, so they also add one.
# Loops can be said to have an exit condition, so they add one.
# Blocks that are calls to builtin iteration methods
# (e.g. `ary.map{...}) also add one, others are ignored.
#
#   def each_child_node(*types)               # count begins: 1
#     unless block_given?                     # unless: +1
#       return to_enum(__method__, *types)
#
#     children.each do |child|                # each{}: +1
#       next unless child.is_a?(Node)         # unless: +1
#
#       yield child if types.empty? ||        # if: +1, ||: +1
#                      types.include?(child.type)
#     end
#
#     self
#   end                                       # total: 6
#
# source://rubocop//lib/rubocop/cop/metrics/cyclomatic_complexity.rb#32
class RuboCop::Cop::Metrics::CyclomaticComplexity < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::AllowedPattern
  include ::RuboCop::Cop::Metrics::Utils::RepeatedCsendDiscount
  include ::RuboCop::Cop::MethodComplexity
  include ::RuboCop::Cop::Metrics::Utils::IteratingBlock

  private

  # source://rubocop//lib/rubocop/cop/metrics/cyclomatic_complexity.rb#42
  def complexity_score_for(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/metrics/cyclomatic_complexity.rb#49
  def count_block?(block); end
end

# source://rubocop//lib/rubocop/cop/metrics/cyclomatic_complexity.rb#37
RuboCop::Cop::Metrics::CyclomaticComplexity::COUNTED_NODES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/metrics/cyclomatic_complexity.rb#36
RuboCop::Cop::Metrics::CyclomaticComplexity::MSG = T.let(T.unsafe(nil), String)

# Checks if the length of a method exceeds some maximum value.
# Comment lines can optionally be allowed.
# The maximum allowed length is configurable.
#
# You can set constructs you want to fold with `CountAsOne`.
# Available are: 'array', 'hash', 'heredoc', and 'method_call'. Each construct
# will be counted as one line regardless of its actual size.
#
# NOTE: The `ExcludedMethods` and `IgnoredMethods` configuration is
# deprecated and only kept for backwards compatibility.
# Please use `AllowedMethods` and `AllowedPatterns` instead.
# By default, there are no methods to allowed.
#
# @example CountAsOne: ['array', 'heredoc', 'method_call']
#
#   def m
#   array = [       # +1
#   1,
#   2
#   ]
#
#   hash = {        # +3
#   key: 'value'
#   }
#
#   <<~HEREDOC      # +1
#   Heredoc
#   content.
#   HEREDOC
#
#   foo(            # +1
#   1,
#   2
#   )
#   end               # 6 points
#
# source://rubocop//lib/rubocop/cop/metrics/method_length.rb#42
class RuboCop::Cop::Metrics::MethodLength < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::AllowedPattern

  # source://rubocop//lib/rubocop/cop/metrics/method_length.rb#56
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/metrics/method_length.rb#49
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/metrics/method_length.rb#49
  def on_defs(node); end

  # source://rubocop//lib/rubocop/cop/metrics/method_length.rb#56
  def on_numblock(node); end

  private

  # source://rubocop//lib/rubocop/cop/metrics/method_length.rb#65
  def cop_label; end
end

# source://rubocop//lib/rubocop/cop/metrics/method_length.rb#47
RuboCop::Cop::Metrics::MethodLength::LABEL = T.let(T.unsafe(nil), String)

# Checks if the length of a module exceeds some maximum value.
# Comment lines can optionally be ignored.
# The maximum allowed length is configurable.
#
# You can set constructs you want to fold with `CountAsOne`.
# Available are: 'array', 'hash', 'heredoc', and 'method_call'. Each construct
# will be counted as one line regardless of its actual size.
#
# @example CountAsOne: ['array', 'heredoc', 'method_call']
#
#   module M
#   ARRAY = [         # +1
#   1,
#   2
#   ]
#
#   HASH = {          # +3
#   key: 'value'
#   }
#
#   MSG = <<~HEREDOC  # +1
#   Heredoc
#   content.
#   HEREDOC
#
#   foo(              # +1
#   1,
#   2
#   )
#   end                 # 6 points
#
# source://rubocop//lib/rubocop/cop/metrics/module_length.rb#37
class RuboCop::Cop::Metrics::ModuleLength < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::CodeLength

  # source://rubocop//lib/rubocop/cop/metrics/module_length.rb#51
  def module_definition?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/metrics/module_length.rb#44
  def on_casgn(node); end

  # source://rubocop//lib/rubocop/cop/metrics/module_length.rb#40
  def on_module(node); end

  private

  # source://rubocop//lib/rubocop/cop/metrics/module_length.rb#55
  def message(length, max_length); end
end

# Checks for methods with too many parameters.
#
# The maximum number of parameters is configurable.
# Keyword arguments can optionally be excluded from the total count,
# as they add less complexity than positional or optional parameters.
#
# Any number of arguments for `initialize` method inside a block of
# `Struct.new` and `Data.define` like this is always allowed:
#
# [source,ruby]
# ----
# Struct.new(:one, :two, :three, :four, :five, keyword_init: true) do
#   def initialize(one:, two:, three:, four:, five:)
#   end
# end
# ----
#
# This is because checking the number of arguments of the `initialize` method
# does not make sense.
#
# NOTE: Explicit block argument `&block` is not counted to prevent
# erroneous change that is avoided by making block argument implicit.
#
# This cop also checks for the maximum number of optional parameters.
# This can be configured using the `MaxOptionalParameters` config option.
#
# @example Max: 3
#   # good
#   def foo(a, b, c = 1)
#   end
# @example Max: 2
#   # bad
#   def foo(a, b, c = 1)
#   end
# @example CountKeywordArgs: true (default)
#   # counts keyword args towards the maximum
#
#   # bad (assuming Max is 3)
#   def foo(a, b, c, d: 1)
#   end
#
#   # good (assuming Max is 3)
#   def foo(a, b, c: 1)
#   end
# @example CountKeywordArgs: false
#   # don't count keyword args towards the maximum
#
#   # good (assuming Max is 3)
#   def foo(a, b, c, d: 1)
#   end
# @example MaxOptionalParameters: 3 (default)
#   # good
#   def foo(a = 1, b = 2, c = 3)
#   end
# @example MaxOptionalParameters: 2
#   # bad
#   def foo(a = 1, b = 2, c = 3)
#   end
#
# source://rubocop//lib/rubocop/cop/metrics/parameter_lists.rb#70
class RuboCop::Cop::Metrics::ParameterLists < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/metrics/parameter_lists.rb#121
  def argument_to_lambda_or_proc?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/exclude_limit.rb#11
  def max=(value); end

  # source://rubocop//lib/rubocop/cop/exclude_limit.rb#11
  def max_optional_parameters=(value); end

  # source://rubocop//lib/rubocop/cop/metrics/parameter_lists.rb#104
  def on_args(node); end

  # source://rubocop//lib/rubocop/cop/metrics/parameter_lists.rb#90
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/metrics/parameter_lists.rb#90
  def on_defs(node); end

  # source://rubocop//lib/rubocop/cop/metrics/parameter_lists.rb#81
  def struct_new_or_data_define_block?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/metrics/parameter_lists.rb#125
  def args_count(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/metrics/parameter_lists.rb#141
  def count_keyword_args?; end

  # source://rubocop//lib/rubocop/cop/metrics/parameter_lists.rb#137
  def max_optional_parameters; end

  # source://rubocop//lib/rubocop/cop/metrics/parameter_lists.rb#133
  def max_params; end
end

# source://rubocop//lib/rubocop/cop/metrics/parameter_lists.rb#74
RuboCop::Cop::Metrics::ParameterLists::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/metrics/parameter_lists.rb#77
RuboCop::Cop::Metrics::ParameterLists::NAMED_KEYWORD_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/metrics/parameter_lists.rb#75
RuboCop::Cop::Metrics::ParameterLists::OPTIONAL_PARAMETERS_MSG = T.let(T.unsafe(nil), String)

# Tries to produce a complexity score that's a measure of the
# complexity the reader experiences when looking at a method. For that
# reason it considers `when` nodes as something that doesn't add as much
# complexity as an `if` or a `&&`. Except if it's one of those special
# `case`/`when` constructs where there's no expression after `case`. Then
# the cop treats it as an `if`/`elsif`/`elsif`... and lets all the `when`
# nodes count. In contrast to the CyclomaticComplexity cop, this cop
# considers `else` nodes as adding complexity.
#
# @example
#
#   def my_method                   # 1
#   if cond                       # 1
#   case var                    # 2 (0.8 + 4 * 0.2, rounded)
#   when 1 then func_one
#   when 2 then func_two
#   when 3 then func_three
#   when 4..10 then func_other
#   end
#   else                          # 1
#   do_something until a && b   # 2
#   end                           # ===
#   end                             # 7 complexity points
#
# source://rubocop//lib/rubocop/cop/metrics/perceived_complexity.rb#29
class RuboCop::Cop::Metrics::PerceivedComplexity < ::RuboCop::Cop::Metrics::CyclomaticComplexity
  private

  # source://rubocop//lib/rubocop/cop/metrics/perceived_complexity.rb#36
  def complexity_score_for(node); end
end

# source://rubocop//lib/rubocop/cop/metrics/perceived_complexity.rb#32
RuboCop::Cop::Metrics::PerceivedComplexity::COUNTED_NODES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/metrics/perceived_complexity.rb#30
RuboCop::Cop::Metrics::PerceivedComplexity::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/metrics/utils/repeated_csend_discount.rb#6
module RuboCop::Cop::Metrics::Utils; end

# > ABC is .. a software size metric .. computed by counting the number
# > of assignments, branches and conditions for a section of code.
# > http://c2.com/cgi/wiki?AbcMetric
#
# We separate the *calculator* from the *cop* so that the calculation,
# the formula itself, is easier to test.
#
# source://rubocop//lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#13
class RuboCop::Cop::Metrics::Utils::AbcSizeCalculator
  include ::RuboCop::AST::Sexp
  include ::RuboCop::Cop::Metrics::Utils::RepeatedAttributeDiscount
  include ::RuboCop::Cop::Metrics::Utils::IteratingBlock
  include ::RuboCop::Cop::Metrics::Utils::RepeatedCsendDiscount

  # @return [AbcSizeCalculator] a new instance of AbcSizeCalculator
  #
  # source://rubocop//lib/rubocop/cop/metrics/utils/repeated_attribute_discount.rb#30
  def initialize(node, discount_repeated_attributes: T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#42
  def calculate; end

  # source://rubocop//lib/rubocop/cop/metrics/utils/repeated_attribute_discount.rb#53
  def calculate_node(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#65
  def else_branch?(node); end

  # source://rubocop//lib/rubocop/cop/metrics/utils/repeated_attribute_discount.rb#47
  def evaluate_branch_nodes(node); end

  # source://rubocop//lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#60
  def evaluate_condition_node(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#128
  def argument?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#86
  def assignment?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#124
  def branch?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#119
  def capturing_variable?(name); end

  # source://rubocop//lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#95
  def compound_assignment(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#132
  def condition?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#108
  def simple_assignment?(node); end

  # @yield [node]
  #
  # source://rubocop//lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#71
  def visit_depth_last(node, &block); end

  class << self
    # source://rubocop//lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#30
    def calculate(node, discount_repeated_attributes: T.unsafe(nil)); end
  end
end

# > Branch -- an explicit forward program branch out of scope -- a
# > function call, class method call ..
# > http://c2.com/cgi/wiki?AbcMetric
#
# source://rubocop//lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#21
RuboCop::Cop::Metrics::Utils::AbcSizeCalculator::BRANCH_NODES = T.let(T.unsafe(nil), Array)

# > Condition -- a logical/Boolean test, == != <= >= < > else case
# > default try catch ? and unary conditionals.
# > http://c2.com/cgi/wiki?AbcMetric
#
# source://rubocop//lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#26
RuboCop::Cop::Metrics::Utils::AbcSizeCalculator::CONDITION_NODES = T.let(T.unsafe(nil), Array)

# Helps to calculate code length for the provided node.
#
# source://rubocop//lib/rubocop/cop/metrics/utils/code_length_calculator.rb#8
class RuboCop::Cop::Metrics::Utils::CodeLengthCalculator
  include ::RuboCop::PathUtil
  include ::RuboCop::Cop::Util
  extend ::RuboCop::AST::NodePattern::Macros

  # @return [CodeLengthCalculator] a new instance of CodeLengthCalculator
  #
  # source://rubocop//lib/rubocop/cop/metrics/utils/code_length_calculator.rb#16
  def initialize(node, processed_source, count_comments: T.unsafe(nil), foldable_types: T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/metrics/utils/code_length_calculator.rb#24
  def calculate; end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/metrics/utils/code_length_calculator.rb#175
  def another_args?(node); end

  # source://rubocop//lib/rubocop/cop/metrics/utils/code_length_calculator.rb#42
  def build_foldable_checks(types); end

  # source://rubocop//lib/rubocop/cop/metrics/utils/code_length_calculator.rb#83
  def classlike_code_length(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/metrics/utils/code_length_calculator.rb#131
  def classlike_node?(node); end

  # source://rubocop//lib/rubocop/cop/metrics/utils/code_length_calculator.rb#66
  def code_length(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/metrics/utils/code_length_calculator.rb#156
  def count_comments?; end

  # source://rubocop//lib/rubocop/cop/metrics/utils/code_length_calculator.rb#119
  def each_top_level_descendant(node, types, &block); end

  # source://rubocop//lib/rubocop/cop/metrics/utils/code_length_calculator.rb#139
  def extract_body(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/metrics/utils/code_length_calculator.rb#135
  def foldable_node?(node); end

  # source://rubocop//lib/rubocop/cop/metrics/utils/code_length_calculator.rb#114
  def heredoc_length(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/metrics/utils/code_length_calculator.rb#79
  def heredoc_node?(node); end

  # Returns true for lines that shall not be included in the count.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/metrics/utils/code_length_calculator.rb#152
  def irrelevant_line?(source_line); end

  # source://rubocop//lib/rubocop/cop/metrics/utils/code_length_calculator.rb#103
  def line_numbers_of_inner_nodes(node, *types); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/metrics/utils/code_length_calculator.rb#99
  def namespace_module?(node); end

  # source://rubocop//lib/rubocop/cop/metrics/utils/code_length_calculator.rb#60
  def normalize_foldable_types(types); end

  # source://rubocop//lib/rubocop/cop/metrics/utils/code_length_calculator.rb#160
  def omit_length(descendant); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/metrics/utils/code_length_calculator.rb#171
  def parenthesized?(node); end
end

# source://rubocop//lib/rubocop/cop/metrics/utils/code_length_calculator.rb#13
RuboCop::Cop::Metrics::Utils::CodeLengthCalculator::CLASSLIKE_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/metrics/utils/code_length_calculator.rb#12
RuboCop::Cop::Metrics::Utils::CodeLengthCalculator::FOLDABLE_TYPES = T.let(T.unsafe(nil), Array)

# Used to identify iterating blocks like `.map{}` and `.map(&:...)`
#
# source://rubocop//lib/rubocop/cop/metrics/utils/iterating_block.rb#8
module RuboCop::Cop::Metrics::Utils::IteratingBlock
  # Returns the name of the method called with a block
  # if node is a block node, or a block-pass node.
  #
  # source://rubocop//lib/rubocop/cop/metrics/utils/iterating_block.rb#37
  def block_method_name(node); end

  # Returns nil if node is neither a block node or a block-pass node.
  # Otherwise returns true/false if method call is a known iterating call
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/metrics/utils/iterating_block.rb#53
  def iterating_block?(node); end

  # Returns true iff name is a known iterating type (e.g. :each, :transform_values)
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/metrics/utils/iterating_block.rb#47
  def iterating_method?(name); end
end

# source://rubocop//lib/rubocop/cop/metrics/utils/iterating_block.rb#33
RuboCop::Cop::Metrics::Utils::IteratingBlock::KNOWN_ITERATING_METHODS = T.let(T.unsafe(nil), Set)

# Identifies repetitions `{c}send` calls with no arguments:
#
#   foo.bar
#   foo.bar # => repeated
#   foo.bar.baz.qux # => inner send repeated
#   foo.bar.baz.other # => both inner send repeated
#   foo.bar(2) # => not repeated
#
# It also invalidates sequences if a receiver is reassigned:
#
#   xx.foo.bar
#   xx.foo.baz      # => inner send repeated
#   self.xx = any   # => invalidates everything so far
#   xx.foo.baz      # => no repetition
#   self.xx.foo.baz # => all repeated
#
# @api private
#
# source://rubocop//lib/rubocop/cop/metrics/utils/repeated_attribute_discount.rb#25
module RuboCop::Cop::Metrics::Utils::RepeatedAttributeDiscount
  include ::RuboCop::AST::Sexp
  extend ::RuboCop::AST::NodePattern::Macros

  # Plug into the calculator
  #
  # @api private
  #
  # source://rubocop//lib/rubocop/cop/metrics/utils/repeated_attribute_discount.rb#30
  def initialize(node, discount_repeated_attributes: T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/metrics/utils/repeated_attribute_discount.rb#61
  def attribute_call?(param0 = T.unsafe(nil)); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/metrics/utils/repeated_attribute_discount.rb#53
  def calculate_node(node); end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/metrics/utils/repeated_attribute_discount.rb#43
  def discount_repeated_attributes?; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/metrics/utils/repeated_attribute_discount.rb#47
  def evaluate_branch_nodes(node); end

  # source://rubocop//lib/rubocop/cop/metrics/utils/repeated_attribute_discount.rb#92
  def root_node?(param0 = T.unsafe(nil)); end

  private

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/metrics/utils/repeated_attribute_discount.rb#66
  def discount_repeated_attribute?(send_node); end

  # Returns the "known_attributes" for the `node` by walking the receiver tree
  # If at any step the subdirectory does not exist, it is yielded with the
  # associated key (method_name)
  # If the node is not a series of `(c)send` calls with no arguments,
  # then `nil` is yielded
  #
  # @api private
  #
  # source://rubocop//lib/rubocop/cop/metrics/utils/repeated_attribute_discount.rb#103
  def find_attributes(node, &block); end

  # or `nil` if it is not a setter.
  #
  # @api private
  #
  # source://rubocop//lib/rubocop/cop/metrics/utils/repeated_attribute_discount.rb#126
  def setter_to_getter(node); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/metrics/utils/repeated_attribute_discount.rb#80
  def update_repeated_attribute(node); end
end

# @api private
#
# source://rubocop//lib/rubocop/cop/metrics/utils/repeated_attribute_discount.rb#117
RuboCop::Cop::Metrics::Utils::RepeatedAttributeDiscount::VAR_SETTER_TO_GETTER = T.let(T.unsafe(nil), Hash)

# Identifies repetitions `&.` on the same variable:
#
#  my_var&.foo
#  my_var&.bar # => repeated
#  my_var = baz # => reset
#  my_var&.qux # => not repeated
#
# @api private
#
# source://rubocop//lib/rubocop/cop/metrics/utils/repeated_csend_discount.rb#15
module RuboCop::Cop::Metrics::Utils::RepeatedCsendDiscount
  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/metrics/utils/repeated_csend_discount.rb#20
  def discount_for_repeated_csend?(csend_node); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/metrics/utils/repeated_csend_discount.rb#34
  def reset_on_lvasgn(node); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/metrics/utils/repeated_csend_discount.rb#16
  def reset_repeated_csend; end
end

# source://rubocop//lib/rubocop/cop/migration/department_name.rb#5
module RuboCop::Cop::Migration; end

# department name.
#
# source://rubocop//lib/rubocop/cop/migration/department_name.rb#8
class RuboCop::Cop::Migration::DepartmentName < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/migration/department_name.rb#21
  def on_new_investigation; end

  private

  # source://rubocop//lib/rubocop/cop/migration/department_name.rb#47
  def check_cop_name(name, comment, offset); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/migration/department_name.rb#69
  def contain_unexpected_character_for_department_name?(name); end

  # source://rubocop//lib/rubocop/cop/migration/department_name.rb#43
  def disable_comment_offset; end

  # source://rubocop//lib/rubocop/cop/migration/department_name.rb#73
  def qualified_legacy_cop_name(cop_name); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/migration/department_name.rb#63
  def valid_content_token?(content_token); end
end

# source://rubocop//lib/rubocop/cop/migration/department_name.rb#14
RuboCop::Cop::Migration::DepartmentName::DISABLE_COMMENT_FORMAT = T.let(T.unsafe(nil), Regexp)

# The token that makes up a disable comment.
# `DepartmentName/CopName` or` all`.
#
# source://rubocop//lib/rubocop/cop/migration/department_name.rb#19
RuboCop::Cop::Migration::DepartmentName::DISABLING_COPS_CONTENT_TOKEN = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/migration/department_name.rb#12
RuboCop::Cop::Migration::DepartmentName::MSG = T.let(T.unsafe(nil), String)

# Common functionality for checking minimum body length.
#
# source://rubocop//lib/rubocop/cop/mixin/min_body_length.rb#6
module RuboCop::Cop::MinBodyLength
  private

  # source://rubocop//lib/rubocop/cop/mixin/min_body_length.rb#13
  def min_body_length; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/min_body_length.rb#9
  def min_body_length?(node); end
end

# Common functionality for checking minimum branches count.
#
# source://rubocop//lib/rubocop/cop/mixin/min_branches_count.rb#6
module RuboCop::Cop::MinBranchesCount
  private

  # source://rubocop//lib/rubocop/cop/mixin/min_branches_count.rb#29
  def if_conditional_branches(node, branches = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/mixin/min_branches_count.rb#22
  def min_branches_count; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/min_branches_count.rb#9
  def min_branches_count?(node); end
end

# Common code for indenting the first elements in multiline
# array literals, hash literals, and method definitions.
#
# source://rubocop//lib/rubocop/cop/mixin/multiline_element_indentation.rb#7
module RuboCop::Cop::MultilineElementIndentation
  private

  # source://rubocop//lib/rubocop/cop/mixin/multiline_element_indentation.rb#42
  def check_expected_style(styles); end

  # source://rubocop//lib/rubocop/cop/mixin/multiline_element_indentation.rb#26
  def check_first(first, left_brace, left_parenthesis, offset); end

  # source://rubocop//lib/rubocop/cop/mixin/multiline_element_indentation.rb#80
  def detected_styles(actual_column, offset, left_parenthesis, left_brace); end

  # source://rubocop//lib/rubocop/cop/mixin/multiline_element_indentation.rb#85
  def detected_styles_for_column(column, left_parenthesis, left_brace); end

  # source://rubocop//lib/rubocop/cop/mixin/multiline_element_indentation.rb#10
  def each_argument_node(node, type); end

  # source://rubocop//lib/rubocop/cop/mixin/multiline_element_indentation.rb#66
  def hash_pair_where_value_beginning_with(left_brace, first); end

  # source://rubocop//lib/rubocop/cop/mixin/multiline_element_indentation.rb#98
  def incorrect_style_detected(styles, first, base_column_type); end

  # source://rubocop//lib/rubocop/cop/mixin/multiline_element_indentation.rb#50
  def indent_base(left_brace, first, left_parenthesis); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/multiline_element_indentation.rb#72
  def key_and_value_begin_on_same_line?(pair); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/multiline_element_indentation.rb#76
  def right_sibling_begins_on_subsequent_line?(pair); end
end

# Common functionality for checking for a line break before each
# element in a multi-line collection.
#
# source://rubocop//lib/rubocop/cop/mixin/multiline_element_line_breaks.rb#7
module RuboCop::Cop::MultilineElementLineBreaks
  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/multiline_element_line_breaks.rb#23
  def all_on_same_line?(nodes, ignore_last: T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/mixin/multiline_element_line_breaks.rb#10
  def check_line_breaks(_node, children, ignore_last: T.unsafe(nil)); end
end

# Common functionality for checking multiline method calls and binary
# operations.
#
# source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#7
module RuboCop::Cop::MultilineExpressionIndentation
  # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#14
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#131
  def argument_in_method_call(node, kind); end

  # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#187
  def assignment_rhs(node); end

  # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#64
  def check(range, node, lhs, rhs); end

  # The correct indentation of `node` is usually `IndentationWidth`, with
  # one exception: prefix keywords.
  #
  # ```
  # while foo &&  # Here, `while` is called a "prefix keyword"
  #     bar       # This is called "special indentation"
  #   baz
  # end
  # ```
  #
  # Note that *postfix conditionals* do *not* get "special indentation".
  #
  # ```
  # next if foo &&
  #   bar # normal indentation, not special
  # ```
  #
  # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#54
  def correct_indentation(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#159
  def disqualified_rhs?(candidate, ancestor); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#203
  def grouped_expression?(node); end

  # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#72
  def incorrect_style_detected(range, node, lhs, rhs); end

  # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#84
  def indentation(node); end

  # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#121
  def indented_keyword_expression(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#207
  def inside_arg_list_parentheses?(node, ancestor); end

  # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#98
  def keyword_message_tail(node); end

  # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#106
  def kw_node_with_special_indentation(node); end

  # In a chain of method calls, we regard the top send node as the base
  # for indentation of all lines following the first. For example:
  # a.
  #   b c { block }.            <-- b is indented relative to a
  #   d                         <-- d is indented relative to a
  #
  # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#31
  def left_hand_side(lhs); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#197
  def not_for_this_cop?(node); end

  # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#88
  def operation_description(node, rhs); end

  # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#145
  def part_of_assignment_rhs(node, candidate); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#183
  def part_of_block_body?(candidate, block_node); end

  # Returns true if `node` is a conditional whose `body` and `condition`
  # begin on the same line.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#216
  def postfix_conditional?(node); end

  # The []= operator and setters (a.b = c) are parsed as :send nodes.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#175
  def valid_method_rhs_candidate?(candidate, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#164
  def valid_rhs?(candidate, ancestor); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#179
  def valid_rhs_candidate?(candidate, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#220
  def within_node?(inner, outer); end
end

# source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#11
RuboCop::Cop::MultilineExpressionIndentation::ASSIGNMENT_MESSAGE_TAIL = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#10
RuboCop::Cop::MultilineExpressionIndentation::DEFAULT_MESSAGE_TAIL = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#8
RuboCop::Cop::MultilineExpressionIndentation::KEYWORD_ANCESTOR_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#12
RuboCop::Cop::MultilineExpressionIndentation::KEYWORD_MESSAGE_TAIL = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#9
RuboCop::Cop::MultilineExpressionIndentation::UNALIGNED_RHS_TYPES = T.let(T.unsafe(nil), Array)

# Autocorrection logic for the closing brace of a literal either
# on the same line as the last contained elements, or a new line.
#
# source://rubocop//lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#7
class RuboCop::Cop::MultilineLiteralBraceCorrector
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::RangeHelp

  # @return [MultilineLiteralBraceCorrector] a new instance of MultilineLiteralBraceCorrector
  #
  # source://rubocop//lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#15
  def initialize(corrector, node, processed_source); end

  # source://rubocop//lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#21
  def call; end

  private

  # source://rubocop//lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#61
  def content_if_comment_present(corrector, node); end

  # source://rubocop//lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#51
  def correct_heredoc_argument_method_chain(corrector, end_range); end

  # source://rubocop//lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#46
  def correct_next_line_brace(corrector, end_range); end

  # source://rubocop//lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#42
  def correct_same_line_brace(corrector); end

  # Returns the value of attribute corrector.
  #
  # source://rubocop//lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#40
  def corrector; end

  # source://rubocop//lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#94
  def last_element_range_with_trailing_comma(node); end

  # source://rubocop//lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#103
  def last_element_trailing_comma_range(node); end

  # Returns the value of attribute node.
  #
  # source://rubocop//lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#40
  def node; end

  # Returns the value of attribute processed_source.
  #
  # source://rubocop//lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#40
  def processed_source; end

  # source://rubocop//lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#90
  def remove_trailing_content_of_comment(corrector, range); end

  # source://rubocop//lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#80
  def select_content_to_be_inserted_after_last_element(corrector, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#73
  def use_heredoc_argument_method_chain?(parent); end

  class << self
    # source://rubocop//lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#11
    def correct(corrector, node, processed_source); end
  end
end

# Common functionality for checking the closing brace of a literal is
# either on the same line as the last contained elements or a new line.
#
# source://rubocop//lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#7
module RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  private

  # source://rubocop//lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#34
  def check(node); end

  # source://rubocop//lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#12
  def check_brace_layout(node); end

  # source://rubocop//lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#42
  def check_new_line(node); end

  # source://rubocop//lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#50
  def check_same_line(node); end

  # source://rubocop//lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#58
  def check_symmetrical(node); end

  # source://rubocop//lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#86
  def children(node); end

  # This method depends on the fact that we have guarded
  # against implicit and empty literals.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#98
  def closing_brace_on_same_line?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#74
  def empty_literal?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#82
  def ignored_literal?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#78
  def implicit_literal?(node); end

  # Starting with the parent node and recursively for the parent node's
  # children, check if the node is a HEREDOC and if the HEREDOC ends below
  # or on the last line of the parent node.
  #
  # Example:
  #
  #   # node is `b: ...` parameter
  #   # last_line_heredoc?(node) => false
  #   foo(a,
  #     b: {
  #       a: 1,
  #       c: <<-EOM
  #         baz
  #       EOM
  #     }
  #   )
  #
  #   # node is `b: ...` parameter
  #   # last_line_heredoc?(node) => true
  #   foo(a,
  #     b: <<-EOM
  #       baz
  #     EOM
  #   )
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#126
  def last_line_heredoc?(node, parent = T.unsafe(nil)); end

  # Returns true for the case
  #   [a,
  #    b # comment
  #   ].some_method
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#26
  def new_line_needed_before_closing_brace?(node); end

  # This method depends on the fact that we have guarded
  # against implicit and empty literals.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#92
  def opening_brace_on_same_line?(node); end
end

# source://rubocop//lib/rubocop/cop/naming/accessor_method_name.rb#5
module RuboCop::Cop::Naming; end

# Makes sure that accessor methods are named properly. Applies
# to both instance and class methods.
#
# NOTE: Offenses are only registered for methods with the expected
# arity. Getters (`get_attribute`) must have no arguments to be
# registered, and setters (`set_attribute(value)`) must have exactly
# one.
#
# @example
#   # bad
#   def set_attribute(value)
#   end
#
#   # good
#   def attribute=(value)
#   end
#
#   # bad
#   def get_attribute
#   end
#
#   # good
#   def attribute
#   end
#
#   # accepted, incorrect arity for getter
#   def get_value(attr)
#   end
#
#   # accepted, incorrect arity for setter
#   def set_value
#   end
#
# source://rubocop//lib/rubocop/cop/naming/accessor_method_name.rb#38
class RuboCop::Cop::Naming::AccessorMethodName < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/naming/accessor_method_name.rb#42
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/naming/accessor_method_name.rb#42
  def on_defs(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/naming/accessor_method_name.rb#61
  def bad_reader_name?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/naming/accessor_method_name.rb#65
  def bad_writer_name?(node); end

  # source://rubocop//lib/rubocop/cop/naming/accessor_method_name.rb#53
  def message(node); end
end

# source://rubocop//lib/rubocop/cop/naming/accessor_method_name.rb#39
RuboCop::Cop::Naming::AccessorMethodName::MSG_READER = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/naming/accessor_method_name.rb#40
RuboCop::Cop::Naming::AccessorMethodName::MSG_WRITER = T.let(T.unsafe(nil), String)

# Checks for non-ascii characters in identifier and constant names.
# Identifiers are always checked and whether constants are checked
# can be controlled using AsciiConstants config.
#
# @example
#   # bad
#   def  # Greek alphabet (non-ascii)
#   end
#
#   # bad
#   def  # Japanese character (non-ascii)
#   end
#
#   # bad
#   def hello_ # Emoji (non-ascii)
#   end
#
#   # good
#   def say_hello
#   end
#
#   # bad
#    = 10 # Hangul character (non-ascii)
#
#   # good
#   height = 10
#
#   # bad
#   params[:_gteq] # Arabic character (non-ascii)
#
#   # good
#   params[:width_gteq]
# @example AsciiConstants: true (default)
#   # bad
#   class Fo
#   end
#
#   FO = "foo"
# @example AsciiConstants: false
#   # good
#   class Fo
#   end
#
#   FO = "foo"
#
# source://rubocop//lib/rubocop/cop/naming/ascii_identifiers.rb#53
class RuboCop::Cop::Naming::AsciiIdentifiers < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/naming/ascii_identifiers.rb#59
  def on_new_investigation; end

  private

  # source://rubocop//lib/rubocop/cop/naming/ascii_identifiers.rb#84
  def first_non_ascii_chars(string); end

  # source://rubocop//lib/rubocop/cop/naming/ascii_identifiers.rb#74
  def first_offense_range(identifier); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/naming/ascii_identifiers.rb#70
  def should_check?(token); end
end

# source://rubocop//lib/rubocop/cop/naming/ascii_identifiers.rb#57
RuboCop::Cop::Naming::AsciiIdentifiers::CONSTANT_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/naming/ascii_identifiers.rb#56
RuboCop::Cop::Naming::AsciiIdentifiers::IDENTIFIER_MSG = T.let(T.unsafe(nil), String)

# Makes sure that certain binary operator methods have their
# sole  parameter named `other`.
#
# @example
#
#   # bad
#   def +(amount); end
#
#   # good
#   def +(other); end
#
# source://rubocop//lib/rubocop/cop/naming/binary_operator_parameter_name.rb#16
class RuboCop::Cop::Naming::BinaryOperatorParameterName < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/naming/binary_operator_parameter_name.rb#29
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/naming/binary_operator_parameter_name.rb#25
  def op_method_candidate?(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/naming/binary_operator_parameter_name.rb#45
  def op_method?(name); end
end

# source://rubocop//lib/rubocop/cop/naming/binary_operator_parameter_name.rb#22
RuboCop::Cop::Naming::BinaryOperatorParameterName::EXCLUDED = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/naming/binary_operator_parameter_name.rb#19
RuboCop::Cop::Naming::BinaryOperatorParameterName::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/naming/binary_operator_parameter_name.rb#21
RuboCop::Cop::Naming::BinaryOperatorParameterName::OP_LIKE_METHODS = T.let(T.unsafe(nil), Array)

# In Ruby 3.1, anonymous block forwarding has been added.
#
# This cop identifies places where `do_something(&block)` can be replaced
# by `do_something(&)`.
#
# It also supports the opposite style by alternative `explicit` option.
# You can specify the block variable name for autocorrection with `BlockForwardingName`.
# The default variable name is `block`. If the name is already in use, it will not be
# autocorrected.
#
# @example EnforcedStyle: anonymous (default)
#
#   # bad
#   def foo(&block)
#   bar(&block)
#   end
#
#   # good
#   def foo(&)
#   bar(&)
#   end
# @example EnforcedStyle: explicit
#
#   # bad
#   def foo(&)
#   bar(&)
#   end
#
#   # good
#   def foo(&block)
#   bar(&block)
#   end
#
# source://rubocop//lib/rubocop/cop/naming/block_forwarding.rb#40
class RuboCop::Cop::Naming::BlockForwarding < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop//lib/rubocop/cop/naming/block_forwarding.rb#54
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/naming/block_forwarding.rb#54
  def on_defs(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/naming/block_forwarding.rb#87
  def anonymous_block_argument?(node); end

  # source://rubocop//lib/rubocop/cop/naming/block_forwarding.rb#119
  def block_forwarding_name; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/naming/block_forwarding.rb#73
  def expected_block_forwarding_style?(node, last_argument); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/naming/block_forwarding.rb#91
  def explicit_block_argument?(node); end

  # source://rubocop//lib/rubocop/cop/naming/block_forwarding.rb#95
  def register_offense(block_argument, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/naming/block_forwarding.rb#111
  def use_block_argument_as_local_variable?(node, last_argument); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/naming/block_forwarding.rb#83
  def use_kwarg_in_method_definition?(node); end

  class << self
    # source://rubocop//lib/rubocop/cop/naming/block_forwarding.rb#50
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop//lib/rubocop/cop/naming/block_forwarding.rb#48
RuboCop::Cop::Naming::BlockForwarding::MSG = T.let(T.unsafe(nil), String)

# Checks block parameter names for how descriptive they
# are. It is highly configurable.
#
# The `MinNameLength` config option takes an integer. It represents
# the minimum amount of characters the name must be. Its default is 1.
# The `AllowNamesEndingInNumbers` config option takes a boolean. When
# set to false, this cop will register offenses for names ending with
# numbers. Its default is false. The `AllowedNames` config option
# takes an array of permitted names that will never register an
# offense. The `ForbiddenNames` config option takes an array of
# restricted names that will always register an offense.
#
# @example
#   # bad
#   bar do |varOne, varTwo|
#   varOne + varTwo
#   end
#
#   # With `AllowNamesEndingInNumbers` set to false
#   foo { |num1, num2| num1 * num2 }
#
#   # With `MinNameLength` set to number greater than 1
#   baz { |a, b, c| do_stuff(a, b, c) }
#
#   # good
#   bar do |thud, fred|
#   thud + fred
#   end
#
#   foo { |speed, distance| speed * distance }
#
#   baz { |age, height, gender| do_stuff(age, height, gender) }
#
# source://rubocop//lib/rubocop/cop/naming/block_parameter_name.rb#38
class RuboCop::Cop::Naming::BlockParameterName < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::UncommunicativeName

  # source://rubocop//lib/rubocop/cop/naming/block_parameter_name.rb#41
  def on_block(node); end
end

# Checks for class and module names with
# an underscore in them.
#
# `AllowedNames` config takes an array of permitted names.
# Its default value is `['module_parent']`.
# These names can be full class/module names or part of the name.
# eg. Adding `my_class` to the `AllowedNames` config will allow names like
# `my_class`, `my_class::User`, `App::my_class`, `App::my_class::User`, etc.
#
# @example
#   # bad
#   class My_Class
#   end
#   module My_Module
#   end
#
#   # good
#   class MyClass
#   end
#   module MyModule
#   end
#   class module_parent::MyModule
#   end
#
# source://rubocop//lib/rubocop/cop/naming/class_and_module_camel_case.rb#29
class RuboCop::Cop::Naming::ClassAndModuleCamelCase < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/naming/class_and_module_camel_case.rb#32
  def on_class(node); end

  # source://rubocop//lib/rubocop/cop/naming/class_and_module_camel_case.rb#32
  def on_module(node); end
end

# source://rubocop//lib/rubocop/cop/naming/class_and_module_camel_case.rb#30
RuboCop::Cop::Naming::ClassAndModuleCamelCase::MSG = T.let(T.unsafe(nil), String)

# Checks whether constant names are written using
# SCREAMING_SNAKE_CASE.
#
# To avoid false positives, it ignores cases in which we cannot know
# for certain the type of value that would be assigned to a constant.
#
# @example
#   # bad
#   InchInCm = 2.54
#   INCHinCM = 2.54
#   Inch_In_Cm = 2.54
#
#   # good
#   INCH_IN_CM = 2.54
#
# source://rubocop//lib/rubocop/cop/naming/constant_name.rb#20
class RuboCop::Cop::Naming::ConstantName < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/naming/constant_name.rb#27
  def class_or_struct_return_method?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/naming/constant_name.rb#69
  def literal_receiver?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/naming/constant_name.rb#33
  def on_casgn(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/naming/constant_name.rb#56
  def allowed_assignment?(value); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/naming/constant_name.rb#74
  def allowed_conditional_expression_on_rhs?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/naming/constant_name.rb#63
  def allowed_method_call_on_rhs?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/naming/constant_name.rb#78
  def contains_constant?(node); end
end

# source://rubocop//lib/rubocop/cop/naming/constant_name.rb#21
RuboCop::Cop::Naming::ConstantName::MSG = T.let(T.unsafe(nil), String)

# Use POSIX character classes, so we allow accented characters rather
# than just standard ASCII characters
#
# source://rubocop//lib/rubocop/cop/naming/constant_name.rb#24
RuboCop::Cop::Naming::ConstantName::SNAKE_CASE = T.let(T.unsafe(nil), Regexp)

# Makes sure that Ruby source files have snake_case
# names. Ruby scripts (i.e. source files with a shebang in the
# first line) are ignored.
#
# The cop also ignores `.gemspec` files, because Bundler
# recommends using dashes to separate namespaces in nested gems
# (i.e. `bundler-console` becomes `Bundler::Console`). As such, the
# gemspec is supposed to be named `bundler-console.gemspec`.
#
# When `ExpectMatchingDefinition` (default: `false`) is `true`, the cop requires
# each file to have a class, module or `Struct` defined in it that matches
# the filename. This can be further configured using
# `CheckDefinitionPathHierarchy` (default: `true`) to determine whether the
# path should match the namespace of the above definition.
#
# When `IgnoreExecutableScripts` (default: `true`) is `true`, files that start
# with a shebang line are not considered by the cop.
#
# When `Regex` is set, the cop will flag any filename that does not match
# the regular expression.
#
# @example
#   # bad
#   lib/layoutManager.rb
#
#   anything/usingCamelCase
#
#   # good
#   lib/layout_manager.rb
#
#   anything/using_snake_case.rake
#
# source://rubocop//lib/rubocop/cop/naming/file_name.rb#39
class RuboCop::Cop::Naming::FileName < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/naming/file_name.rb#56
  def on_new_investigation; end

  # source://rubocop//lib/rubocop/cop/naming/file_name.rb#49
  def struct_definition(param0 = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/naming/file_name.rb#134
  def allowed_acronyms; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/naming/file_name.rb#96
  def bad_filename_allowed?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/naming/file_name.rb#122
  def check_definition_path_hierarchy?; end

  # source://rubocop//lib/rubocop/cop/naming/file_name.rb#169
  def defined_struct(node); end

  # source://rubocop//lib/rubocop/cop/naming/file_name.rb#126
  def definition_path_hierarchy_roots; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/naming/file_name.rb#118
  def expect_matching_definition?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/naming/file_name.rb#138
  def filename_good?(basename); end

  # source://rubocop//lib/rubocop/cop/naming/file_name.rb#147
  def find_class_or_module(node, namespace); end

  # source://rubocop//lib/rubocop/cop/naming/file_name.rb#165
  def find_definition(node); end

  # @yield [source_range(processed_source.buffer, 1, 0), msg]
  #
  # source://rubocop//lib/rubocop/cop/naming/file_name.rb#65
  def for_bad_filename(file_path); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/naming/file_name.rb#114
  def ignore_executable_scripts?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/naming/file_name.rb#202
  def match?(expected); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/naming/file_name.rb#206
  def match_acronym?(expected, name); end

  # source://rubocop//lib/rubocop/cop/naming/file_name.rb#174
  def match_namespace(node, namespace, expected); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/naming/file_name.rb#92
  def matching_class?(file_name); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/naming/file_name.rb#88
  def matching_definition?(file_path); end

  # source://rubocop//lib/rubocop/cop/naming/file_name.rb#100
  def no_definition_message(basename, file_path); end

  # source://rubocop//lib/rubocop/cop/naming/file_name.rb#106
  def other_message(basename); end

  # source://rubocop//lib/rubocop/cop/naming/file_name.rb#188
  def partial_matcher!(expected); end

  # source://rubocop//lib/rubocop/cop/naming/file_name.rb#77
  def perform_class_and_module_naming_checks(file_path, basename); end

  # source://rubocop//lib/rubocop/cop/naming/file_name.rb#130
  def regex; end

  # source://rubocop//lib/rubocop/cop/naming/file_name.rb#240
  def to_module_name(basename); end

  # source://rubocop//lib/rubocop/cop/naming/file_name.rb#213
  def to_namespace(path); end
end

# source://rubocop//lib/rubocop/cop/naming/file_name.rb#43
RuboCop::Cop::Naming::FileName::MSG_NO_DEFINITION = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/naming/file_name.rb#44
RuboCop::Cop::Naming::FileName::MSG_REGEX = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/naming/file_name.rb#42
RuboCop::Cop::Naming::FileName::MSG_SNAKE_CASE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/naming/file_name.rb#46
RuboCop::Cop::Naming::FileName::SNAKE_CASE = T.let(T.unsafe(nil), Regexp)

# Checks that your heredocs are using the configured case.
# By default it is configured to enforce uppercase heredocs.
#
# @example EnforcedStyle: uppercase (default)
#   # bad
#   <<-sql
#   SELECT * FROM foo
#   sql
#
#   # good
#   <<-SQL
#   SELECT * FROM foo
#   SQL
# @example EnforcedStyle: lowercase
#   # bad
#   <<-SQL
#   SELECT * FROM foo
#   SQL
#
#   # good
#   <<-sql
#   SELECT * FROM foo
#   sql
#
# source://rubocop//lib/rubocop/cop/naming/heredoc_delimiter_case.rb#30
class RuboCop::Cop::Naming::HeredocDelimiterCase < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Heredoc
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/naming/heredoc_delimiter_case.rb#37
  def on_heredoc(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/naming/heredoc_delimiter_case.rb#54
  def correct_case_delimiters?(node); end

  # source://rubocop//lib/rubocop/cop/naming/heredoc_delimiter_case.rb#58
  def correct_delimiters(source); end

  # source://rubocop//lib/rubocop/cop/naming/heredoc_delimiter_case.rb#50
  def message(_node); end
end

# source://rubocop//lib/rubocop/cop/naming/heredoc_delimiter_case.rb#35
RuboCop::Cop::Naming::HeredocDelimiterCase::MSG = T.let(T.unsafe(nil), String)

# Checks that your heredocs are using meaningful delimiters.
# By default it disallows `END` and `EO*`, and can be configured through
# forbidden listing additional delimiters.
#
# @example
#
#   # good
#   <<-SQL
#   SELECT * FROM foo
#   SQL
#
#   # bad
#   <<-END
#   SELECT * FROM foo
#   END
#
#   # bad
#   <<-EOS
#   SELECT * FROM foo
#   EOS
#
# source://rubocop//lib/rubocop/cop/naming/heredoc_delimiter_naming.rb#26
class RuboCop::Cop::Naming::HeredocDelimiterNaming < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Heredoc

  # source://rubocop//lib/rubocop/cop/naming/heredoc_delimiter_naming.rb#31
  def on_heredoc(node); end

  private

  # source://rubocop//lib/rubocop/cop/naming/heredoc_delimiter_naming.rb#49
  def forbidden_delimiters; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/naming/heredoc_delimiter_naming.rb#39
  def meaningful_delimiters?(node); end
end

# source://rubocop//lib/rubocop/cop/naming/heredoc_delimiter_naming.rb#29
RuboCop::Cop::Naming::HeredocDelimiterNaming::MSG = T.let(T.unsafe(nil), String)

# Recommends the use of inclusive language instead of problematic terms.
# The cop can check the following locations for offenses:
#
# - identifiers
# - constants
# - variables
# - strings
# - symbols
# - comments
# - file paths
#
# Each of these locations can be individually enabled/disabled via configuration,
# for example CheckIdentifiers = true/false.
#
# Flagged terms are configurable for the cop. For each flagged term an optional
# Regex can be specified to identify offenses. Suggestions for replacing a flagged term can
# be configured and will be displayed as part of the offense message.
# An AllowedRegex can be specified for a flagged term to exempt allowed uses of the term.
# `WholeWord: true` can be set on a flagged term to indicate the cop should only match when
# a term matches the whole word (partial matches will not be offenses).
#
# The cop supports autocorrection when there is only one suggestion. When there are multiple
# suggestions, the best suggestion cannot be identified and will not be autocorrected.
#
# @example FlaggedTerms: { whitelist: { Suggestions: ['allowlist'] } }
#   # Suggest replacing identifier whitelist with allowlist
#
#   # bad
#   whitelist_users = %w(user1 user1)
#
#   # good
#   allowlist_users = %w(user1 user2)
# @example FlaggedTerms: { master: { Suggestions: ['main', 'primary', 'leader'] } }
#   # Suggest replacing master in an instance variable name with main, primary, or leader
#
#   # bad
#   @master_node = 'node1.example.com'
#
#   # good
#   @primary_node = 'node1.example.com'
# @example FlaggedTerms: { whitelist: { Regex: !ruby/regexp '/white[-_\s]?list' } }
#   # Identify problematic terms using a Regexp
#
#   # bad
#   white_list = %w(user1 user2)
#
#   # good
#   allow_list = %w(user1 user2)
# @example FlaggedTerms: { master: { AllowedRegex: 'master\'?s degree' } }
#   # Specify allowed uses of the flagged term as a string or regexp.
#
#   # bad
#   # They had a masters
#
#   # good
#   # They had a master's degree
# @example FlaggedTerms: { slave: { WholeWord: true } }
#   # Specify that only terms that are full matches will be flagged.
#
#   # bad
#   Slave
#
#   # good (won't be flagged despite containing `slave`)
#   TeslaVehicle
#
# source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#74
class RuboCop::Cop::Naming::InclusiveLanguage < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # @return [InclusiveLanguage] a new instance of InclusiveLanguage
  #
  # source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#84
  def initialize(config = T.unsafe(nil), options = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#93
  def on_new_investigation; end

  private

  # source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#111
  def add_offenses_for_token(token, word_locations); end

  # source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#167
  def add_to_flagged_term_hash(regex_string, term, term_definition); end

  # source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#193
  def array_to_ignorecase_regex(strings); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#126
  def check_token?(type); end

  # source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#244
  def create_message(word, message = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#218
  def create_multiple_word_message_for_file(words); end

  # source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#214
  def create_single_word_message_for_file(word); end

  # source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#189
  def ensure_regex_string(regex); end

  # source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#160
  def extract_regexp(term, term_definition); end

  # source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#252
  def find_flagged_term(word); end

  # source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#266
  def format_suggestions(suggestions); end

  # source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#197
  def investigate_filepath; end

  # source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#100
  def investigate_tokens; end

  # source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#232
  def mask_input(str); end

  # source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#281
  def offense_range(token, word); end

  # source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#130
  def preprocess_check_config; end

  # source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#144
  def preprocess_flagged_terms; end

  # source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#259
  def preprocess_suggestions(suggestions); end

  # source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#179
  def process_allowed_regex(allowed); end

  # source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#222
  def scan_for_words(input); end

  # source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#174
  def set_regexes(flagged_term_strings, allowed_strings); end
end

# source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#78
RuboCop::Cop::Naming::InclusiveLanguage::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#79
RuboCop::Cop::Naming::InclusiveLanguage::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#80
RuboCop::Cop::Naming::InclusiveLanguage::MSG_FOR_FILE_PATH = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#82
class RuboCop::Cop::Naming::InclusiveLanguage::WordLocation < ::Struct
  # Returns the value of attribute position
  #
  # @return [Object] the current value of position
  def position; end

  # Sets the attribute position
  #
  # @param value [Object] the value to set the attribute position to.
  # @return [Object] the newly set value
  def position=(_); end

  # Returns the value of attribute word
  #
  # @return [Object] the current value of word
  def word; end

  # Sets the attribute word
  #
  # @param value [Object] the value to set the attribute word to.
  # @return [Object] the newly set value
  def word=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# Checks for memoized methods whose instance variable name
# does not match the method name. Applies to both regular methods
# (defined with `def`) and dynamic methods (defined with
# `define_method` or `define_singleton_method`).
#
# This cop can be configured with the EnforcedStyleForLeadingUnderscores
# directive. It can be configured to allow for memoized instance variables
# prefixed with an underscore. Prefixing ivars with an underscore is a
# convention that is used to implicitly indicate that an ivar should not
# be set or referenced outside of the memoization method.
#
# @example EnforcedStyleForLeadingUnderscores: disallowed (default)
#   # bad
#   # Method foo is memoized using an instance variable that is
#   # not `@foo`. This can cause confusion and bugs.
#   def foo
#   @something ||= calculate_expensive_thing
#   end
#
#   def foo
#   return @something if defined?(@something)
#   @something = calculate_expensive_thing
#   end
#
#   # good
#   def _foo
#   @foo ||= calculate_expensive_thing
#   end
#
#   # good
#   def foo
#   @foo ||= calculate_expensive_thing
#   end
#
#   # good
#   def foo
#   @foo ||= begin
#   calculate_expensive_thing
#   end
#   end
#
#   # good
#   def foo
#   helper_variable = something_we_need_to_calculate_foo
#   @foo ||= calculate_expensive_thing(helper_variable)
#   end
#
#   # good
#   define_method(:foo) do
#   @foo ||= calculate_expensive_thing
#   end
#
#   # good
#   define_method(:foo) do
#   return @foo if defined?(@foo)
#   @foo = calculate_expensive_thing
#   end
# @example EnforcedStyleForLeadingUnderscores: required
#   # bad
#   def foo
#   @something ||= calculate_expensive_thing
#   end
#
#   # bad
#   def foo
#   @foo ||= calculate_expensive_thing
#   end
#
#   def foo
#   return @foo if defined?(@foo)
#   @foo = calculate_expensive_thing
#   end
#
#   # good
#   def foo
#   @_foo ||= calculate_expensive_thing
#   end
#
#   # good
#   def _foo
#   @_foo ||= calculate_expensive_thing
#   end
#
#   def foo
#   return @_foo if defined?(@_foo)
#   @_foo = calculate_expensive_thing
#   end
#
#   # good
#   define_method(:foo) do
#   @_foo ||= calculate_expensive_thing
#   end
#
#   # good
#   define_method(:foo) do
#   return @_foo if defined?(@_foo)
#   @_foo = calculate_expensive_thing
#   end
# @example EnforcedStyleForLeadingUnderscores :optional
#   # bad
#   def foo
#   @something ||= calculate_expensive_thing
#   end
#
#   # good
#   def foo
#   @foo ||= calculate_expensive_thing
#   end
#
#   # good
#   def foo
#   @_foo ||= calculate_expensive_thing
#   end
#
#   # good
#   def _foo
#   @_foo ||= calculate_expensive_thing
#   end
#
#   # good
#   def foo
#   return @_foo if defined?(@_foo)
#   @_foo = calculate_expensive_thing
#   end
#
#   # good
#   define_method(:foo) do
#   @foo ||= calculate_expensive_thing
#   end
#
#   # good
#   define_method(:foo) do
#   @_foo ||= calculate_expensive_thing
#   end
#
# source://rubocop//lib/rubocop/cop/naming/memoized_instance_variable_name.rb#147
class RuboCop::Cop::Naming::MemoizedInstanceVariableName < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop//lib/rubocop/cop/naming/memoized_instance_variable_name.rb#189
  def defined_memoized?(param0 = T.unsafe(nil), param1); end

  # source://rubocop//lib/rubocop/cop/naming/memoized_instance_variable_name.rb#157
  def method_definition?(param0 = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/naming/memoized_instance_variable_name.rb#197
  def on_defined?(node); end

  # source://rubocop//lib/rubocop/cop/naming/memoized_instance_variable_name.rb#166
  def on_or_asgn(node); end

  private

  # source://rubocop//lib/rubocop/cop/naming/memoized_instance_variable_name.rb#227
  def find_definition(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/naming/memoized_instance_variable_name.rb#238
  def matches?(method_name, ivar_assign); end

  # source://rubocop//lib/rubocop/cop/naming/memoized_instance_variable_name.rb#248
  def message(variable); end

  # source://rubocop//lib/rubocop/cop/naming/memoized_instance_variable_name.rb#223
  def style_parameter_name; end

  # source://rubocop//lib/rubocop/cop/naming/memoized_instance_variable_name.rb#256
  def suggested_var(method_name); end

  # source://rubocop//lib/rubocop/cop/naming/memoized_instance_variable_name.rb#262
  def variable_name_candidates(method_name); end
end

# source://rubocop//lib/rubocop/cop/naming/memoized_instance_variable_name.rb#154
RuboCop::Cop::Naming::MemoizedInstanceVariableName::DYNAMIC_DEFINE_METHODS = T.let(T.unsafe(nil), Set)

# source://rubocop//lib/rubocop/cop/naming/memoized_instance_variable_name.rb#150
RuboCop::Cop::Naming::MemoizedInstanceVariableName::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/naming/memoized_instance_variable_name.rb#152
RuboCop::Cop::Naming::MemoizedInstanceVariableName::UNDERSCORE_REQUIRED = T.let(T.unsafe(nil), String)

# Makes sure that all methods use the configured style,
# snake_case or camelCase, for their names.
#
# This cop has `AllowedPatterns` configuration option.
#
#   Naming/MethodName:
#     AllowedPatterns:
#       - '\AonSelectionBulkChange\z'
#       - '\AonSelectionCleared\z'
#
# Method names matching patterns are always allowed.
#
# @example EnforcedStyle: snake_case (default)
#   # bad
#   def fooBar; end
#
#   # good
#   def foo_bar; end
# @example EnforcedStyle: camelCase
#   # bad
#   def foo_bar; end
#
#   # good
#   def fooBar; end
#
# source://rubocop//lib/rubocop/cop/naming/method_name.rb#31
class RuboCop::Cop::Naming::MethodName < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableNaming
  include ::RuboCop::Cop::AllowedPattern
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/naming/method_name.rb#55
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/naming/method_name.rb#55
  def on_defs(node); end

  # source://rubocop//lib/rubocop/cop/naming/method_name.rb#44
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/naming/method_name.rb#42
  def str_name(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/naming/method_name.rb#39
  def sym_name(param0 = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/naming/method_name.rb#64
  def attr_name(name_item); end

  # source://rubocop//lib/rubocop/cop/naming/method_name.rb#75
  def message(style); end

  # source://rubocop//lib/rubocop/cop/naming/method_name.rb#68
  def range_position(node); end
end

# source://rubocop//lib/rubocop/cop/naming/method_name.rb#36
RuboCop::Cop::Naming::MethodName::MSG = T.let(T.unsafe(nil), String)

# Checks method parameter names for how descriptive they
# are. It is highly configurable.
#
# The `MinNameLength` config option takes an integer. It represents
# the minimum amount of characters the name must be. Its default is 3.
# The `AllowNamesEndingInNumbers` config option takes a boolean. When
# set to false, this cop will register offenses for names ending with
# numbers. Its default is false. The `AllowedNames` config option
# takes an array of permitted names that will never register an
# offense. The `ForbiddenNames` config option takes an array of
# restricted names that will always register an offense.
#
# @example
#   # bad
#   def bar(varOne, varTwo)
#   varOne + varTwo
#   end
#
#   # With `AllowNamesEndingInNumbers` set to false
#   def foo(num1, num2)
#   num1 * num2
#   end
#
#   # With `MinNameLength` set to number greater than 1
#   def baz(a, b, c)
#   do_stuff(a, b, c)
#   end
#
#   # good
#   def bar(thud, fred)
#   thud + fred
#   end
#
#   def foo(speed, distance)
#   speed * distance
#   end
#
#   def baz(age_a, height_b, gender_c)
#   do_stuff(age_a, height_b, gender_c)
#   end
#
# source://rubocop//lib/rubocop/cop/naming/method_parameter_name.rb#46
class RuboCop::Cop::Naming::MethodParameterName < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::UncommunicativeName

  # source://rubocop//lib/rubocop/cop/naming/method_parameter_name.rb#49
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/naming/method_parameter_name.rb#49
  def on_defs(node); end
end

# Checks that predicate methods names end with a question mark and
# do not start with a forbidden prefix.
#
# A method is determined to be a predicate method if its name starts
# with one of the prefixes defined in the `NamePrefix` configuration.
# You can change what prefixes are considered by changing this option.
# Any method name that starts with one of these prefixes is required by
# the cop to end with a `?`. Other methods can be allowed by adding to
# the `AllowedMethods` configuration.
#
# NOTE: The `is_a?` method is allowed by default.
#
# If `ForbiddenPrefixes` is set, methods that start with the configured
# prefixes will not be allowed and will be removed by autocorrection.
#
# In other words, if `ForbiddenPrefixes` is empty, a method named `is_foo`
# will register an offense only due to the lack of question mark (and will be
# autocorrected to `is_foo?`). If `ForbiddenPrefixes` contains `is_`,
# `is_foo` will register an offense both because the ? is missing and because of
# the `is_` prefix, and will be corrected to `foo?`.
#
# NOTE: `ForbiddenPrefixes` is only applied to prefixes in `NamePrefix`;
# a prefix in the former but not the latter will not be considered by
# this cop.
#
# @example
#   # bad
#   def is_even(value)
#   end
#
#   def is_even?(value)
#   end
#
#   # good
#   def even?(value)
#   end
#
#   # bad
#   def has_value
#   end
#
#   def has_value?
#   end
#
#   # good
#   def value?
#   end
# @example AllowedMethods: ['is_a?'] (default)
#   # good
#   def is_a?(value)
#   end
#
# source://rubocop//lib/rubocop/cop/naming/predicate_name.rb#59
class RuboCop::Cop::Naming::PredicateName < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::AllowedMethods

  # source://rubocop//lib/rubocop/cop/naming/predicate_name.rb#63
  def dynamic_method_define(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/naming/predicate_name.rb#82
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/naming/predicate_name.rb#82
  def on_defs(node); end

  # source://rubocop//lib/rubocop/cop/naming/predicate_name.rb#69
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/naming/predicate_name.rb#98
  def allowed_method_name?(method_name, prefix); end

  # source://rubocop//lib/rubocop/cop/naming/predicate_name.rb#106
  def expected_name(method_name, prefix); end

  # source://rubocop//lib/rubocop/cop/naming/predicate_name.rb#120
  def forbidden_prefixes; end

  # source://rubocop//lib/rubocop/cop/naming/predicate_name.rb#116
  def message(method_name, new_name); end

  # source://rubocop//lib/rubocop/cop/naming/predicate_name.rb#128
  def method_definition_macros(macro_name); end

  # source://rubocop//lib/rubocop/cop/naming/predicate_name.rb#124
  def predicate_prefixes; end
end

# Makes sure that rescued exceptions variables are named as
# expected.
#
# The `PreferredName` config option takes a `String`. It represents
# the required name of the variable. Its default is `e`.
#
# NOTE: This cop does not consider nested rescues because it cannot
# guarantee that the variable from the outer rescue is not used within
# the inner rescue (in which case, changing the inner variable would
# shadow the outer variable).
#
# @example PreferredName: e (default)
#   # bad
#   begin
#   # do something
#   rescue MyException => exception
#   # do something
#   end
#
#   # good
#   begin
#   # do something
#   rescue MyException => e
#   # do something
#   end
#
#   # good
#   begin
#   # do something
#   rescue MyException => _e
#   # do something
#   end
# @example PreferredName: exception
#   # bad
#   begin
#   # do something
#   rescue MyException => e
#   # do something
#   end
#
#   # good
#   begin
#   # do something
#   rescue MyException => exception
#   # do something
#   end
#
#   # good
#   begin
#   # do something
#   rescue MyException => _exception
#   # do something
#   end
#
# source://rubocop//lib/rubocop/cop/naming/rescued_exceptions_variable_name.rb#61
class RuboCop::Cop::Naming::RescuedExceptionsVariableName < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/naming/rescued_exceptions_variable_name.rb#66
  def on_resbody(node); end

  private

  # source://rubocop//lib/rubocop/cop/naming/rescued_exceptions_variable_name.rb#108
  def correct_node(corrector, node, offending_name, preferred_name); end

  # If the exception variable is reassigned, that assignment needs to be corrected.
  # Further `lvar` nodes will not be corrected though since they now refer to a
  # different variable.
  #
  # source://rubocop//lib/rubocop/cop/naming/rescued_exceptions_variable_name.rb#126
  def correct_reassignment(corrector, node, offending_name, preferred_name); end

  # source://rubocop//lib/rubocop/cop/naming/rescued_exceptions_variable_name.rb#151
  def message(node); end

  # source://rubocop//lib/rubocop/cop/naming/rescued_exceptions_variable_name.rb#93
  def offense_range(resbody); end

  # source://rubocop//lib/rubocop/cop/naming/rescued_exceptions_variable_name.rb#135
  def preferred_name(variable_name); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/naming/rescued_exceptions_variable_name.rb#157
  def shadowed_variable_name?(node); end

  # source://rubocop//lib/rubocop/cop/naming/rescued_exceptions_variable_name.rb#144
  def variable_name(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/naming/rescued_exceptions_variable_name.rb#98
  def variable_name_matches?(node, name); end
end

# source://rubocop//lib/rubocop/cop/naming/rescued_exceptions_variable_name.rb#64
RuboCop::Cop::Naming::RescuedExceptionsVariableName::MSG = T.let(T.unsafe(nil), String)

# Makes sure that all variables use the configured style,
# snake_case or camelCase, for their names.
#
# @example EnforcedStyle: snake_case (default)
#   # bad
#   fooBar = 1
#
#   # good
#   foo_bar = 1
# @example EnforcedStyle: camelCase
#   # bad
#   foo_bar = 1
#
#   # good
#   fooBar = 1
# @example AllowedPatterns: ['_v\d+\z']
#   # good
#   :release_v1
#
# source://rubocop//lib/rubocop/cop/naming/variable_name.rb#26
class RuboCop::Cop::Naming::VariableName < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::AllowedIdentifiers
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableNaming
  include ::RuboCop::Cop::AllowedPattern

  # source://rubocop//lib/rubocop/cop/naming/variable_name.rb#37
  def on_arg(node); end

  # source://rubocop//lib/rubocop/cop/naming/variable_name.rb#37
  def on_blockarg(node); end

  # source://rubocop//lib/rubocop/cop/naming/variable_name.rb#37
  def on_cvasgn(node); end

  # source://rubocop//lib/rubocop/cop/naming/variable_name.rb#37
  def on_ivasgn(node); end

  # source://rubocop//lib/rubocop/cop/naming/variable_name.rb#37
  def on_kwarg(node); end

  # source://rubocop//lib/rubocop/cop/naming/variable_name.rb#37
  def on_kwoptarg(node); end

  # source://rubocop//lib/rubocop/cop/naming/variable_name.rb#37
  def on_kwrestarg(node); end

  # source://rubocop//lib/rubocop/cop/naming/variable_name.rb#37
  def on_lvar(node); end

  # source://rubocop//lib/rubocop/cop/naming/variable_name.rb#37
  def on_lvasgn(node); end

  # source://rubocop//lib/rubocop/cop/naming/variable_name.rb#37
  def on_optarg(node); end

  # source://rubocop//lib/rubocop/cop/naming/variable_name.rb#37
  def on_restarg(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/naming/variable_name.rb#33
  def valid_name?(node, name, given_style = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/naming/variable_name.rb#57
  def message(style); end
end

# source://rubocop//lib/rubocop/cop/naming/variable_name.rb#31
RuboCop::Cop::Naming::VariableName::MSG = T.let(T.unsafe(nil), String)

# Makes sure that all numbered variables use the
# configured style, snake_case, normalcase, or non_integer,
# for their numbering.
#
# Additionally, `CheckMethodNames` and `CheckSymbols` configuration options
# can be used to specify whether method names and symbols should be checked.
# Both are enabled by default.
#
# @example AllowedPatterns: ['_v\d+\z']
#   # good
#   :some_sym_v1
# @example EnforcedStyle: snake_case
#   # bad
#   :some_sym1
#   variable1 = 1
#
#   def some_method1; end
#
#   def some_method_1(arg1); end
#
#   # good
#   :some_sym_1
#   variable_1 = 1
#
#   def some_method_1; end
#
#   def some_method_1(arg_1); end
# @example EnforcedStyle: non_integer
#   # bad
#   :some_sym1
#   :some_sym_1
#
#   variable1 = 1
#   variable_1 = 1
#
#   def some_method1; end
#
#   def some_method_1; end
#
#   def some_methodone(arg1); end
#   def some_methodone(arg_1); end
#
#   # good
#   :some_symone
#   :some_sym_one
#
#   variableone = 1
#   variable_one = 1
#
#   def some_methodone; end
#
#   def some_method_one; end
#
#   def some_methodone(argone); end
#   def some_methodone(arg_one); end
#
#   # In the following examples, we assume `EnforcedStyle: normalcase` (default).
# @example CheckMethodNames: true (default)
#   # bad
#   def some_method_1; end
# @example CheckMethodNames: false
#   # good
#   def some_method_1; end
# @example CheckSymbols: true (default)
#   # bad
#   :some_sym_1
# @example CheckSymbols: false
#   # good
#   :some_sym_1
# @example AllowedIdentifiers: [capture3]
#   # good
#   expect(Open3).to receive(:capture3)
# @example EnforcedStyle: normalcase (default)
#   # bad
#   :some_sym_1
#   variable_1 = 1
#
#   def some_method_1; end
#
#   def some_method1(arg_1); end
#
#   # good
#   :some_sym1
#   variable1 = 1
#
#   def some_method1; end
#
#   def some_method1(arg1); end
#
# source://rubocop//lib/rubocop/cop/naming/variable_number.rb#103
class RuboCop::Cop::Naming::VariableNumber < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::AllowedIdentifiers
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableNumbering
  include ::RuboCop::Cop::AllowedPattern

  # source://rubocop//lib/rubocop/cop/naming/variable_number.rb#114
  def on_arg(node); end

  # source://rubocop//lib/rubocop/cop/naming/variable_number.rb#114
  def on_cvasgn(node); end

  # source://rubocop//lib/rubocop/cop/naming/variable_number.rb#126
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/naming/variable_number.rb#126
  def on_defs(node); end

  # source://rubocop//lib/rubocop/cop/naming/variable_number.rb#114
  def on_gvasgn(node); end

  # source://rubocop//lib/rubocop/cop/naming/variable_number.rb#114
  def on_ivasgn(node); end

  # source://rubocop//lib/rubocop/cop/naming/variable_number.rb#114
  def on_lvasgn(node); end

  # source://rubocop//lib/rubocop/cop/naming/variable_number.rb#134
  def on_sym(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/naming/variable_number.rb#110
  def valid_name?(node, name, given_style = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/naming/variable_number.rb#143
  def message(style); end
end

# source://rubocop//lib/rubocop/cop/naming/variable_number.rb#108
RuboCop::Cop::Naming::VariableNumber::MSG = T.let(T.unsafe(nil), String)

# Some common code shared between `NegatedIf` and
# `NegatedWhile` cops.
#
# source://rubocop//lib/rubocop/cop/mixin/negative_conditional.rb#7
module RuboCop::Cop::NegativeConditional
  extend ::RuboCop::AST::NodePattern::Macros

  # source://rubocop//lib/rubocop/cop/mixin/negative_conditional.rb#18
  def empty_condition?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/mixin/negative_conditional.rb#15
  def single_negative?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/mixin/negative_conditional.rb#20
  def check_negative_conditional(node, message:, &block); end
end

# source://rubocop//lib/rubocop/cop/mixin/negative_conditional.rb#10
RuboCop::Cop::NegativeConditional::MSG = T.let(T.unsafe(nil), String)

# This module provides a list of methods that are:
# 1. In the NilClass by default
# 2. Added to NilClass by explicitly requiring any standard libraries
# 3. Cop's configuration parameter AllowedMethods.
#
# source://rubocop//lib/rubocop/cop/mixin/nil_methods.rb#9
module RuboCop::Cop::NilMethods
  include ::RuboCop::Cop::AllowedMethods

  private

  # source://rubocop//lib/rubocop/cop/mixin/nil_methods.rb#14
  def nil_methods; end

  # source://rubocop//lib/rubocop/cop/mixin/nil_methods.rb#18
  def other_stdlib_methods; end
end

# An offense represents a style violation detected by RuboCop.
#
# source://rubocop//lib/rubocop/cop/offense.rb#6
class RuboCop::Cop::Offense
  include ::Comparable

  # @api private
  # @return [Offense] a new instance of Offense
  #
  # source://rubocop//lib/rubocop/cop/offense.rb#84
  def initialize(severity, location, message, cop_name, status = T.unsafe(nil), corrector = T.unsafe(nil)); end

  # Returns `-1`, `0`, or `+1`
  # if this offense is less than, equal to, or greater than `other`.
  #
  # @api public
  # @return [Integer] comparison result
  #
  # source://rubocop//lib/rubocop/cop/offense.rb#230
  def <=>(other); end

  # @api public
  # @return [Boolean] returns `true` if two offenses contain same attributes
  #
  # source://rubocop//lib/rubocop/cop/offense.rb#211
  def ==(other); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/offense.rb#160
  def column; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/offense.rb#170
  def column_length; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/offense.rb#194
  def column_range; end

  # @api public
  # @example
  #   'LineLength'
  # @return [String] a cop class name without department.
  #   i.e. type of the violation.
  #
  # source://rubocop//lib/rubocop/cop/offense.rb#51
  def cop_name; end

  # @api public
  # @return [Boolean] whether this offense can be automatically corrected via
  #   autocorrect or a todo.
  #
  # source://rubocop//lib/rubocop/cop/offense.rb#102
  def correctable?; end

  # @api public
  # @return [Boolean] whether this offense is automatically corrected via
  #   autocorrect or a todo.
  #
  # source://rubocop//lib/rubocop/cop/offense.rb#113
  def corrected?; end

  # @api public
  # @return [Boolean] whether this offense is automatically disabled via a todo.
  #
  # source://rubocop//lib/rubocop/cop/offense.rb#123
  def corrected_with_todo?; end

  # @api public
  # @return [Corrector | nil] the autocorrection for this offense, or `nil` when not available
  #
  # source://rubocop//lib/rubocop/cop/offense.rb#62
  def corrector; end

  # @api public
  # @return [Boolean] whether this offense was locally disabled with a
  #   disable or todo where it occurred.
  #
  # source://rubocop//lib/rubocop/cop/offense.rb#134
  def disabled?; end

  # @api public
  # @return [Boolean] returns `true` if two offenses contain same attributes
  #
  # source://rubocop//lib/rubocop/cop/offense.rb#211
  def eql?(other); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/offense.rb#179
  def first_line; end

  # source://rubocop//lib/rubocop/cop/offense.rb#219
  def hash; end

  # @api public
  # @return [Parser::Source::Range] the range of the code that is highlighted
  #
  # source://rubocop//lib/rubocop/cop/offense.rb#142
  def highlighted_area; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/offense.rb#189
  def last_column; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/offense.rb#184
  def last_line; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/offense.rb#155
  def line; end

  # @api public
  # @return [Parser::Source::Range] the location where the violation is detected.
  # @see https://www.rubydoc.info/gems/parser/Parser/Source/Range Parser::Source::Range
  #
  # source://rubocop//lib/rubocop/cop/offense.rb#28
  def location; end

  # @api public
  # @example
  #   'Line is too long. [90/80]'
  # @return [String] human-readable message
  #
  # source://rubocop//lib/rubocop/cop/offense.rb#39
  def message; end

  # Internally we use column number that start at 0, but when
  # outputting column numbers, we want them to start at 1. One
  # reason is that editors, such as Emacs, expect this.
  #
  # @api private
  #
  # source://rubocop//lib/rubocop/cop/offense.rb#203
  def real_column; end

  # @api public
  # @return [RuboCop::Cop::Severity]
  #
  # source://rubocop//lib/rubocop/cop/offense.rb#17
  def severity; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/offense.rb#165
  def source_line; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/offense.rb#54
  def status; end

  # This is just for debugging purpose.
  #
  # @api private
  #
  # source://rubocop//lib/rubocop/cop/offense.rb#148
  def to_s; end
end

# @api private
#
# source://rubocop//lib/rubocop/cop/offense.rb#10
RuboCop::Cop::Offense::COMPARISON_ATTRIBUTES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/offense.rb#81
RuboCop::Cop::Offense::NO_LOCATION = T.let(T.unsafe(nil), RuboCop::Cop::Offense::PseudoSourceRange)

# source://rubocop//lib/rubocop/cop/offense.rb#64
class RuboCop::Cop::Offense::PseudoSourceRange < ::Struct
  # Returns the value of attribute begin_pos
  #
  # @return [Object] the current value of begin_pos
  def begin_pos; end

  # Sets the attribute begin_pos
  #
  # @param value [Object] the value to set the attribute begin_pos to.
  # @return [Object] the newly set value
  def begin_pos=(_); end

  # Returns the value of attribute column
  #
  # @return [Object] the current value of column
  def column; end

  # Sets the attribute column
  #
  # @param value [Object] the value to set the attribute column to.
  # @return [Object] the newly set value
  def column=(_); end

  # source://rubocop//lib/rubocop/cop/offense.rb#70
  def column_range; end

  # Returns the value of attribute end_pos
  #
  # @return [Object] the current value of end_pos
  def end_pos; end

  # Sets the attribute end_pos
  #
  # @param value [Object] the value to set the attribute end_pos to.
  # @return [Object] the newly set value
  def end_pos=(_); end

  # Returns the value of attribute line
  #
  # @return [Object] the current value of line
  def first_line; end

  # Returns the value of attribute column
  #
  # @return [Object] the current value of column
  def last_column; end

  # Returns the value of attribute line
  #
  # @return [Object] the current value of line
  def last_line; end

  # source://rubocop//lib/rubocop/cop/offense.rb#74
  def length; end

  # Returns the value of attribute line
  #
  # @return [Object] the current value of line
  def line; end

  # Sets the attribute line
  #
  # @param value [Object] the value to set the attribute line to.
  # @return [Object] the newly set value
  def line=(_); end

  # source://rubocop//lib/rubocop/cop/offense.rb#74
  def size; end

  # Returns the value of attribute source_line
  #
  # @return [Object] the current value of source_line
  def source_line; end

  # Sets the attribute source_line
  #
  # @param value [Object] the value to set the attribute source_line to.
  # @return [Object] the newly set value
  def source_line=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# Common functionality for cops checking if and unless expressions.
#
# source://rubocop//lib/rubocop/cop/mixin/on_normal_if_unless.rb#6
module RuboCop::Cop::OnNormalIfUnless
  # source://rubocop//lib/rubocop/cop/mixin/on_normal_if_unless.rb#7
  def on_if(node); end
end

# This autocorrects gem dependency order
#
# source://rubocop//lib/rubocop/cop/correctors/ordered_gem_corrector.rb#6
class RuboCop::Cop::OrderedGemCorrector
  extend ::RuboCop::Cop::OrderedGemNode
  extend ::RuboCop::Cop::RangeHelp

  class << self
    # Returns the value of attribute comments_as_separators.
    #
    # source://rubocop//lib/rubocop/cop/correctors/ordered_gem_corrector.rb#11
    def comments_as_separators; end

    # source://rubocop//lib/rubocop/cop/correctors/ordered_gem_corrector.rb#13
    def correct(processed_source, node, previous_declaration, comments_as_separators); end

    # Returns the value of attribute processed_source.
    #
    # source://rubocop//lib/rubocop/cop/correctors/ordered_gem_corrector.rb#11
    def processed_source; end

    private

    # source://rubocop//lib/rubocop/cop/correctors/ordered_gem_corrector.rb#26
    def declaration_with_comment(node); end
  end
end

# Common functionality for Bundler/OrderedGems and
# Gemspec/OrderedDependencies.
#
# source://rubocop//lib/rubocop/cop/mixin/ordered_gem_node.rb#7
module RuboCop::Cop::OrderedGemNode
  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/ordered_gem_node.rb#23
  def case_insensitive_out_of_order?(string_a, string_b); end

  # source://rubocop//lib/rubocop/cop/mixin/ordered_gem_node.rb#27
  def consecutive_lines(previous, current); end

  # source://rubocop//lib/rubocop/cop/mixin/ordered_gem_node.rb#55
  def find_gem_name(gem_node); end

  # source://rubocop//lib/rubocop/cop/mixin/ordered_gem_node.rb#18
  def gem_canonical_name(name); end

  # source://rubocop//lib/rubocop/cop/mixin/ordered_gem_node.rb#49
  def gem_name(declaration_node); end

  # source://rubocop//lib/rubocop/cop/mixin/ordered_gem_node.rb#10
  def get_source_range(node, comments_as_separators); end

  # source://rubocop//lib/rubocop/cop/mixin/ordered_gem_node.rb#32
  def register_offense(previous, current); end

  # source://rubocop//lib/rubocop/cop/mixin/ordered_gem_node.rb#61
  def treat_comments_as_separators; end
end

# Common functionality for handling parentheses.
#
# source://rubocop//lib/rubocop/cop/mixin/parentheses.rb#6
module RuboCop::Cop::Parentheses
  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/parentheses.rb#9
  def parens_required?(node); end
end

# This autocorrects parentheses
#
# source://rubocop//lib/rubocop/cop/correctors/parentheses_corrector.rb#6
class RuboCop::Cop::ParenthesesCorrector
  extend ::RuboCop::Cop::RangeHelp

  class << self
    # source://rubocop//lib/rubocop/cop/correctors/parentheses_corrector.rb#12
    def correct(corrector, node); end

    private

    # Add a comma back after the heredoc identifier
    #
    # source://rubocop//lib/rubocop/cop/correctors/parentheses_corrector.rb#74
    def add_heredoc_comma(corrector, node); end

    # If the node contains a heredoc, remove the comma too
    # It'll be added back in the right place later
    #
    # source://rubocop//lib/rubocop/cop/correctors/parentheses_corrector.rb#64
    def extend_range_for_heredoc(node, range); end

    # If removing parentheses leaves a comma on its own line, remove all the whitespace
    # preceding it to prevent a syntax error.
    #
    # source://rubocop//lib/rubocop/cop/correctors/parentheses_corrector.rb#41
    def handle_orphaned_comma(corrector, node); end

    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/cop/correctors/parentheses_corrector.rb#80
    def heredoc?(node); end

    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/cop/correctors/parentheses_corrector.rb#28
    def next_char_is_question_mark?(node); end

    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/cop/correctors/parentheses_corrector.rb#32
    def only_closing_paren_before_comma?(node); end

    # Get a range for the closing parenthesis and all whitespace to the left of it
    #
    # source://rubocop//lib/rubocop/cop/correctors/parentheses_corrector.rb#51
    def parens_range(node); end

    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/cop/correctors/parentheses_corrector.rb#24
    def ternary_condition?(node); end
  end
end

# Common functionality for handling percent arrays.
#
# source://rubocop//lib/rubocop/cop/mixin/percent_array.rb#6
module RuboCop::Cop::PercentArray
  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/percent_array.rb#26
  def allowed_bracket_array?(node); end

  # @param node [RuboCop::AST::ArrayNode]
  # @param elements [Array<String>]
  # @return [String]
  #
  # source://rubocop//lib/rubocop/cop/mixin/percent_array.rb#83
  def build_bracketed_array_with_appropriate_whitespace(elements:, node:); end

  # @param preferred_array_code [String]
  # @return [String]
  #
  # source://rubocop//lib/rubocop/cop/mixin/percent_array.rb#56
  def build_message_for_bracketed_array(preferred_array_code); end

  # source://rubocop//lib/rubocop/cop/mixin/percent_array.rb#67
  def check_bracketed_array(node, literal_prefix); end

  # source://rubocop//lib/rubocop/cop/mixin/percent_array.rb#36
  def check_percent_array(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/percent_array.rb#31
  def comments_in_array?(node); end

  # Override to determine values that are invalid in a percent array
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/percent_array.rb#22
  def invalid_percent_array_contents?(_node); end

  # Ruby does not allow percent arrays in an ambiguous block context.
  #
  # @example
  #
  #   foo %i[bar baz] { qux }
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/percent_array.rb#14
  def invalid_percent_array_context?(node); end

  # Provides whitespace between elements for building a bracketed array.
  #   %w[  a   b   c    ]
  #         ^^^
  #
  # @param node [RuboCop::AST::ArrayNode]
  # @return [String]
  #
  # source://rubocop//lib/rubocop/cop/mixin/percent_array.rb#98
  def whitespace_between(node); end

  # Provides leading whitespace for building a bracketed array.
  #   %w[  a   b   c    ]
  #      ^^
  #
  # @param node [RuboCop::AST::ArrayNode]
  # @return [String]
  #
  # source://rubocop//lib/rubocop/cop/mixin/percent_array.rb#111
  def whitespace_leading(node); end

  # Provides trailing whitespace for building a bracketed array.
  #   %w[  a   b   c    ]
  #                 ^^^^
  #
  # @param node [RuboCop::AST::ArrayNode]
  # @return [String]
  #
  # source://rubocop//lib/rubocop/cop/mixin/percent_array.rb#120
  def whitespace_trailing(node); end
end

# Common functionality for handling percent literals.
#
# source://rubocop//lib/rubocop/cop/mixin/percent_literal.rb#6
module RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp

  private

  # source://rubocop//lib/rubocop/cop/mixin/percent_literal.rb#23
  def begin_source(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/percent_literal.rb#11
  def percent_literal?(node); end

  # source://rubocop//lib/rubocop/cop/mixin/percent_literal.rb#17
  def process(node, *types); end

  # source://rubocop//lib/rubocop/cop/mixin/percent_literal.rb#27
  def type(node); end
end

# This autocorrects percent literals
#
# source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#6
class RuboCop::Cop::PercentLiteralCorrector
  include ::RuboCop::PathUtil
  include ::RuboCop::Cop::Util

  # @return [PercentLiteralCorrector] a new instance of PercentLiteralCorrector
  #
  # source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#11
  def initialize(config, preferred_delimiters); end

  # Returns the value of attribute config.
  #
  # source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#9
  def config; end

  # source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#16
  def correct(corrector, node, char); end

  # Returns the value of attribute preferred_delimiters.
  #
  # source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#9
  def preferred_delimiters; end

  private

  # source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#46
  def autocorrect_multiline_words(node, escape, delimiters); end

  # source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#52
  def autocorrect_words(node, escape, delimiters); end

  # source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#34
  def delimiters_for(type); end

  # source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#100
  def end_content(source); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#30
  def escape_words?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#78
  def first_line?(node, previous_line_num); end

  # source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#89
  def fix_escaped_content(word_node, escape, delimiters); end

  # source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#69
  def line_breaks(node, source, previous_line_num, base_line_num, node_index); end

  # source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#38
  def new_contents(node, escape, delimiters); end

  # source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#82
  def process_lines(node, previous_line_num, base_line_num, source_in_lines); end

  # source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#58
  def process_multiline_words(node, escape, delimiters); end

  # source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#96
  def substitute_escaped_delimiters(content, delimiters); end

  # source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#26
  def wrap_contents(corrector, node, contents, char, delimiters); end
end

# Common functionality for checking whether an AST node/token is aligned
# with something on a preceding or following line
#
# source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#7
module RuboCop::Cop::PrecedingFollowingAlignment
  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#95
  def aligned_assignment?(range, line); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#91
  def aligned_char?(range, line); end

  # source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#70
  def aligned_comment_lines; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#107
  def aligned_identical?(range, line); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#83
  def aligned_operator?(range, line); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#77
  def aligned_token?(range, line); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#34
  def aligned_with_adjacent_line?(range, predicate); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#52
  def aligned_with_any_line?(line_ranges, range, indent = T.unsafe(nil), &predicate); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#42
  def aligned_with_any_line_range?(line_ranges, range, &predicate); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#100
  def aligned_with_append_operator?(range, line); end

  # source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#111
  def aligned_with_assignment(token, line_range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#56
  def aligned_with_line?(line_nos, range, indent = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#18
  def aligned_with_operator?(range); end

  # source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#22
  def aligned_with_preceding_assignment(token); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#14
  def aligned_with_something?(range); end

  # source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#28
  def aligned_with_subsequent_assignment(token); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#87
  def aligned_words?(range, line); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#10
  def allow_for_alignment?; end

  # source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#129
  def assignment_lines; end

  # source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#133
  def assignment_tokens; end

  # source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#149
  def relevant_assignment_lines(line_range); end

  # source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#176
  def remove_optarg_equals(asgn_tokens, processed_source); end
end

# Common functionality for handling percent literal delimiters.
#
# source://rubocop//lib/rubocop/cop/mixin/preferred_delimiters.rb#6
class RuboCop::Cop::PreferredDelimiters
  # @return [PreferredDelimiters] a new instance of PreferredDelimiters
  #
  # source://rubocop//lib/rubocop/cop/mixin/preferred_delimiters.rb#11
  def initialize(type, config, preferred_delimiters); end

  # Returns the value of attribute config.
  #
  # source://rubocop//lib/rubocop/cop/mixin/preferred_delimiters.rb#7
  def config; end

  # source://rubocop//lib/rubocop/cop/mixin/preferred_delimiters.rb#17
  def delimiters; end

  # Returns the value of attribute type.
  #
  # source://rubocop//lib/rubocop/cop/mixin/preferred_delimiters.rb#7
  def type; end

  private

  # @raise [ArgumentError]
  #
  # source://rubocop//lib/rubocop/cop/mixin/preferred_delimiters.rb#23
  def ensure_valid_preferred_delimiters; end

  # source://rubocop//lib/rubocop/cop/mixin/preferred_delimiters.rb#30
  def preferred_delimiters; end

  # source://rubocop//lib/rubocop/cop/mixin/preferred_delimiters.rb#45
  def preferred_delimiters_config; end
end

# source://rubocop//lib/rubocop/cop/mixin/preferred_delimiters.rb#9
RuboCop::Cop::PreferredDelimiters::PERCENT_LITERAL_TYPES = T.let(T.unsafe(nil), Array)

# This autocorrects punctuation
#
# source://rubocop//lib/rubocop/cop/correctors/punctuation_corrector.rb#6
class RuboCop::Cop::PunctuationCorrector
  class << self
    # source://rubocop//lib/rubocop/cop/correctors/punctuation_corrector.rb#12
    def add_space(corrector, token); end

    # source://rubocop//lib/rubocop/cop/correctors/punctuation_corrector.rb#8
    def remove_space(corrector, space_before); end

    # source://rubocop//lib/rubocop/cop/correctors/punctuation_corrector.rb#16
    def swap_comma(corrector, range); end
  end
end

# Methods that calculate and return Parser::Source::Ranges
#
# source://rubocop//lib/rubocop/cop/mixin/range_help.rb#6
module RuboCop::Cop::RangeHelp
  private

  # source://rubocop//lib/rubocop/cop/mixin/range_help.rb#141
  def add_range(range1, range2); end

  # source://rubocop//lib/rubocop/cop/mixin/range_help.rb#82
  def column_offset_between(base_range, range); end

  # A range containing only the contents of a literal with delimiters (e.g. in
  # `%i{1 2 3}` this will be the range covering `1 2 3` only).
  #
  # source://rubocop//lib/rubocop/cop/mixin/range_help.rb#32
  def contents_range(node); end

  # source://rubocop//lib/rubocop/cop/mixin/range_help.rb#100
  def directions(side); end

  # Returns the column attribute of the range, except if the range is on
  # the first line and there's a byte order mark at the beginning of that
  # line, in which case 1 is subtracted from the column value. This gives
  # the column as it appears when viewing the file in an editor.
  #
  # source://rubocop//lib/rubocop/cop/mixin/range_help.rb#92
  def effective_column(range); end

  # source://rubocop//lib/rubocop/cop/mixin/range_help.rb#109
  def final_pos(src, pos, increment, continuations, newlines, whitespace); end

  # source://rubocop//lib/rubocop/cop/mixin/range_help.rb#117
  def move_pos(src, pos, step, condition, regexp); end

  # source://rubocop//lib/rubocop/cop/mixin/range_help.rb#123
  def move_pos_str(src, pos, step, condition, needle); end

  # source://rubocop//lib/rubocop/cop/mixin/range_help.rb#36
  def range_between(start_pos, end_pos); end

  # source://rubocop//lib/rubocop/cop/mixin/range_help.rb#73
  def range_by_whole_lines(range, include_final_newline: T.unsafe(nil), buffer: T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/mixin/range_help.rb#134
  def range_with_comments(node); end

  # source://rubocop//lib/rubocop/cop/mixin/range_help.rb#130
  def range_with_comments_and_lines(node); end

  # source://rubocop//lib/rubocop/cop/mixin/range_help.rb#40
  def range_with_surrounding_comma(range, side = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/mixin/range_help.rb#55
  def range_with_surrounding_space(range_positional = T.unsafe(nil), range: T.unsafe(nil), side: T.unsafe(nil), newlines: T.unsafe(nil), whitespace: T.unsafe(nil), continuations: T.unsafe(nil), buffer: T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/mixin/range_help.rb#11
  def source_range(source_buffer, line_number, column, length = T.unsafe(nil)); end
end

# The Unicode codepoint
#
# source://rubocop//lib/rubocop/cop/mixin/range_help.rb#9
RuboCop::Cop::RangeHelp::BYTE_ORDER_MARK = T.let(T.unsafe(nil), Integer)

# source://rubocop//lib/rubocop/cop/mixin/range_help.rb#54
module RuboCop::Cop::RangeHelp::NOT_GIVEN; end

# Common functionality for handling Rational literals.
#
# source://rubocop//lib/rubocop/cop/mixin/rational_literal.rb#6
module RuboCop::Cop::RationalLiteral
  extend ::RuboCop::AST::NodePattern::Macros

  # source://rubocop//lib/rubocop/cop/mixin/rational_literal.rb#12
  def rational_literal?(param0 = T.unsafe(nil)); end
end

# Registry that tracks all cops by their badge and department.
#
# source://rubocop//lib/rubocop/cop/registry.rb#19
class RuboCop::Cop::Registry
  include ::Enumerable

  # @return [Registry] a new instance of Registry
  #
  # source://rubocop//lib/rubocop/cop/registry.rb#51
  def initialize(cops = T.unsafe(nil), options = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/registry.rb#232
  def ==(other); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/registry.rb#97
  def contains_cop_matching?(names); end

  # source://rubocop//lib/rubocop/cop/registry.rb#179
  def cops; end

  # source://rubocop//lib/rubocop/cop/registry.rb#224
  def cops_for_department(department); end

  # @return [Boolean] Checks if given name is department
  #
  # source://rubocop//lib/rubocop/cop/registry.rb#93
  def department?(name); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/registry.rb#147
  def department_missing?(badge, name); end

  # @return [Array<Symbol>] list of departments for current cops.
  #
  # source://rubocop//lib/rubocop/cop/registry.rb#72
  def departments; end

  # source://rubocop//lib/rubocop/cop/registry.rb#193
  def disabled(config); end

  # source://rubocop//lib/rubocop/cop/registry.rb#67
  def dismiss(cop); end

  # source://rubocop//lib/rubocop/cop/registry.rb#247
  def each(&block); end

  # source://rubocop//lib/rubocop/cop/registry.rb#189
  def enabled(config); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/registry.rb#197
  def enabled?(cop, config); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/registry.rb#213
  def enabled_pending_cop?(cop_cfg, config); end

  # source://rubocop//lib/rubocop/cop/registry.rb#63
  def enlist(cop); end

  # @param cop_name [String]
  # @return [Class, nil]
  #
  # source://rubocop//lib/rubocop/cop/registry.rb#253
  def find_by_cop_name(cop_name); end

  # When a cop name is given returns a single-element array with the cop class.
  # When a department name is given returns an array with all the cop classes
  # for that department.
  #
  # source://rubocop//lib/rubocop/cop/registry.rb#260
  def find_cops_by_directive(directive); end

  # source://rubocop//lib/rubocop/cop/registry.rb#265
  def freeze; end

  # source://rubocop//lib/rubocop/cop/registry.rb#184
  def length; end

  # source://rubocop//lib/rubocop/cop/registry.rb#220
  def names; end

  # source://rubocop//lib/rubocop/cop/registry.rb#228
  def names_for_department(department); end

  # Returns the value of attribute options.
  #
  # source://rubocop//lib/rubocop/cop/registry.rb#49
  def options; end

  # source://rubocop//lib/rubocop/cop/registry.rb#151
  def print_warning(name, path); end

  # Convert a user provided cop name into a properly namespaced name
  #
  # @example gives back a correctly qualified cop name
  #
  #   registry = RuboCop::Cop::Registry
  #   registry.qualified_cop_name('Layout/EndOfLine', '') # => 'Layout/EndOfLine'
  # @example fixes incorrect namespaces
  #
  #   registry = RuboCop::Cop::Registry
  #   registry.qualified_cop_name('Lint/EndOfLine', '') # => 'Layout/EndOfLine'
  # @example namespaces bare cop identifiers
  #
  #   registry = RuboCop::Cop::Registry
  #   registry.qualified_cop_name('EndOfLine', '') # => 'Layout/EndOfLine'
  # @example passes back unrecognized cop names
  #
  #   registry = RuboCop::Cop::Registry
  #   registry.qualified_cop_name('NotACop', '') # => 'NotACop'
  # @note Emits a warning if the provided name has an incorrect namespace
  # @param name [String] Cop name extracted from config
  # @param path [String, nil] Path of file that `name` was extracted from
  # @param warn [Boolean] Print a warning if no department given for `name`
  # @raise [AmbiguousCopName] if a bare identifier with two possible namespaces is provided
  # @return [String] Qualified cop name
  #
  # source://rubocop//lib/rubocop/cop/registry.rb#133
  def qualified_cop_name(name, path, warn: T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/registry.rb#166
  def qualify_badge(badge); end

  # source://rubocop//lib/rubocop/cop/registry.rb#243
  def select(&block); end

  # source://rubocop//lib/rubocop/cop/registry.rb#236
  def sort!; end

  # @return [Hash{String => Array<Class>}]
  #
  # source://rubocop//lib/rubocop/cop/registry.rb#174
  def to_h; end

  # source://rubocop//lib/rubocop/cop/registry.rb#159
  def unqualified_cop_names; end

  # @return [Registry] Cops for that specific department.
  #
  # source://rubocop//lib/rubocop/cop/registry.rb#78
  def with_department(department); end

  # @return [Registry] Cops not for a specific department.
  #
  # source://rubocop//lib/rubocop/cop/registry.rb#84
  def without_department(department); end

  private

  # source://rubocop//lib/rubocop/cop/registry.rb#283
  def clear_enrollment_queue; end

  # source://rubocop//lib/rubocop/cop/registry.rb#279
  def initialize_copy(reg); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/registry.rb#309
  def registered?(badge); end

  # source://rubocop//lib/rubocop/cop/registry.rb#299
  def resolve_badge(given_badge, real_badge, source_path); end

  # source://rubocop//lib/rubocop/cop/registry.rb#295
  def with(cops); end

  class << self
    # source://rubocop//lib/rubocop/cop/registry.rb#22
    def all; end

    # Returns the value of attribute global.
    #
    # source://rubocop//lib/rubocop/cop/registry.rb#274
    def global; end

    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/cop/registry.rb#44
    def qualified_cop?(name); end

    # source://rubocop//lib/rubocop/cop/registry.rb#26
    def qualified_cop_name(name, origin); end

    # source://rubocop//lib/rubocop/cop/registry.rb#40
    def reset!; end

    # Changes momentarily the global registry
    # Intended for testing purposes
    #
    # source://rubocop//lib/rubocop/cop/registry.rb#32
    def with_temporary_global(temp_global = T.unsafe(nil)); end
  end
end

# Ensure a require statement is present for a standard library determined
# by variable library_name
#
# source://rubocop//lib/rubocop/cop/mixin/require_library.rb#7
module RuboCop::Cop::RequireLibrary
  extend ::RuboCop::AST::NodePattern::Macros

  # source://rubocop//lib/rubocop/cop/mixin/require_library.rb#12
  def ensure_required(corrector, node, library_name); end

  # source://rubocop//lib/rubocop/cop/mixin/require_library.rb#33
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/mixin/require_library.rb#24
  def remove_subsequent_requires(corrector, node, library_name); end

  # source://rubocop//lib/rubocop/cop/mixin/require_library.rb#51
  def require_any_library?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/mixin/require_library.rb#56
  def require_library_name?(param0 = T.unsafe(nil), param1); end

  private

  # source://rubocop//lib/rubocop/cop/mixin/require_library.rb#44
  def on_new_investigation; end
end

# source://rubocop//lib/rubocop/cop/mixin/require_library.rb#10
RuboCop::Cop::RequireLibrary::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This class ensures a require statement is present for a standard library
# determined by the variable library_name
#
# source://rubocop//lib/rubocop/cop/correctors/require_library_corrector.rb#7
class RuboCop::Cop::RequireLibraryCorrector
  extend ::RuboCop::Cop::RangeHelp

  class << self
    # source://rubocop//lib/rubocop/cop/correctors/require_library_corrector.rb#11
    def correct(corrector, node, library_name); end

    # source://rubocop//lib/rubocop/cop/correctors/require_library_corrector.rb#17
    def require_statement(library_name); end
  end
end

# Common functionality for checking `rescue` nodes.
#
# source://rubocop//lib/rubocop/cop/mixin/rescue_node.rb#6
module RuboCop::Cop::RescueNode
  # source://rubocop//lib/rubocop/cop/mixin/rescue_node.rb#7
  def modifier_locations; end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/rescue_node.rb#13
  def rescue_modifier?(node); end

  # @deprecated Use ResbodyNode#exceptions instead
  #
  # source://rubocop//lib/rubocop/cop/mixin/rescue_node.rb#20
  def rescued_exceptions(resbody); end
end

# Common functionality for safe assignment. By safe assignment we mean
# putting parentheses around an assignment to indicate "I know I'm using an
# assignment as a condition. It's not a mistake."
#
# source://rubocop//lib/rubocop/cop/mixin/safe_assignment.rb#8
module RuboCop::Cop::SafeAssignment
  extend ::RuboCop::AST::NodePattern::Macros

  # source://rubocop//lib/rubocop/cop/mixin/safe_assignment.rb#14
  def empty_condition?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/mixin/safe_assignment.rb#20
  def safe_assignment?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/mixin/safe_assignment.rb#17
  def setter_method?(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/safe_assignment.rb#22
  def safe_assignment_allowed?; end
end

# source://rubocop//lib/rubocop/cop/security/compound_hash.rb#5
module RuboCop::Cop::Security; end

# Checks for implementations of the `hash` method which combine
# values using custom logic instead of delegating to `Array#hash`.
#
# Manually combining hashes is error prone and hard to follow, especially
# when there are many values. Poor implementations may also introduce
# performance or security concerns if they are prone to collisions.
# Delegating to `Array#hash` is clearer and safer, although it might be slower
# depending on the use case.
#
# @example
#
#   # bad
#   def hash
#   @foo ^ @bar
#   end
#
#   # good
#   def hash
#   [@foo, @bar].hash
#   end
#
# source://rubocop//lib/rubocop/cop/security/compound_hash.rb#30
class RuboCop::Cop::Security::CompoundHash < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/security/compound_hash.rb#58
  def bad_hash_combinator?(param0 = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/security/compound_hash.rb#75
  def contained_in_hash_method?(node, &block); end

  # source://rubocop//lib/rubocop/cop/security/compound_hash.rb#42
  def dynamic_hash_method_definition?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/security/compound_hash.rb#37
  def hash_method_definition?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/security/compound_hash.rb#63
  def monuple_hash?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/security/compound_hash.rb#87
  def on_op_asgn(node); end

  # source://rubocop//lib/rubocop/cop/security/compound_hash.rb#87
  def on_send(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/security/compound_hash.rb#81
  def outer_bad_hash_combinator?(node); end

  # source://rubocop//lib/rubocop/cop/security/compound_hash.rb#68
  def redundant_hash?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/security/compound_hash.rb#51
  def static_hash_method_definition?(param0 = T.unsafe(nil)); end
end

# source://rubocop//lib/rubocop/cop/security/compound_hash.rb#31
RuboCop::Cop::Security::CompoundHash::COMBINATOR_IN_HASH_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/security/compound_hash.rb#32
RuboCop::Cop::Security::CompoundHash::MONUPLE_HASH_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/security/compound_hash.rb#34
RuboCop::Cop::Security::CompoundHash::REDUNDANT_HASH_MSG = T.let(T.unsafe(nil), String)

# Checks for the use of `Kernel#eval` and `Binding#eval`.
#
# @example
#
#   # bad
#
#   eval(something)
#   binding.eval(something)
#
# source://rubocop//lib/rubocop/cop/security/eval.rb#14
class RuboCop::Cop::Security::Eval < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/security/eval.rb#19
  def eval?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/security/eval.rb#23
  def on_send(node); end
end

# source://rubocop//lib/rubocop/cop/security/eval.rb#15
RuboCop::Cop::Security::Eval::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/security/eval.rb#16
RuboCop::Cop::Security::Eval::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for the first argument to `IO.read`, `IO.binread`, `IO.write`, `IO.binwrite`,
# `IO.foreach`, and `IO.readlines`.
#
# If argument starts with a pipe character (`'|'`) and the receiver is the `IO` class,
# a subprocess is created in the same way as `Kernel#open`, and its output is returned.
# `Kernel#open` may allow unintentional command injection, which is the reason these
# `IO` methods are a security risk.
# Consider to use `File.read` to disable the behavior of subprocess invocation.
#
# @example
#
#   # bad
#   IO.read(path)
#   IO.read('path')
#
#   # good
#   File.read(path)
#   File.read('path')
#   IO.read('| command') # Allow intentional command invocation.
#
# source://rubocop//lib/rubocop/cop/security/io_methods.rb#30
class RuboCop::Cop::Security::IoMethods < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/security/io_methods.rb#36
  def on_send(node); end
end

# source://rubocop//lib/rubocop/cop/security/io_methods.rb#33
RuboCop::Cop::Security::IoMethods::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/security/io_methods.rb#34
RuboCop::Cop::Security::IoMethods::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for the use of JSON class methods which have potential
# security issues.
#
# @example
#   # bad
#   JSON.load("{}")
#   JSON.restore("{}")
#
#   # good
#   JSON.parse("{}")
#
# source://rubocop//lib/rubocop/cop/security/json_load.rb#26
class RuboCop::Cop::Security::JSONLoad < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/security/json_load.rb#33
  def json_load(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/security/json_load.rb#37
  def on_send(node); end
end

# source://rubocop//lib/rubocop/cop/security/json_load.rb#29
RuboCop::Cop::Security::JSONLoad::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/security/json_load.rb#30
RuboCop::Cop::Security::JSONLoad::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for the use of Marshal class methods which have
# potential security issues leading to remote code execution when
# loading from an untrusted source.
#
# @example
#   # bad
#   Marshal.load("{}")
#   Marshal.restore("{}")
#
#   # good
#   Marshal.dump("{}")
#
#   # okish - deep copy hack
#   Marshal.load(Marshal.dump({}))
#
# source://rubocop//lib/rubocop/cop/security/marshal_load.rb#21
class RuboCop::Cop::Security::MarshalLoad < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/security/marshal_load.rb#26
  def marshal_load(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/security/marshal_load.rb#31
  def on_send(node); end
end

# source://rubocop//lib/rubocop/cop/security/marshal_load.rb#22
RuboCop::Cop::Security::MarshalLoad::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/security/marshal_load.rb#23
RuboCop::Cop::Security::MarshalLoad::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for the use of `Kernel#open` and `URI.open` with dynamic
# data.
#
# `Kernel#open` and `URI.open` enable not only file access but also process
# invocation by prefixing a pipe symbol (e.g., `open("| ls")`).
# So, it may lead to a serious security risk by using variable input to
# the argument of `Kernel#open` and `URI.open`. It would be better to use
# `File.open`, `IO.popen` or `URI.parse#open` explicitly.
#
# NOTE: `open` and `URI.open` with literal strings are not flagged by this
# cop.
#
# @example
#   # bad
#   open(something)
#   open("| #{something}")
#   URI.open(something)
#
#   # good
#   File.open(something)
#   IO.popen(something)
#   URI.parse(something).open
#
#   # good (literal strings)
#   open("foo.text")
#   open("| foo")
#   URI.open("http://example.com")
#
# source://rubocop//lib/rubocop/cop/security/open.rb#37
class RuboCop::Cop::Security::Open < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/security/open.rb#46
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/security/open.rb#42
  def open?(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/security/open.rb#75
  def composite_string?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/security/open.rb#83
  def concatenated_string?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/security/open.rb#79
  def interpolated_string?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/security/open.rb#57
  def safe?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/security/open.rb#67
  def safe_argument?(argument); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/security/open.rb#71
  def simple_string?(node); end
end

# source://rubocop//lib/rubocop/cop/security/open.rb#38
RuboCop::Cop::Security::Open::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/security/open.rb#39
RuboCop::Cop::Security::Open::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for the use of YAML class methods which have
# potential security issues leading to remote code execution when
# loading from an untrusted source.
#
# NOTE: Ruby 3.1+ (Psych 4) uses `Psych.load` as `Psych.safe_load` by default.
#
# @example
#   # bad
#   YAML.load("--- !ruby/object:Foo {}") # Psych 3 is unsafe by default
#
#   # good
#   YAML.safe_load("--- !ruby/object:Foo {}", [Foo])                    # Ruby 2.5  (Psych 3)
#   YAML.safe_load("--- !ruby/object:Foo {}", permitted_classes: [Foo]) # Ruby 3.0- (Psych 3)
#   YAML.load("--- !ruby/object:Foo {}", permitted_classes: [Foo])      # Ruby 3.1+ (Psych 4)
#   YAML.dump(foo)
#
# source://rubocop//lib/rubocop/cop/security/yaml_load.rb#26
class RuboCop::Cop::Security::YAMLLoad < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/security/yaml_load.rb#37
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/security/yaml_load.rb#33
  def yaml_load(param0 = T.unsafe(nil)); end
end

# source://rubocop//lib/rubocop/cop/security/yaml_load.rb#29
RuboCop::Cop::Security::YAMLLoad::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/security/yaml_load.rb#30
RuboCop::Cop::Security::YAMLLoad::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Severity class is simple value object about severity
#
# source://rubocop//lib/rubocop/cop/severity.rb#6
class RuboCop::Cop::Severity
  include ::Comparable

  # @api private
  # @raise [ArgumentError]
  # @return [Severity] a new instance of Severity
  #
  # source://rubocop//lib/rubocop/cop/severity.rb#30
  def initialize(name_or_code); end

  # source://rubocop//lib/rubocop/cop/severity.rb#62
  def <=>(other); end

  # source://rubocop//lib/rubocop/cop/severity.rb#50
  def ==(other); end

  # source://rubocop//lib/rubocop/cop/severity.rb#42
  def code; end

  # source://rubocop//lib/rubocop/cop/severity.rb#58
  def hash; end

  # source://rubocop//lib/rubocop/cop/severity.rb#46
  def level; end

  # @api public
  # @return [Symbol] severity.
  #   any of `:info`, `:refactor`, `:convention`, `:warning`, `:error` or `:fatal`.
  #
  # source://rubocop//lib/rubocop/cop/severity.rb#22
  def name; end

  # source://rubocop//lib/rubocop/cop/severity.rb#38
  def to_s; end

  class << self
    # source://rubocop//lib/rubocop/cop/severity.rb#24
    def name_from_code(code); end
  end
end

# @api private
#
# source://rubocop//lib/rubocop/cop/severity.rb#12
RuboCop::Cop::Severity::CODE_TABLE = T.let(T.unsafe(nil), Hash)

# source://rubocop//lib/rubocop/cop/severity.rb#9
RuboCop::Cop::Severity::NAMES = T.let(T.unsafe(nil), Array)

# Common functionality for cops checking for missing space after
# punctuation.
#
# source://rubocop//lib/rubocop/cop/mixin/space_after_punctuation.rb#7
module RuboCop::Cop::SpaceAfterPunctuation
  # source://rubocop//lib/rubocop/cop/mixin/space_after_punctuation.rb#10
  def on_new_investigation; end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/space_after_punctuation.rb#38
  def allowed_type?(token); end

  # source://rubocop//lib/rubocop/cop/mixin/space_after_punctuation.rb#20
  def each_missing_space(tokens); end

  # The normal offset, i.e., the distance from the punctuation
  # token where a space should be, is 1.
  #
  # source://rubocop//lib/rubocop/cop/mixin/space_after_punctuation.rb#49
  def offset; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/space_after_punctuation.rb#42
  def space_forbidden_before_rcurly?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/space_after_punctuation.rb#30
  def space_missing?(token1, token2); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/space_after_punctuation.rb#34
  def space_required_before?(token); end
end

# source://rubocop//lib/rubocop/cop/mixin/space_after_punctuation.rb#8
RuboCop::Cop::SpaceAfterPunctuation::MSG = T.let(T.unsafe(nil), String)

# Common functionality for cops checking for space before
# punctuation.
#
# source://rubocop//lib/rubocop/cop/mixin/space_before_punctuation.rb#7
module RuboCop::Cop::SpaceBeforePunctuation
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/mixin/space_before_punctuation.rb#12
  def on_new_investigation; end

  private

  # source://rubocop//lib/rubocop/cop/mixin/space_before_punctuation.rb#22
  def each_missing_space(tokens); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/space_before_punctuation.rb#34
  def space_missing?(token1, token2); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/space_before_punctuation.rb#38
  def space_required_after?(token); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/space_before_punctuation.rb#42
  def space_required_after_lcurly?; end
end

# source://rubocop//lib/rubocop/cop/mixin/space_before_punctuation.rb#10
RuboCop::Cop::SpaceBeforePunctuation::MSG = T.let(T.unsafe(nil), String)

# This autocorrects whitespace
#
# source://rubocop//lib/rubocop/cop/correctors/space_corrector.rb#6
class RuboCop::Cop::SpaceCorrector
  extend ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::SurroundingSpace

  class << self
    # source://rubocop//lib/rubocop/cop/correctors/space_corrector.rb#36
    def add_space(processed_source, corrector, left_token, right_token); end

    # source://rubocop//lib/rubocop/cop/correctors/space_corrector.rb#12
    def empty_corrections(processed_source, corrector, empty_config, left_token, right_token); end

    # Returns the value of attribute processed_source.
    #
    # source://rubocop//lib/rubocop/cop/correctors/space_corrector.rb#10
    def processed_source; end

    # source://rubocop//lib/rubocop/cop/correctors/space_corrector.rb#24
    def remove_space(processed_source, corrector, left_token, right_token); end
  end
end

# Common functionality for modifier cops.
#
# source://rubocop//lib/rubocop/cop/mixin/statement_modifier.rb#6
module RuboCop::Cop::StatementModifier
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::LineLengthHelp
  include ::RuboCop::Cop::RangeHelp

  private

  # source://rubocop//lib/rubocop/cop/mixin/statement_modifier.rb#79
  def code_after(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/statement_modifier.rb#103
  def comment_disables_cop?(comment); end

  # source://rubocop//lib/rubocop/cop/mixin/statement_modifier.rb#71
  def first_line_comment(node); end

  # source://rubocop//lib/rubocop/cop/mixin/statement_modifier.rb#58
  def if_body_source(if_body); end

  # source://rubocop//lib/rubocop/cop/mixin/statement_modifier.rb#44
  def length_in_modifier_form(node); end

  # source://rubocop//lib/rubocop/cop/mixin/statement_modifier.rb#97
  def max_line_length; end

  # source://rubocop//lib/rubocop/cop/mixin/statement_modifier.rb#67
  def method_source(if_body); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/statement_modifier.rb#38
  def modifier_fits_on_single_line?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/statement_modifier.rb#27
  def non_eligible_body?(body); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/statement_modifier.rb#34
  def non_eligible_condition?(condition); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/statement_modifier.rb#20
  def non_eligible_node?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/statement_modifier.rb#85
  def parenthesize?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/statement_modifier.rb#12
  def single_line_as_modifier?(node); end

  # source://rubocop//lib/rubocop/cop/mixin/statement_modifier.rb#51
  def to_modifier_form(node); end
end

# Classes that include this module just implement functions to determine
# what is an offense and how to do autocorrection. They get help with
# adding offenses for the faulty string nodes, and with filtering out
# nodes.
#
# source://rubocop//lib/rubocop/cop/mixin/string_help.rb#9
module RuboCop::Cop::StringHelp
  # source://rubocop//lib/rubocop/cop/mixin/string_help.rb#26
  def on_regexp(node); end

  # source://rubocop//lib/rubocop/cop/mixin/string_help.rb#10
  def on_str(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/string_help.rb#32
  def inside_interpolation?(node); end
end

# This autocorrects string literals
#
# source://rubocop//lib/rubocop/cop/correctors/string_literal_corrector.rb#6
class RuboCop::Cop::StringLiteralCorrector
  extend ::RuboCop::PathUtil
  extend ::RuboCop::Cop::Util

  class << self
    # source://rubocop//lib/rubocop/cop/correctors/string_literal_corrector.rb#10
    def correct(corrector, node, style); end
  end
end

# Common functionality for cops checking single/double quotes.
#
# source://rubocop//lib/rubocop/cop/mixin/string_literals_help.rb#6
module RuboCop::Cop::StringLiteralsHelp
  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/string_literals_help.rb#9
  def wrong_quotes?(src_or_node); end
end

# source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#5
module RuboCop::Cop::Style; end

# Access modifiers should be declared to apply to a group of methods
# or inline before each method, depending on configuration.
# EnforcedStyle config covers only method definitions.
# Applications of visibility methods to symbols can be controlled
# using AllowModifiersOnSymbols config.
#
# @example EnforcedStyle: group (default)
#   # bad
#   class Foo
#
#   private def bar; end
#   private def baz; end
#
#   end
#
#   # good
#   class Foo
#
#   private
#
#   def bar; end
#   def baz; end
#
#   end
# @example EnforcedStyle: inline
#   # bad
#   class Foo
#
#   private
#
#   def bar; end
#   def baz; end
#
#   end
#
#   # good
#   class Foo
#
#   private def bar; end
#   private def baz; end
#
#   end
# @example AllowModifiersOnSymbols: true (default)
#   # good
#   class Foo
#
#   private :bar, :baz
#
#   end
# @example AllowModifiersOnSymbols: false
#   # bad
#   class Foo
#
#   private :bar, :baz
#
#   end
#
# source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#70
class RuboCop::Cop::Style::AccessModifierDeclarations < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#91
  def access_modifier_with_symbol?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#95
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#145
  def access_modifier_is_inlined?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#149
  def access_modifier_is_not_inlined?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#127
  def allow_modifiers_on_symbols?(node); end

  # source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#112
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#219
  def def_source(node, def_node); end

  # source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#180
  def find_argument_less_modifier_node(node); end

  # source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#169
  def find_corresponding_def_node(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#137
  def group_style?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#141
  def inline_style?; end

  # source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#211
  def insert_inline_modifier(corrector, node, modifier_name); end

  # source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#159
  def message(range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#131
  def offense?(node); end

  # source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#215
  def remove_node(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#194
  def replace_def(corrector, node, def_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#153
  def right_siblings_same_inline_method?(node); end

  # source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#188
  def select_grouped_def_nodes(node); end
end

# source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#88
RuboCop::Cop::Style::AccessModifierDeclarations::ALLOWED_NODE_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#76
RuboCop::Cop::Style::AccessModifierDeclarations::GROUP_STYLE_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#81
RuboCop::Cop::Style::AccessModifierDeclarations::INLINE_STYLE_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#86
RuboCop::Cop::Style::AccessModifierDeclarations::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for grouping of accessors in `class` and `module` bodies.
# By default it enforces accessors to be placed in grouped declarations,
# but it can be configured to enforce separating them in multiple declarations.
#
# NOTE: If there is a method call before the accessor method it is always allowed
# as it might be intended like Sorbet.
#
# @example EnforcedStyle: grouped (default)
#   # bad
#   class Foo
#   attr_reader :bar
#   attr_reader :bax
#   attr_reader :baz
#   end
#
#   # good
#   class Foo
#   attr_reader :bar, :bax, :baz
#   end
#
#   # good
#   class Foo
#   # may be intended comment for bar.
#   attr_reader :bar
#
#   sig { returns(String) }
#   attr_reader :bax
#
#   may_be_intended_annotation :baz
#   attr_reader :baz
#   end
# @example EnforcedStyle: separated
#   # bad
#   class Foo
#   attr_reader :bar, :baz
#   end
#
#   # good
#   class Foo
#   attr_reader :bar
#   attr_reader :baz
#   end
#
# source://rubocop//lib/rubocop/cop/style/accessor_grouping.rb#50
class RuboCop::Cop::Style::AccessorGrouping < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::VisibilityHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/accessor_grouping.rb#59
  def on_class(node); end

  # source://rubocop//lib/rubocop/cop/style/accessor_grouping.rb#59
  def on_module(node); end

  # source://rubocop//lib/rubocop/cop/style/accessor_grouping.rb#59
  def on_sclass(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/accessor_grouping.rb#82
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/accessor_grouping.rb#71
  def check(send_node); end

  # source://rubocop//lib/rubocop/cop/style/accessor_grouping.rb#110
  def class_send_elements(class_node); end

  # source://rubocop//lib/rubocop/cop/style/accessor_grouping.rb#153
  def group_accessors(node, accessors); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/accessor_grouping.rb#95
  def groupable_accessor?(node); end

  # source://rubocop//lib/rubocop/cop/style/accessor_grouping.rb#130
  def groupable_sibling_accessors(send_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/accessor_grouping.rb#122
  def grouped_style?; end

  # source://rubocop//lib/rubocop/cop/style/accessor_grouping.rb#139
  def message(send_node); end

  # source://rubocop//lib/rubocop/cop/style/accessor_grouping.rb#144
  def preferred_accessors(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/accessor_grouping.rb#91
  def previous_line_comment?(node); end

  # source://rubocop//lib/rubocop/cop/style/accessor_grouping.rb#159
  def separate_accessors(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/accessor_grouping.rb#126
  def separated_style?; end
end

# source://rubocop//lib/rubocop/cop/style/accessor_grouping.rb#56
RuboCop::Cop::Style::AccessorGrouping::GROUPED_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/accessor_grouping.rb#57
RuboCop::Cop::Style::AccessorGrouping::SEPARATED_MSG = T.let(T.unsafe(nil), String)

# Enforces the use of either `#alias` or `#alias_method`
# depending on configuration.
# It also flags uses of `alias :symbol` rather than `alias bareword`.
#
# However, it will always enforce `method_alias` when used `alias`
# in an instance method definition and in a singleton method definition.
# If used in a block, always enforce `alias_method`
# unless it is an `instance_eval` block.
#
# @example EnforcedStyle: prefer_alias (default)
#   # bad
#   alias_method :bar, :foo
#   alias :bar :foo
#
#   # good
#   alias bar foo
# @example EnforcedStyle: prefer_alias_method
#   # bad
#   alias :bar :foo
#   alias bar foo
#
#   # good
#   alias_method :bar, :foo
#
# source://rubocop//lib/rubocop/cop/style/alias.rb#31
class RuboCop::Cop::Style::Alias < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/alias.rb#150
  def identifier(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/alias.rb#51
  def on_alias(node); end

  # source://rubocop//lib/rubocop/cop/style/alias.rb#41
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/alias.rb#85
  def add_offense_for_args(node, &block); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/alias.rb#75
  def alias_keyword_possible?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/alias.rb#79
  def alias_method_possible?(node); end

  # source://rubocop//lib/rubocop/cop/style/alias.rb#65
  def autocorrect(corrector, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/alias.rb#124
  def bareword?(sym_node); end

  # source://rubocop//lib/rubocop/cop/style/alias.rb#128
  def correct_alias_method_to_alias(corrector, send_node); end

  # source://rubocop//lib/rubocop/cop/style/alias.rb#135
  def correct_alias_to_alias_method(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/alias.rb#144
  def correct_alias_with_symbol_args(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/alias.rb#113
  def lexical_scope_type(node); end

  # In this expression, will `self` be the same as the innermost enclosing
  # class or module block (:lexical)? Or will it be something else
  # (:dynamic)? If we're in an instance_eval block, return that.
  #
  # source://rubocop//lib/rubocop/cop/style/alias.rb#96
  def scope_type(node); end
end

# source://rubocop//lib/rubocop/cop/style/alias.rb#35
RuboCop::Cop::Style::Alias::MSG_ALIAS = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/alias.rb#36
RuboCop::Cop::Style::Alias::MSG_ALIAS_METHOD = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/alias.rb#37
RuboCop::Cop::Style::Alias::MSG_SYMBOL_ARGS = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/alias.rb#39
RuboCop::Cop::Style::Alias::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for uses of `and` and `or`, and suggests using `&&` and
# `||` instead. It can be configured to check only in conditions or in
# all contexts.
#
# @example EnforcedStyle: conditionals (default)
#   # bad
#   if foo and bar
#   end
#
#   # good
#   foo.save && return
#
#   # good
#   foo.save and return
#
#   # good
#   if foo && bar
#   end
# @example EnforcedStyle: always
#   # bad
#   foo.save and return
#
#   # bad
#   if foo and bar
#   end
#
#   # good
#   foo.save && return
#
#   # good
#   if foo && bar
#   end
#
# source://rubocop//lib/rubocop/cop/style/and_or.rb#44
class RuboCop::Cop::Style::AndOr < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/and_or.rb#51
  def on_and(node); end

  # source://rubocop//lib/rubocop/cop/style/and_or.rb#56
  def on_if(node); end

  # source://rubocop//lib/rubocop/cop/style/and_or.rb#51
  def on_or(node); end

  # source://rubocop//lib/rubocop/cop/style/and_or.rb#56
  def on_until(node); end

  # source://rubocop//lib/rubocop/cop/style/and_or.rb#56
  def on_until_post(node); end

  # source://rubocop//lib/rubocop/cop/style/and_or.rb#56
  def on_while(node); end

  # source://rubocop//lib/rubocop/cop/style/and_or.rb#56
  def on_while_post(node); end

  private

  # ! is a special case:
  # 'x and !obj.method arg' can be autocorrected if we
  # recurse down a level and add parens to 'obj.method arg'
  # however, 'not x' also parses as (send x :!)
  #
  # source://rubocop//lib/rubocop/cop/style/and_or.rb#117
  def correct_not(node, receiver, corrector); end

  # source://rubocop//lib/rubocop/cop/style/and_or.rb#129
  def correct_other(node, corrector); end

  # source://rubocop//lib/rubocop/cop/style/and_or.rb#95
  def correct_send(node, corrector); end

  # source://rubocop//lib/rubocop/cop/style/and_or.rb#108
  def correct_setter(node, corrector); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/and_or.rb#143
  def correctable_send?(node); end

  # source://rubocop//lib/rubocop/cop/style/and_or.rb#135
  def keep_operator_precedence(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/and_or.rb#91
  def message(node); end

  # source://rubocop//lib/rubocop/cop/style/and_or.rb#85
  def on_conditionals(node); end

  # source://rubocop//lib/rubocop/cop/style/and_or.rb#66
  def process_logical_operator(node); end

  # source://rubocop//lib/rubocop/cop/style/and_or.rb#147
  def whitespace_before_arg(node); end
end

# source://rubocop//lib/rubocop/cop/style/and_or.rb#49
RuboCop::Cop::Style::AndOr::MSG = T.let(T.unsafe(nil), String)

# In Ruby 2.7, arguments forwarding has been added.
#
# This cop identifies places where `do_something(*args, &block)`
# can be replaced by `do_something(...)`.
#
# @example
#   # bad
#   def foo(*args, &block)
#   bar(*args, &block)
#   end
#
#   # bad
#   def foo(*args, **kwargs, &block)
#   bar(*args, **kwargs, &block)
#   end
#
#   # good
#   def foo(...)
#   bar(...)
#   end
# @example AllowOnlyRestArgument: true (default)
#   # good
#   def foo(*args)
#   bar(*args)
#   end
#
#   def foo(**kwargs)
#   bar(**kwargs)
#   end
# @example AllowOnlyRestArgument: false
#   # bad
#   # The following code can replace the arguments with `...`,
#   # but it will change the behavior. Because `...` forwards block also.
#   def foo(*args)
#   bar(*args)
#   end
#
#   def foo(**kwargs)
#   bar(**kwargs)
#   end
#
# source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#49
class RuboCop::Cop::Style::ArgumentsForwarding < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#72
  def forwarding_method_arguments?(param0 = T.unsafe(nil), param1, param2, param3); end

  # source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#84
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#84
  def on_defs(node); end

  # source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#64
  def only_rest_arguments?(param0 = T.unsafe(nil), param1); end

  # source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#59
  def use_rest_arguments?(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#116
  def all_lvars_as_forwarding_method_arguments?(def_node, forwarding_method); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#149
  def allow_only_rest_arguments?; end

  # source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#143
  def arguments_range(node); end

  # source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#103
  def extract_argument_names_from(args); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#110
  def forwarding_method?(node, rest_arg, kwargs, block_arg); end

  # source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#125
  def register_offense_to_forwarding_method_arguments(forwarding_method); end

  # source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#134
  def register_offense_to_method_definition_arguments(method_definition); end
end

# source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#56
RuboCop::Cop::Style::ArgumentsForwarding::MSG = T.let(T.unsafe(nil), String)

# Enforces the use of `Array()` instead of explicit `Array` check or `[*var]`.
#
# The cop is disabled by default due to safety concerns.
#
# @example
#   # bad
#   paths = [paths] unless paths.is_a?(Array)
#   paths.each { |path| do_something(path) }
#
#   # bad (always creates a new Array instance)
#   [*paths].each { |path| do_something(path) }
#
#   # good (and a bit more readable)
#   Array(paths).each { |path| do_something(path) }
#
# source://rubocop//lib/rubocop/cop/style/array_coercion.rb#41
class RuboCop::Cop::Style::ArrayCoercion < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/array_coercion.rb#48
  def array_splat?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/array_coercion.rb#63
  def on_array(node); end

  # source://rubocop//lib/rubocop/cop/style/array_coercion.rb#74
  def on_if(node); end

  # source://rubocop//lib/rubocop/cop/style/array_coercion.rb#53
  def unless_array?(param0 = T.unsafe(nil)); end
end

# source://rubocop//lib/rubocop/cop/style/array_coercion.rb#45
RuboCop::Cop::Style::ArrayCoercion::CHECK_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/array_coercion.rb#44
RuboCop::Cop::Style::ArrayCoercion::SPLAT_MSG = T.let(T.unsafe(nil), String)

# In Ruby 3.1, `Array#intersect?` has been added.
#
# This cop identifies places where `(array1 & array2).any?`
# can be replaced by `array1.intersect?(array2)`.
#
# The `array1.intersect?(array2)` method is faster than
# `(array1 & array2).any?` and is more readable.
#
# @example
#   # bad
#   (array1 & array2).any?
#   (array1 & array2).empty?
#
#   # good
#   array1.intersect?(array2)
#   !array1.intersect?(array2)
# @example AllCops:ActiveSupportExtensionsEnabled: false (default)
#   # good
#   (array1 & array2).present?
#   (array1 & array2).blank?
# @example AllCops:ActiveSupportExtensionsEnabled: true
#   # bad
#   (array1 & array2).present?
#   (array1 & array2).blank?
#
#   # good
#   array1.intersect?(array2)
#   !array1.intersect?(array2)
#
# source://rubocop//lib/rubocop/cop/style/array_intersect.rb#40
class RuboCop::Cop::Style::ArrayIntersect < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop//lib/rubocop/cop/style/array_intersect.rb#56
  def active_support_bad_intersection_check?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/array_intersect.rb#70
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/style/array_intersect.rb#47
  def regular_bad_intersection_check?(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/array_intersect.rb#86
  def bad_intersection_check?(node); end

  # source://rubocop//lib/rubocop/cop/style/array_intersect.rb#98
  def message(receiver, argument, method_name); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/array_intersect.rb#94
  def straight?(method_name); end
end

# source://rubocop//lib/rubocop/cop/style/array_intersect.rb#64
RuboCop::Cop::Style::ArrayIntersect::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/array_intersect.rb#67
RuboCop::Cop::Style::ArrayIntersect::NEGATED_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/array_intersect.rb#68
RuboCop::Cop::Style::ArrayIntersect::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/array_intersect.rb#66
RuboCop::Cop::Style::ArrayIntersect::STRAIGHT_METHODS = T.let(T.unsafe(nil), Array)

# Checks for uses of "*" as a substitute for _join_.
#
# Not all cases can reliably checked, due to Ruby's dynamic
# types, so we consider only cases when the first argument is an
# array literal or the second is a string literal.
#
# @example
#
#   # bad
#   %w(foo bar baz) * ","
#
#   # good
#   %w(foo bar baz).join(",")
#
# source://rubocop//lib/rubocop/cop/style/array_join.rb#20
class RuboCop::Cop::Style::ArrayJoin < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/array_join.rb#27
  def join_candidate?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/array_join.rb#29
  def on_send(node); end
end

# source://rubocop//lib/rubocop/cop/style/array_join.rb#23
RuboCop::Cop::Style::ArrayJoin::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/array_join.rb#24
RuboCop::Cop::Style::ArrayJoin::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/ascii_comments.rb#16
class RuboCop::Cop::Style::AsciiComments < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/style/ascii_comments.rb#21
  def on_new_investigation; end

  private

  # source://rubocop//lib/rubocop/cop/style/ascii_comments.rb#51
  def allowed_non_ascii_chars; end

  # source://rubocop//lib/rubocop/cop/style/ascii_comments.rb#42
  def first_non_ascii_chars(string); end

  # source://rubocop//lib/rubocop/cop/style/ascii_comments.rb#32
  def first_offense_range(comment); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/ascii_comments.rb#46
  def only_allowed_non_ascii_chars?(string); end
end

# source://rubocop//lib/rubocop/cop/style/ascii_comments.rb#19
RuboCop::Cop::Style::AsciiComments::MSG = T.let(T.unsafe(nil), String)

# Checks for uses of Module#attr.
#
# @example
#   # bad - creates a single attribute accessor (deprecated in Ruby 1.9)
#   attr :something, true
#   attr :one, :two, :three # behaves as attr_reader
#
#   # good
#   attr_accessor :something
#   attr_reader :one, :two, :three
#
# source://rubocop//lib/rubocop/cop/style/attr.rb#17
class RuboCop::Cop::Style::Attr < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/attr.rb#64
  def class_eval?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/attr.rb#24
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/attr.rb#37
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/attr.rb#49
  def message(node); end

  # source://rubocop//lib/rubocop/cop/style/attr.rb#53
  def replacement_method(node); end
end

# source://rubocop//lib/rubocop/cop/style/attr.rb#21
RuboCop::Cop::Style::Attr::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/attr.rb#22
RuboCop::Cop::Style::Attr::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for cases when you could use a block
# accepting version of a method that does automatic
# resource cleanup.
#
# @example
#
#   # bad
#   f = File.open('file')
#
#   # good
#   File.open('file') do |f|
#   # ...
#   end
#
# source://rubocop//lib/rubocop/cop/style/auto_resource_cleanup.rb#19
class RuboCop::Cop::Style::AutoResourceCleanup < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/style/auto_resource_cleanup.rb#26
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/auto_resource_cleanup.rb#41
  def cleanup?(node); end
end

# source://rubocop//lib/rubocop/cop/style/auto_resource_cleanup.rb#20
RuboCop::Cop::Style::AutoResourceCleanup::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/auto_resource_cleanup.rb#24
RuboCop::Cop::Style::AutoResourceCleanup::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/auto_resource_cleanup.rb#22
RuboCop::Cop::Style::AutoResourceCleanup::TARGET_METHODS = T.let(T.unsafe(nil), Hash)

# Checks if usage of %() or %Q() matches configuration.
#
# @example EnforcedStyle: bare_percent (default)
#   # bad
#   %Q(He said: "#{greeting}")
#   %q{She said: 'Hi'}
#
#   # good
#   %(He said: "#{greeting}")
#   %{She said: 'Hi'}
# @example EnforcedStyle: percent_q
#   # bad
#   %|He said: "#{greeting}"|
#   %/She said: 'Hi'/
#
#   # good
#   %Q|He said: "#{greeting}"|
#   %q/She said: 'Hi'/
#
# source://rubocop//lib/rubocop/cop/style/bare_percent_literals.rb#26
class RuboCop::Cop::Style::BarePercentLiterals < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/bare_percent_literals.rb#32
  def on_dstr(node); end

  # source://rubocop//lib/rubocop/cop/style/bare_percent_literals.rb#36
  def on_str(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/bare_percent_literals.rb#63
  def add_offense_for_wrong_style(node, good, bad); end

  # source://rubocop//lib/rubocop/cop/style/bare_percent_literals.rb#42
  def check(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/bare_percent_literals.rb#59
  def requires_bare_percent?(source); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/bare_percent_literals.rb#55
  def requires_percent_q?(source); end
end

# source://rubocop//lib/rubocop/cop/style/bare_percent_literals.rb#30
RuboCop::Cop::Style::BarePercentLiterals::MSG = T.let(T.unsafe(nil), String)

# This cop checks for BEGIN blocks.
#
# @example
#   # bad
#   BEGIN { test }
#
# source://rubocop//lib/rubocop/cop/style/begin_block.rb#13
class RuboCop::Cop::Style::BeginBlock < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/style/begin_block.rb#16
  def on_preexe(node); end
end

# source://rubocop//lib/rubocop/cop/style/begin_block.rb#14
RuboCop::Cop::Style::BeginBlock::MSG = T.let(T.unsafe(nil), String)

# Checks for places where `attr_reader` and `attr_writer`
# for the same method can be combined into single `attr_accessor`.
#
# @example
#   # bad
#   class Foo
#   attr_reader :bar
#   attr_writer :bar
#   end
#
#   # good
#   class Foo
#   attr_accessor :bar
#   end
#
# source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor.rb#21
class RuboCop::Cop::Style::BisectedAttrAccessor < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # Each offending macro is captured and registered in `on_class` but correction
  # happens in `after_class` because a macro might have multiple attributes
  # rewritten from it
  #
  # source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor.rb#55
  def after_class(class_node); end

  # Each offending macro is captured and registered in `on_class` but correction
  # happens in `after_class` because a macro might have multiple attributes
  # rewritten from it
  #
  # source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor.rb#55
  def after_module(class_node); end

  # Each offending macro is captured and registered in `on_class` but correction
  # happens in `after_class` because a macro might have multiple attributes
  # rewritten from it
  #
  # source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor.rb#55
  def after_sclass(class_node); end

  # source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor.rb#33
  def on_class(class_node); end

  # source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor.rb#33
  def on_module(class_node); end

  # source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor.rb#29
  def on_new_investigation; end

  # source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor.rb#33
  def on_sclass(class_node); end

  private

  # source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor.rb#102
  def correct_reader(corrector, macro, node, range); end

  # source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor.rb#114
  def correct_writer(corrector, macro, node, range); end

  # source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor.rb#91
  def find_bisection(macros); end

  # source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor.rb#74
  def find_macros(class_def); end

  # source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor.rb#98
  def register_offense(attr); end
end

# source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor.rb#27
RuboCop::Cop::Style::BisectedAttrAccessor::MSG = T.let(T.unsafe(nil), String)

# Representation of an `attr_reader`, `attr_writer` or `attr` macro
# for use by `Style/BisectedAttrAccessor`.
#
# @api private
#
# source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor/macro.rb#10
class RuboCop::Cop::Style::BisectedAttrAccessor::Macro
  include ::RuboCop::Cop::VisibilityHelp

  # @api private
  # @return [Macro] a new instance of Macro
  #
  # source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor/macro.rb#19
  def initialize(node); end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor/macro.rb#49
  def all_bisected?; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor/macro.rb#29
  def attr_names; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor/macro.rb#13
  def attrs; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor/macro.rb#25
  def bisect(*names); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor/macro.rb#33
  def bisected_names; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor/macro.rb#13
  def bisection; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor/macro.rb#13
  def node; end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor/macro.rb#41
  def reader?; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor/macro.rb#53
  def rest; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor/macro.rb#37
  def visibility; end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor/macro.rb#45
  def writer?; end

  class << self
    # @api private
    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor/macro.rb#15
    def macro?(node); end
  end
end

# Looks for uses of block comments (=begin...=end).
#
# @example
#   # bad
#   =begin
#   Multiple lines
#   of comments...
#   =end
#
#   # good
#   # Multiple lines
#   # of comments...
#
# source://rubocop//lib/rubocop/cop/style/block_comments.rb#19
class RuboCop::Cop::Style::BlockComments < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/block_comments.rb#27
  def on_new_investigation; end

  private

  # source://rubocop//lib/rubocop/cop/style/block_comments.rb#56
  def eq_end_part(comment, expr); end

  # source://rubocop//lib/rubocop/cop/style/block_comments.rb#48
  def parts(comment); end
end

# source://rubocop//lib/rubocop/cop/style/block_comments.rb#24
RuboCop::Cop::Style::BlockComments::BEGIN_LENGTH = T.let(T.unsafe(nil), Integer)

# source://rubocop//lib/rubocop/cop/style/block_comments.rb#25
RuboCop::Cop::Style::BlockComments::END_LENGTH = T.let(T.unsafe(nil), Integer)

# source://rubocop//lib/rubocop/cop/style/block_comments.rb#23
RuboCop::Cop::Style::BlockComments::MSG = T.let(T.unsafe(nil), String)

# Check for uses of braces or do/end around single line or
# multi-line blocks.
#
# Methods that can be either procedural or functional and cannot be
# categorised from their usage alone is ignored.
# `lambda`, `proc`, and `it` are their defaults.
# Additional methods can be added to the `AllowedMethods`.
#
# @example AllowedPatterns: ['map']
#
#   # good
#   things.map { |thing|
#   something = thing.some_method
#   process(something)
#   }
# @example EnforcedStyle: semantic
#   # Prefer `do...end` over `{...}` for procedural blocks.
#
#   # return value is used/assigned
#   # bad
#   foo = map do |x|
#   x
#   end
#   puts (map do |x|
#   x
#   end)
#
#   # return value is not used out of scope
#   # good
#   map do |x|
#   x
#   end
#
#   # Prefer `{...}` over `do...end` for functional blocks.
#
#   # return value is not used out of scope
#   # bad
#   each { |x|
#   x
#   }
#
#   # return value is used/assigned
#   # good
#   foo = map { |x|
#   x
#   }
#   map { |x|
#   x
#   }.inspect
#
#   # The AllowBracesOnProceduralOneLiners option is allowed unless the
#   # EnforcedStyle is set to `semantic`. If so:
#
#   # If the AllowBracesOnProceduralOneLiners option is unspecified, or
#   # set to `false` or any other falsey value, then semantic purity is
#   # maintained, so one-line procedural blocks must use do-end, not
#   # braces.
#
#   # bad
#   collection.each { |element| puts element }
#
#   # good
#   collection.each do |element| puts element end
#
#   # If the AllowBracesOnProceduralOneLiners option is set to `true`, or
#   # any other truthy value, then one-line procedural blocks may use
#   # either style. (There is no setting for requiring braces on them.)
#
#   # good
#   collection.each { |element| puts element }
#
#   # also good
#   collection.each do |element| puts element end
# @example EnforcedStyle: braces_for_chaining
#   # bad
#   words.each do |word|
#   word.flip.flop
#   end.join("-")
#
#   # good
#   words.each { |word|
#   word.flip.flop
#   }.join("-")
# @example EnforcedStyle: always_braces
#   # bad
#   words.each do |word|
#   word.flip.flop
#   end
#
#   # good
#   words.each { |word|
#   word.flip.flop
#   }
# @example BracesRequiredMethods: ['sig']
#
#   # Methods listed in the BracesRequiredMethods list, such as 'sig'
#   # in this example, will require `{...}` braces. This option takes
#   # precedence over all other configurations except AllowedMethods.
#
#   # bad
#   sig do
#   params(
#   foo: string,
#   ).void
#   end
#   def bar(foo)
#   puts foo
#   end
#
#   # good
#   sig {
#   params(
#   foo: string,
#   ).void
#   }
#   def bar(foo)
#   puts foo
#   end
# @example AllowedMethods: ['lambda', 'proc', 'it' ] (default)
#
#   # good
#   foo = lambda do |x|
#   puts "Hello, #{x}"
#   end
#
#   foo = lambda do |x|
#   x * 100
#   end
# @example AllowedPatterns: [] (default)
#
#   # bad
#   things.map { |thing|
#   something = thing.some_method
#   process(something)
#   }
# @example EnforcedStyle: line_count_based (default)
#   # bad - single line block
#   items.each do |item| item / 5 end
#
#   # good - single line block
#   items.each { |item| item / 5 }
#
#   # bad - multi-line block
#   things.map { |thing|
#   something = thing.some_method
#   process(something)
#   }
#
#   # good - multi-line block
#   things.map do |thing|
#   something = thing.some_method
#   process(something)
#   end
#
# source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#168
class RuboCop::Cop::Style::BlockDelimiters < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::AllowedPattern
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#194
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#194
  def on_numblock(node); end

  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#179
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#458
  def array_or_range?(node); end

  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#208
  def autocorrect(corrector, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#462
  def begin_required?(block_node); end

  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#236
  def braces_for_chaining_message(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#399
  def braces_for_chaining_style?(node); end

  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#248
  def braces_required_message(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#376
  def braces_required_method?(method_name); end

  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#380
  def braces_required_methods; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#409
  def braces_style?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#454
  def conditional?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#413
  def correction_would_break_code?(node); end

  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#309
  def end_of_chain(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#423
  def functional_block?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#419
  def functional_method?(method_name); end

  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#326
  def get_blocks(node, &block); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#384
  def line_count_based_block_style?(node); end

  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#218
  def line_count_based_message(node); end

  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#252
  def message(node); end

  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#300
  def move_comment_before_block(corrector, comment, block_node, closing_brace); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#431
  def procedural_method?(method_name); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#427
  def procedural_oneliners_may_have_braces?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#344
  def proper_block_style?(node); end

  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#316
  def remove_trailing_whitespace(corrector, range, comment); end

  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#263
  def replace_braces_with_do_end(corrector, loc); end

  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#279
  def replace_do_end_with_braces(corrector, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#356
  def require_braces?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#447
  def return_value_of_scope?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#435
  def return_value_used?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#388
  def semantic_block_style?(node); end

  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#226
  def semantic_message(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#364
  def special_method?(method_name); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#370
  def special_method_proper_block_style?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#296
  def whitespace_after?(range, length = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#292
  def whitespace_before?(range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#322
  def with_block?(node); end
end

# source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#175
RuboCop::Cop::Style::BlockDelimiters::ALWAYS_BRACES_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#177
RuboCop::Cop::Style::BlockDelimiters::BRACES_REQUIRED_MESSAGE = T.let(T.unsafe(nil), String)

# Corrector to correct conditional assignment in `case` statements.
#
# source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#603
class RuboCop::Cop::Style::CaseCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper

  class << self
    # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#608
    def correct(corrector, cop, node); end

    # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#618
    def move_assignment_inside_condition(corrector, node); end

    private

    # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#638
    def extract_branches(case_node); end

    # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#632
    def extract_tail_branches(node); end

    # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#648
    def move_branch_inside_condition(corrector, branch, condition, assignment, column); end
  end
end

# If `AllowOnSelfClass` option is enabled, the cop will ignore violations when the receiver of
# the case equality operator is `self.class`. Note intermediate variables are not accepted.
#
# @example
#   # bad
#   (1..100) === 7
#   /something/ === some_string
#
#   # good
#   something.is_a?(Array)
#   (1..100).include?(7)
#   /something/.match?(some_string)
# @example AllowOnConstant: false (default)
#   # bad
#   Array === something
# @example AllowOnConstant: true
#   # good
#   Array === something
# @example AllowOnSelfClass: false (default)
#   # bad
#   self.class === something
# @example AllowOnSelfClass: true
#   # good
#   self.class === something
#
# source://rubocop//lib/rubocop/cop/style/case_equality.rb#40
class RuboCop::Cop::Style::CaseEquality < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/case_equality.rb#47
  def case_equality?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/case_equality.rb#52
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/style/case_equality.rb#50
  def self_class?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/style/case_equality.rb#90
  def begin_replacement(lhs, rhs); end

  # source://rubocop//lib/rubocop/cop/style/case_equality.rb#96
  def const_replacement(lhs, rhs); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/case_equality.rb#65
  def offending_receiver?(node); end

  # source://rubocop//lib/rubocop/cop/style/case_equality.rb#72
  def replacement(lhs, rhs); end

  # source://rubocop//lib/rubocop/cop/style/case_equality.rb#100
  def send_replacement(lhs, rhs); end
end

# source://rubocop//lib/rubocop/cop/style/case_equality.rb#43
RuboCop::Cop::Style::CaseEquality::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/case_equality.rb#44
RuboCop::Cop::Style::CaseEquality::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Identifies places where `if-elsif` constructions
# can be replaced with `case-when`.
#
# @example MinBranchesCount: 3 (default)
#   # bad
#   if status == :active
#   perform_action
#   elsif status == :inactive || status == :hibernating
#   check_timeout
#   elsif status == :invalid
#   report_invalid
#   else
#   final_action
#   end
#
#   # good
#   case status
#   when :active
#   perform_action
#   when :inactive, :hibernating
#   check_timeout
#   when :invalid
#   report_invalid
#   else
#   final_action
#   end
# @example MinBranchesCount: 4
#   # good
#   if status == :active
#   perform_action
#   elsif status == :inactive || status == :hibernating
#   check_timeout
#   elsif status == :invalid
#   report_invalid
#   else
#   final_action
#   end
#
# source://rubocop//lib/rubocop/cop/style/case_like_if.rb#50
class RuboCop::Cop::Style::CaseLikeIf < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::MinBranchesCount
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/case_like_if.rb#57
  def on_if(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/case_like_if.rb#81
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/case_like_if.rb#231
  def branch_conditions(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/case_like_if.rb#249
  def class_reference?(node); end

  # source://rubocop//lib/rubocop/cop/style/case_like_if.rb#166
  def collect_conditions(node, target, conditions); end

  # source://rubocop//lib/rubocop/cop/style/case_like_if.rb#220
  def condition_from_binary_op(lhs, rhs, target); end

  # source://rubocop//lib/rubocop/cop/style/case_like_if.rb#202
  def condition_from_equality_node(node, target); end

  # source://rubocop//lib/rubocop/cop/style/case_like_if.rb#213
  def condition_from_include_or_cover_node(node, target); end

  # source://rubocop//lib/rubocop/cop/style/case_like_if.rb#208
  def condition_from_match_node(node, target); end

  # source://rubocop//lib/rubocop/cop/style/case_like_if.rb#185
  def condition_from_send_node(node, target); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/case_like_if.rb#240
  def const_reference?(node); end

  # source://rubocop//lib/rubocop/cop/style/case_like_if.rb#258
  def correction_range(node); end

  # source://rubocop//lib/rubocop/cop/style/case_like_if.rb#253
  def deparenthesize(node); end

  # source://rubocop//lib/rubocop/cop/style/case_like_if.rb#102
  def find_target(node); end

  # source://rubocop//lib/rubocop/cop/style/case_like_if.rb#136
  def find_target_in_equality_node(node); end

  # source://rubocop//lib/rubocop/cop/style/case_like_if.rb#148
  def find_target_in_include_or_cover_node(node); end

  # source://rubocop//lib/rubocop/cop/style/case_like_if.rb#154
  def find_target_in_match_node(node); end

  # source://rubocop//lib/rubocop/cop/style/case_like_if.rb#121
  def find_target_in_send_node(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/case_like_if.rb#274
  def regexp_with_named_captures?(node); end

  # Named captures work with `=~` (if regexp is on lhs) and with `match` (both sides)
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/case_like_if.rb#263
  def regexp_with_working_captures?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/case_like_if.rb#96
  def should_check?(node); end
end

# source://rubocop//lib/rubocop/cop/style/case_like_if.rb#55
RuboCop::Cop::Style::CaseLikeIf::MSG = T.let(T.unsafe(nil), String)

# Checks for uses of the character literal ?x.
# Starting with Ruby 1.9 character literals are
# essentially one-character strings, so this syntax
# is mostly redundant at this point.
#
# ? character literal can be used to express meta and control character.
# That's a good use case of ? literal so it doesn't count it as an offense.
#
# @example
#   # bad
#   ?x
#
#   # good
#   'x'
#
#   # good - control & meta escapes
#   ?\C-\M-d
#   "\C-\M-d" # same as above
#
# source://rubocop//lib/rubocop/cop/style/character_literal.rb#24
class RuboCop::Cop::Style::CharacterLiteral < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::StringHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/character_literal.rb#35
  def autocorrect(corrector, node); end

  # Dummy implementation of method in ConfigurableEnforcedStyle that is
  # called from StringHelp.
  #
  # source://rubocop//lib/rubocop/cop/style/character_literal.rb#53
  def correct_style_detected; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/character_literal.rb#30
  def offense?(node); end

  # Dummy implementation of method in ConfigurableEnforcedStyle that is
  # called from StringHelp.
  #
  # source://rubocop//lib/rubocop/cop/style/character_literal.rb#49
  def opposite_style_detected; end
end

# source://rubocop//lib/rubocop/cop/style/character_literal.rb#28
RuboCop::Cop::Style::CharacterLiteral::MSG = T.let(T.unsafe(nil), String)

# Checks the style of children definitions at classes and
# modules. Basically there are two different styles:
#
# The compact style is only forced for classes/modules with one child.
#
# @example EnforcedStyle: nested (default)
#   # good
#   # have each child on its own line
#   class Foo
#   class Bar
#   end
#   end
# @example EnforcedStyle: compact
#   # good
#   # combine definitions as much as possible
#   class Foo::Bar
#   end
#
# source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#33
class RuboCop::Cop::Style::ClassAndModuleChildren < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#42
  def on_class(node); end

  # source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#48
  def on_module(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#89
  def add_trailing_end(corrector, node, padding); end

  # source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#170
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#159
  def check_compact_style(node, body); end

  # source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#151
  def check_nested_style(node); end

  # source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#141
  def check_style(node, body); end

  # source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#94
  def compact_definition(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#115
  def compact_identifier_name(node); end

  # source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#100
  def compact_node(corrector, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#180
  def compact_node_name?(node); end

  # source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#105
  def compact_replacement(node); end

  # source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#137
  def leading_spaces(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#176
  def needs_compacting?(body); end

  # source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#62
  def nest_definition(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#54
  def nest_or_compact(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#120
  def remove_end(corrector, body); end

  # source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#71
  def replace_namespace_keyword(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#80
  def split_on_double_colon(corrector, node, padding); end

  # source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#128
  def unindent(corrector, node); end
end

# source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#40
RuboCop::Cop::Style::ClassAndModuleChildren::COMPACT_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#39
RuboCop::Cop::Style::ClassAndModuleChildren::NESTED_MSG = T.let(T.unsafe(nil), String)

# Enforces consistent use of `Object#is_a?` or `Object#kind_of?`.
#
# @example EnforcedStyle: is_a? (default)
#   # bad
#   var.kind_of?(Date)
#   var.kind_of?(Integer)
#
#   # good
#   var.is_a?(Date)
#   var.is_a?(Integer)
# @example EnforcedStyle: kind_of?
#   # bad
#   var.is_a?(Time)
#   var.is_a?(String)
#
#   # good
#   var.kind_of?(Time)
#   var.kind_of?(String)
#
# source://rubocop//lib/rubocop/cop/style/class_check.rb#26
class RuboCop::Cop::Style::ClassCheck < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/class_check.rb#44
  def message(node); end

  # source://rubocop//lib/rubocop/cop/style/class_check.rb#33
  def on_send(node); end
end

# source://rubocop//lib/rubocop/cop/style/class_check.rb#30
RuboCop::Cop::Style::ClassCheck::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/class_check.rb#31
RuboCop::Cop::Style::ClassCheck::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Enforces the use of `Object#instance_of?` instead of class comparison
# for equality.
# `==`, `equal?`, and `eql?` methods are allowed by default.
# These are customizable with `AllowedMethods` option.
#
# @example
#   # bad
#   var.class == Date
#   var.class.equal?(Date)
#   var.class.eql?(Date)
#   var.class.name == 'Date'
#
#   # good
#   var.instance_of?(Date)
# @example AllowedMethods: [] (default)
#   # good
#   var.instance_of?(Date)
#
#   # bad
#   var.class == Date
#   var.class.equal?(Date)
#   var.class.eql?(Date)
#   var.class.name == 'Date'
#   var.class.to_s == 'Date'
#   var.class.inspect == 'Date'
# @example AllowedMethods: [`==`]
#   # good
#   var.instance_of?(Date)
#   var.class == Date
#   var.class.name == 'Date'
#   var.class.to_s == 'Date'
#   var.class.inspect == 'Date'
#
#   # bad
#   var.class.equal?(Date)
#   var.class.eql?(Date)
# @example AllowedPatterns: [] (default)
#   # good
#   var.instance_of?(Date)
#
#   # bad
#   var.class == Date
#   var.class.equal?(Date)
#   var.class.eql?(Date)
#   var.class.name == 'Date'
#   var.class.to_s == 'Date'
#   var.class.inspect == 'Date'
# @example AllowedPatterns: ['eq']
#   # good
#   var.instance_of?(Date)
#   var.class.equal?(Date)
#   var.class.eql?(Date)
#
#   # bad
#   var.class == Date
#   var.class.name == 'Date'
#   var.class.to_s == 'Date'
#   var.class.inspect == 'Date'
#
# source://rubocop//lib/rubocop/cop/style/class_equality_comparison.rb#69
class RuboCop::Cop::Style::ClassEqualityComparison < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::AllowedPattern
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/class_equality_comparison.rb#81
  def class_comparison_candidate?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/class_equality_comparison.rb#87
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/class_equality_comparison.rb#105
  def class_name(class_node, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/class_equality_comparison.rb#119
  def class_name_method?(method_name); end

  # source://rubocop//lib/rubocop/cop/style/class_equality_comparison.rb#123
  def offense_range(receiver_node, node); end
end

# source://rubocop//lib/rubocop/cop/style/class_equality_comparison.rb#78
RuboCop::Cop::Style::ClassEqualityComparison::CLASS_NAME_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/class_equality_comparison.rb#75
RuboCop::Cop::Style::ClassEqualityComparison::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/class_equality_comparison.rb#77
RuboCop::Cop::Style::ClassEqualityComparison::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for uses of the class/module name instead of
# self, when defining class/module methods.
#
# @example
#   # bad
#   class SomeClass
#   def SomeClass.class_method
#   # ...
#   end
#   end
#
#   # good
#   class SomeClass
#   def self.class_method
#   # ...
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/style/class_methods.rb#23
class RuboCop::Cop::Style::ClassMethods < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/class_methods.rb#28
  def on_class(node); end

  # source://rubocop//lib/rubocop/cop/style/class_methods.rb#28
  def on_module(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/class_methods.rb#41
  def check_defs(name, node); end
end

# source://rubocop//lib/rubocop/cop/style/class_methods.rb#26
RuboCop::Cop::Style::ClassMethods::MSG = T.let(T.unsafe(nil), String)

# Enforces using `def self.method_name` or `class << self` to define class methods.
#
# @example EnforcedStyle: def_self (default)
#   # bad
#   class SomeClass
#   class << self
#   attr_accessor :class_accessor
#
#   def class_method
#   # ...
#   end
#   end
#   end
#
#   # good
#   class SomeClass
#   def self.class_method
#   # ...
#   end
#
#   class << self
#   attr_accessor :class_accessor
#   end
#   end
#
#   # good - contains private method
#   class SomeClass
#   class << self
#   attr_accessor :class_accessor
#
#   private
#
#   def private_class_method
#   # ...
#   end
#   end
#   end
# @example EnforcedStyle: self_class
#   # bad
#   class SomeClass
#   def self.class_method
#   # ...
#   end
#   end
#
#   # good
#   class SomeClass
#   class << self
#   def class_method
#   # ...
#   end
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/style/class_methods_definitions.rb#61
class RuboCop::Cop::Style::ClassMethodsDefinitions < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::CommentsHelp
  include ::RuboCop::Cop::VisibilityHelp
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/class_methods_definitions.rb#81
  def on_defs(node); end

  # source://rubocop//lib/rubocop/cop/style/class_methods_definitions.rb#71
  def on_sclass(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/class_methods_definitions.rb#95
  def all_methods_public?(sclass_node); end

  # source://rubocop//lib/rubocop/cop/style/class_methods_definitions.rb#115
  def autocorrect_sclass(node, corrector); end

  # source://rubocop//lib/rubocop/cop/style/class_methods_definitions.rb#102
  def def_nodes(sclass_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/class_methods_definitions.rb#91
  def def_self_style?; end

  # source://rubocop//lib/rubocop/cop/style/class_methods_definitions.rb#141
  def extract_def_from_sclass(def_node, sclass_node); end

  # source://rubocop//lib/rubocop/cop/style/class_methods_definitions.rb#152
  def indentation_diff(node1, node2); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/class_methods_definitions.rb#137
  def sclass_only_has_methods?(node); end
end

# source://rubocop//lib/rubocop/cop/style/class_methods_definitions.rb#68
RuboCop::Cop::Style::ClassMethodsDefinitions::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/class_methods_definitions.rb#69
RuboCop::Cop::Style::ClassMethodsDefinitions::MSG_SCLASS = T.let(T.unsafe(nil), String)

# Checks for uses of class variables. Offenses
# are signaled only on assignment to class variables to
# reduce the number of offenses that would be reported.
#
# You have to be careful when setting a value for a class
# variable; if a class has been inherited, changing the
# value of a class variable also affects the inheriting
# classes. This means that it's almost always better to
# use a class instance variable instead.
#
# @example
#   # bad
#   class A
#   @@test = 10
#   end
#
#   class A
#   def self.test(name, value)
#   class_variable_set("@@#{name}", value)
#   end
#   end
#
#   class A; end
#   A.class_variable_set(:@@test, 10)
#
#   # good
#   class A
#   @test = 10
#   end
#
#   class A
#   def test
#   @@test # you can access class variable without offense
#   end
#   end
#
#   class A
#   def self.test(name)
#   class_variable_get("@@#{name}") # you can access without offense
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/style/class_vars.rb#48
class RuboCop::Cop::Style::ClassVars < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/style/class_vars.rb#52
  def on_cvasgn(node); end

  # source://rubocop//lib/rubocop/cop/style/class_vars.rb#56
  def on_send(node); end
end

# source://rubocop//lib/rubocop/cop/style/class_vars.rb#49
RuboCop::Cop::Style::ClassVars::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/class_vars.rb#50
RuboCop::Cop::Style::ClassVars::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for places where custom logic on rejection nils from arrays
# and hashes can be replaced with `{Array,Hash}#{compact,compact!}`.
#
# @example
#   # bad
#   array.reject(&:nil?)
#   array.reject { |e| e.nil? }
#   array.select { |e| !e.nil? }
#
#   # good
#   array.compact
#
#   # bad
#   hash.reject!(&:nil?)
#   hash.reject! { |k, v| v.nil? }
#   hash.select! { |k, v| !v.nil? }
#
#   # good
#   hash.compact!
#
# source://rubocop//lib/rubocop/cop/style/collection_compact.rb#36
class RuboCop::Cop::Style::CollectionCompact < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/collection_compact.rb#72
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/style/collection_compact.rb#52
  def reject_method?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/collection_compact.rb#45
  def reject_method_with_block_pass?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/collection_compact.rb#62
  def select_method?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/style/collection_compact.rb#106
  def good_method_name(node); end

  # source://rubocop//lib/rubocop/cop/style/collection_compact.rb#84
  def offense_range(node); end

  # source://rubocop//lib/rubocop/cop/style/collection_compact.rb#114
  def range(begin_pos_node, end_pos_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/collection_compact.rb#100
  def to_enum_method?(node); end
end

# source://rubocop//lib/rubocop/cop/style/collection_compact.rb#40
RuboCop::Cop::Style::CollectionCompact::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/collection_compact.rb#41
RuboCop::Cop::Style::CollectionCompact::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/collection_compact.rb#42
RuboCop::Cop::Style::CollectionCompact::TO_ENUM_METHODS = T.let(T.unsafe(nil), Array)

# Enforces the use of consistent method names
# from the Enumerable module.
#
# You can customize the mapping from undesired method to desired method.
#
# e.g. to use `detect` over `find`:
#
#   Style/CollectionMethods:
#     PreferredMethods:
#       find: detect
#
# @example
#   # These examples are based on the default mapping for `PreferredMethods`.
#
#   # bad
#   items.collect
#   items.collect!
#   items.inject
#   items.detect
#   items.find_all
#   items.member?
#
#   # good
#   items.map
#   items.map!
#   items.reduce
#   items.find
#   items.select
#   items.include?
#
# source://rubocop//lib/rubocop/cop/style/collection_methods.rb#41
class RuboCop::Cop::Style::CollectionMethods < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::MethodPreference
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/collection_methods.rb#47
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/style/collection_methods.rb#47
  def on_numblock(node); end

  # source://rubocop//lib/rubocop/cop/style/collection_methods.rb#53
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/collection_methods.rb#61
  def check_method_node(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/collection_methods.rb#70
  def implicit_block?(node); end

  # source://rubocop//lib/rubocop/cop/style/collection_methods.rb#78
  def message(node); end

  # Some enumerable methods accept a bare symbol (ie. _not_ Symbol#to_proc) instead
  # of a block.
  #
  # source://rubocop//lib/rubocop/cop/style/collection_methods.rb#84
  def methods_accepting_symbol; end
end

# source://rubocop//lib/rubocop/cop/style/collection_methods.rb#45
RuboCop::Cop::Style::CollectionMethods::MSG = T.let(T.unsafe(nil), String)

# Checks for methods invoked via the :: operator instead
# of the . operator (like FileUtils::rmdir instead of FileUtils.rmdir).
#
# @example
#   # bad
#   Timeout::timeout(500) { do_something }
#   FileUtils::rmdir(dir)
#   Marshal::dump(obj)
#
#   # good
#   Timeout.timeout(500) { do_something }
#   FileUtils.rmdir(dir)
#   Marshal.dump(obj)
#
# source://rubocop//lib/rubocop/cop/style/colon_method_call.rb#20
class RuboCop::Cop::Style::ColonMethodCall < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/colon_method_call.rb#26
  def java_type_node?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/colon_method_call.rb#35
  def on_send(node); end

  class << self
    # source://rubocop//lib/rubocop/cop/style/colon_method_call.rb#31
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop//lib/rubocop/cop/style/colon_method_call.rb#23
RuboCop::Cop::Style::ColonMethodCall::MSG = T.let(T.unsafe(nil), String)

# Checks for class methods that are defined using the `::`
# operator instead of the `.` operator.
#
# @example
#   # bad
#   class Foo
#   def self::bar
#   end
#   end
#
#   # good
#   class Foo
#   def self.bar
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/style/colon_method_definition.rb#22
class RuboCop::Cop::Style::ColonMethodDefinition < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/colon_method_definition.rb#27
  def on_defs(node); end
end

# source://rubocop//lib/rubocop/cop/style/colon_method_definition.rb#25
RuboCop::Cop::Style::ColonMethodDefinition::MSG = T.let(T.unsafe(nil), String)

# Checks for places where multiple consecutive loops over the same data
# can be combined into a single loop. It is very likely that combining them
# will make the code more efficient and more concise.
#
# @example
#   # bad
#   def method
#   items.each do |item|
#   do_something(item)
#   end
#
#   items.each do |item|
#   do_something_else(item)
#   end
#   end
#
#   # good
#   def method
#   items.each do |item|
#   do_something(item)
#   do_something_else(item)
#   end
#   end
#
#   # bad
#   def method
#   for item in items do
#   do_something(item)
#   end
#
#   for item in items do
#   do_something_else(item)
#   end
#   end
#
#   # good
#   def method
#   for item in items do
#   do_something(item)
#   do_something_else(item)
#   end
#   end
#
#   # good
#   def method
#   each_slice(2) { |slice| do_something(slice) }
#   each_slice(3) { |slice| do_something(slice) }
#   end
#
# source://rubocop//lib/rubocop/cop/style/combinable_loops.rb#59
class RuboCop::Cop::Style::CombinableLoops < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/style/combinable_loops.rb#62
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/style/combinable_loops.rb#71
  def on_for(node); end

  # source://rubocop//lib/rubocop/cop/style/combinable_loops.rb#62
  def on_numblock(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/combinable_loops.rb#80
  def collection_looping_method?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/combinable_loops.rb#86
  def same_collection_looping?(node, sibling); end
end

# source://rubocop//lib/rubocop/cop/style/combinable_loops.rb#60
RuboCop::Cop::Style::CombinableLoops::MSG = T.let(T.unsafe(nil), String)

# Enforces using `` or %x around command literals.
#
# @example EnforcedStyle: backticks (default)
#   # bad
#   folders = %x(find . -type d).split
#
#   # bad
#   %x(
#   ln -s foo.example.yml foo.example
#   ln -s bar.example.yml bar.example
#   )
#
#   # good
#   folders = `find . -type d`.split
#
#   # good
#   `
#   ln -s foo.example.yml foo.example
#   ln -s bar.example.yml bar.example
#   `
# @example EnforcedStyle: mixed
#   # bad
#   folders = %x(find . -type d).split
#
#   # bad
#   `
#   ln -s foo.example.yml foo.example
#   ln -s bar.example.yml bar.example
#   `
#
#   # good
#   folders = `find . -type d`.split
#
#   # good
#   %x(
#   ln -s foo.example.yml foo.example
#   ln -s bar.example.yml bar.example
#   )
# @example EnforcedStyle: percent_x
#   # bad
#   folders = `find . -type d`.split
#
#   # bad
#   `
#   ln -s foo.example.yml foo.example
#   ln -s bar.example.yml bar.example
#   `
#
#   # good
#   folders = %x(find . -type d).split
#
#   # good
#   %x(
#   ln -s foo.example.yml foo.example
#   ln -s bar.example.yml bar.example
#   )
# @example AllowInnerBackticks: false (default)
#   # If `false`, the cop will always recommend using `%x` if one or more
#   # backticks are found in the command string.
#
#   # bad
#   `echo \`ls\``
#
#   # good
#   %x(echo `ls`)
# @example AllowInnerBackticks: true
#   # good
#   `echo \`ls\``
#
# source://rubocop//lib/rubocop/cop/style/command_literal.rb#78
class RuboCop::Cop::Style::CommandLiteral < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/command_literal.rb#85
  def on_xstr(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/command_literal.rb#146
  def allow_inner_backticks?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/command_literal.rb#122
  def allowed_backtick_literal?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/command_literal.rb#131
  def allowed_percent_x_literal?(node); end

  # source://rubocop//lib/rubocop/cop/style/command_literal.rb#109
  def autocorrect(corrector, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/command_literal.rb#159
  def backtick_literal?(node); end

  # source://rubocop//lib/rubocop/cop/style/command_literal.rb#97
  def check_backtick_literal(node, message); end

  # source://rubocop//lib/rubocop/cop/style/command_literal.rb#103
  def check_percent_x_literal(node, message); end

  # source://rubocop//lib/rubocop/cop/style/command_literal.rb#167
  def command_delimiter; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/command_literal.rb#150
  def contains_backtick?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/command_literal.rb#142
  def contains_disallowed_backtick?(node); end

  # source://rubocop//lib/rubocop/cop/style/command_literal.rb#171
  def default_delimiter; end

  # source://rubocop//lib/rubocop/cop/style/command_literal.rb#154
  def node_body(node); end

  # source://rubocop//lib/rubocop/cop/style/command_literal.rb#163
  def preferred_delimiter; end

  # source://rubocop//lib/rubocop/cop/style/command_literal.rb#175
  def preferred_delimiters_config; end
end

# source://rubocop//lib/rubocop/cop/style/command_literal.rb#82
RuboCop::Cop::Style::CommandLiteral::MSG_USE_BACKTICKS = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/command_literal.rb#83
RuboCop::Cop::Style::CommandLiteral::MSG_USE_PERCENT_X = T.let(T.unsafe(nil), String)

# Checks that comment annotation keywords are written according
# to guidelines.
#
# Annotation keywords can be specified by overriding the cop's `Keywords`
# configuration. Keywords are allowed to be single words or phrases.
#
# NOTE: With a multiline comment block (where each line is only a
# comment), only the first line will be able to register an offense, even
# if an annotation keyword starts another line. This is done to prevent
# incorrect registering of keywords (eg. `review`) inside a paragraph as an
# annotation.
#
# @example RequireColon: true (default)
#   # bad
#   # TODO make better
#
#   # good
#   # TODO: make better
#
#   # bad
#   # TODO:make better
#
#   # good
#   # TODO: make better
#
#   # bad
#   # fixme: does not work
#
#   # good
#   # FIXME: does not work
#
#   # bad
#   # Optimize does not work
#
#   # good
#   # OPTIMIZE: does not work
# @example RequireColon: false
#   # bad
#   # TODO: make better
#
#   # good
#   # TODO make better
#
#   # bad
#   # fixme does not work
#
#   # good
#   # FIXME does not work
#
#   # bad
#   # Optimize does not work
#
#   # good
#   # OPTIMIZE does not work
#
# source://rubocop//lib/rubocop/cop/style/comment_annotation.rb#61
class RuboCop::Cop::Style::CommentAnnotation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/comment_annotation.rb#73
  def on_new_investigation; end

  private

  # source://rubocop//lib/rubocop/cop/style/comment_annotation.rb#110
  def annotation_range(annotation); end

  # source://rubocop//lib/rubocop/cop/style/comment_annotation.rb#114
  def correct_offense(corrector, range, keyword); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/comment_annotation.rb#102
  def first_comment_line?(comments, index); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/comment_annotation.rb#106
  def inline_comment?(comment); end

  # source://rubocop//lib/rubocop/cop/style/comment_annotation.rb#124
  def keywords; end

  # source://rubocop//lib/rubocop/cop/style/comment_annotation.rb#87
  def register_offense(annotation); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/comment_annotation.rb#120
  def requires_colon?; end
end

# source://rubocop//lib/rubocop/cop/style/comment_annotation.rb#71
RuboCop::Cop::Style::CommentAnnotation::MISSING_NOTE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/comment_annotation.rb#65
RuboCop::Cop::Style::CommentAnnotation::MSG_COLON_STYLE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/comment_annotation.rb#68
RuboCop::Cop::Style::CommentAnnotation::MSG_SPACE_STYLE = T.let(T.unsafe(nil), String)

# Checks for comments put on the same line as some keywords.
# These keywords are: `class`, `module`, `def`, `begin`, `end`.
#
# Note that some comments
# are allowed.
#
# Autocorrection removes comments from `end` keyword and keeps comments
# for `class`, `module`, `def` and `begin` above the keyword.
#
# @example
#   # bad
#   if condition
#   statement
#   end # end if
#
#   # bad
#   class X # comment
#   statement
#   end
#
#   # bad
#   def x; end # comment
#
#   # good
#   if condition
#   statement
#   end
#
#   # good
#   class X # :nodoc:
#   y
#   end
#
# source://rubocop//lib/rubocop/cop/style/commented_keyword.rb#43
class RuboCop::Cop::Style::CommentedKeyword < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/commented_keyword.rb#57
  def on_new_investigation; end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/commented_keyword.rb#80
  def offensive?(comment); end

  # source://rubocop//lib/rubocop/cop/style/commented_keyword.rb#67
  def register_offense(comment, matched_keyword); end

  # source://rubocop//lib/rubocop/cop/style/commented_keyword.rb#86
  def source_line(comment); end
end

# source://rubocop//lib/rubocop/cop/style/commented_keyword.rb#52
RuboCop::Cop::Style::CommentedKeyword::ALLOWED_COMMENTS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/commented_keyword.rb#53
RuboCop::Cop::Style::CommentedKeyword::ALLOWED_COMMENT_REGEXES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/commented_keyword.rb#49
RuboCop::Cop::Style::CommentedKeyword::KEYWORDS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/commented_keyword.rb#50
RuboCop::Cop::Style::CommentedKeyword::KEYWORD_REGEXES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/commented_keyword.rb#47
RuboCop::Cop::Style::CommentedKeyword::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/commented_keyword.rb#55
RuboCop::Cop::Style::CommentedKeyword::REGEXP = T.let(T.unsafe(nil), Regexp)

# Enforces the use of `Comparable#clamp` instead of comparison by minimum and maximum.
#
# This cop supports autocorrection for `if/elsif/else` bad style only.
# Because `ArgumentError` occurs if the minimum and maximum of `clamp` arguments are reversed.
# When these are variables, it is not possible to determine which is the minimum and maximum:
#
# [source,ruby]
# ----
# [1, [2, 3].max].min # => 1
# 1.clamp(3, 1)       # => min argument must be smaller than max argument (ArgumentError)
# ----
#
# @example
#
#   # bad
#   [[x, low].max, high].min
#
#   # bad
#   if x < low
#   low
#   elsif high < x
#   high
#   else
#   x
#   end
#
#   # good
#   x.clamp(low, high)
#
# source://rubocop//lib/rubocop/cop/style/comparable_clamp.rb#35
class RuboCop::Cop::Style::ComparableClamp < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop//lib/rubocop/cop/style/comparable_clamp.rb#61
  def array_min_max?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/comparable_clamp.rb#47
  def if_elsif_else_condition?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/comparable_clamp.rb#78
  def on_if(node); end

  # source://rubocop//lib/rubocop/cop/style/comparable_clamp.rb#100
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/comparable_clamp.rb#108
  def autocorrect(corrector, node, prefer); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/comparable_clamp.rb#117
  def min_condition?(if_condition, else_body); end
end

# source://rubocop//lib/rubocop/cop/style/comparable_clamp.rb#42
RuboCop::Cop::Style::ComparableClamp::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/comparable_clamp.rb#43
RuboCop::Cop::Style::ComparableClamp::MSG_MIN_MAX = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/comparable_clamp.rb#44
RuboCop::Cop::Style::ComparableClamp::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Enforces the use of `Array#push(item)` instead of `Array#concat([item])`
# to avoid redundant array literals.
#
# @example
#
#   # bad
#   list.concat([foo])
#   list.concat([bar, baz])
#   list.concat([qux, quux], [corge])
#
#   # good
#   list.push(foo)
#   list.push(bar, baz)
#   list.push(qux, quux, corge)
#
# source://rubocop//lib/rubocop/cop/style/concat_array_literals.rb#25
class RuboCop::Cop::Style::ConcatArrayLiterals < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/concat_array_literals.rb#34
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/concat_array_literals.rb#69
  def offense_range(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/concat_array_literals.rb#86
  def percent_literals_includes_only_basic_literals?(node); end

  # source://rubocop//lib/rubocop/cop/style/concat_array_literals.rb#73
  def preferred_method(node); end
end

# source://rubocop//lib/rubocop/cop/style/concat_array_literals.rb#28
RuboCop::Cop::Style::ConcatArrayLiterals::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/concat_array_literals.rb#29
RuboCop::Cop::Style::ConcatArrayLiterals::MSG_FOR_PERCENT_LITERALS = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/concat_array_literals.rb#31
RuboCop::Cop::Style::ConcatArrayLiterals::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Check for `if` and `case` statements where each branch is used for
# assignment to the same variable when using the return of the
# condition can be used instead.
#
# @example EnforcedStyle: assign_to_condition (default)
#   # bad
#   if foo
#   bar = 1
#   else
#   bar = 2
#   end
#
#   case foo
#   when 'a'
#   bar += 1
#   else
#   bar += 2
#   end
#
#   if foo
#   some_method
#   bar = 1
#   else
#   some_other_method
#   bar = 2
#   end
#
#   # good
#   bar = if foo
#   1
#   else
#   2
#   end
#
#   bar += case foo
#   when 'a'
#   1
#   else
#   2
#   end
#
#   bar << if foo
#   some_method
#   1
#   else
#   some_other_method
#   2
#   end
# @example EnforcedStyle: assign_inside_condition
#   # bad
#   bar = if foo
#   1
#   else
#   2
#   end
#
#   bar += case foo
#   when 'a'
#   1
#   else
#   2
#   end
#
#   bar << if foo
#   some_method
#   1
#   else
#   some_other_method
#   2
#   end
#
#   # good
#   if foo
#   bar = 1
#   else
#   bar = 2
#   end
#
#   case foo
#   when 'a'
#   bar += 1
#   else
#   bar += 2
#   end
#
#   if foo
#   some_method
#   bar = 1
#   else
#   some_other_method
#   bar = 2
#   end
#
# source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#210
class RuboCop::Cop::Style::ConditionalAssignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # The shovel operator `<<` does not have its own type. It is a `send`
  # type.
  #
  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#228
  def assignment_type?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#309
  def candidate_condition?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#236
  def on_and_asgn(node); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#264
  def on_case(node); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#274
  def on_case_match(node); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#236
  def on_casgn(node); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#236
  def on_cvasgn(node); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#236
  def on_gvasgn(node); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#250
  def on_if(node); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#236
  def on_ivasgn(node); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#236
  def on_lvasgn(node); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#236
  def on_masgn(node); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#236
  def on_op_asgn(node); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#236
  def on_or_asgn(node); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#244
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#315
  def allowed_single_line?(branches); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#386
  def allowed_statements?(branches); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#311
  def allowed_ternary?(assignment); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#319
  def assignment_node(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#363
  def assignment_types_match?(*nodes); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#378
  def autocorrect(corrector, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#304
  def candidate_node?(node); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#286
  def check_assignment_to_condition(node); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#369
  def check_node(node, branches); end

  # If `Layout/LineLength` is enabled, we do not want to introduce an
  # offense by autocorrecting this cop. Find the max configured line
  # length. Find the longest line of condition. Remove the assignment
  # from lines that contain the offending assignment because after
  # correcting, this will not be on the line anymore. Check if the length
  # of the longest line + the length of the corrected assignment is
  # greater than the max configured line length
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#402
  def correction_exceeds_line_limit?(node, branches); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#433
  def include_ternary?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#356
  def lhs_all_match?(branches); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#421
  def line_length_cop_enabled?; end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#414
  def longest_line(node, assignment); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#410
  def longest_line_exceeds_line_limit?(node, assignment); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#425
  def max_line_length; end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#340
  def move_assignment_inside_condition(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#330
  def move_assignment_outside_condition(corrector, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#429
  def single_line_conditions_only?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#352
  def ternary_condition?(node); end
end

# source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#219
RuboCop::Cop::Style::ConditionalAssignment::ASSIGNMENT_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#217
RuboCop::Cop::Style::ConditionalAssignment::ASSIGN_TO_CONDITION_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#221
RuboCop::Cop::Style::ConditionalAssignment::ENABLED = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#220
RuboCop::Cop::Style::ConditionalAssignment::LINE_LENGTH = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#222
RuboCop::Cop::Style::ConditionalAssignment::MAX = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#216
RuboCop::Cop::Style::ConditionalAssignment::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#223
RuboCop::Cop::Style::ConditionalAssignment::SINGLE_LINE_CONDITIONS_ONLY = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#218
RuboCop::Cop::Style::ConditionalAssignment::VARIABLE_ASSIGNMENT_TYPES = T.let(T.unsafe(nil), Array)

# Helper module to provide common methods to classes needed for the
# ConditionalAssignment Cop.
#
# source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#8
module RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::AST::NodePattern::Macros

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#64
  def end_with_eq?(sym); end

  # `elsif` branches show up in the `node` as an `else`. We need
  # to recursively iterate over all `else` branches and consider all
  # but the last `node` an `elsif` branch and consider the last `node`
  # the actual `else` branch.
  #
  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#20
  def expand_elses(branch); end

  # `when` nodes contain the entire branch including the condition.
  # We only need the contents of the branch, not the condition.
  #
  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#28
  def expand_when_branches(when_branches); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#55
  def indent(cop, source); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#37
  def lhs(node); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#32
  def tail(branch); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#109
  def assignment_rhs_exist?(node); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#70
  def expand_elsif(node, elsif_branches = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#96
  def lhs_for_casgn(node); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#83
  def lhs_for_send(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#105
  def setter_method?(method_name); end
end

# source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#13
RuboCop::Cop::Style::ConditionalAssignmentHelper::ALIGN_WITH = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#12
RuboCop::Cop::Style::ConditionalAssignmentHelper::END_ALIGNMENT = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#11
RuboCop::Cop::Style::ConditionalAssignmentHelper::EQUAL = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#14
RuboCop::Cop::Style::ConditionalAssignmentHelper::KEYWORD = T.let(T.unsafe(nil), String)

# Helper module to provide common methods to ConditionalAssignment
# correctors
#
# source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#440
module RuboCop::Cop::Style::ConditionalCorrectorHelper
  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#459
  def assignment(node); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#489
  def correct_branches(corrector, branches); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#466
  def correct_if_branches(corrector, cop, node); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#441
  def remove_whitespace_in_branches(corrector, branch, condition, column); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#476
  def replace_branch_assignment(corrector, branch); end

  # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#452
  def white_space_range(node, column); end
end

# Checks that constants defined in classes and modules have
# an explicit visibility declaration. By default, Ruby makes all class-
# and module constants public, which litters the public API of the
# class or module. Explicitly declaring a visibility makes intent more
# clear, and prevents outside actors from touching private state.
#
# @example
#
#   # bad
#   class Foo
#   BAR = 42
#   BAZ = 43
#   end
#
#   # good
#   class Foo
#   BAR = 42
#   private_constant :BAR
#
#   BAZ = 43
#   public_constant :BAZ
#   end
# @example IgnoreModules: false (default)
#   # bad
#   class Foo
#   MyClass = Struct.new()
#   end
#
#   # good
#   class Foo
#   MyClass = Struct.new()
#   public_constant :MyClass
#   end
# @example IgnoreModules: true
#   # good
#   class Foo
#   MyClass = Struct.new()
#   end
#
# source://rubocop//lib/rubocop/cop/style/constant_visibility.rb#47
class RuboCop::Cop::Style::ConstantVisibility < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/style/constant_visibility.rb#51
  def on_casgn(node); end

  # source://rubocop//lib/rubocop/cop/style/constant_visibility.rb#96
  def visibility_declaration_for?(param0 = T.unsafe(nil), param1); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/constant_visibility.rb#76
  def class_or_module_scope?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/constant_visibility.rb#62
  def ignore_modules?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/constant_visibility.rb#100
  def match_name?(name, constant_name); end

  # source://rubocop//lib/rubocop/cop/style/constant_visibility.rb#70
  def message(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/constant_visibility.rb#66
  def module?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/constant_visibility.rb#87
  def visibility_declaration?(node); end
end

# source://rubocop//lib/rubocop/cop/style/constant_visibility.rb#48
RuboCop::Cop::Style::ConstantVisibility::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/copyright.rb#18
class RuboCop::Cop::Style::Copyright < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/copyright.rb#25
  def on_new_investigation; end

  private

  # source://rubocop//lib/rubocop/cop/style/copyright.rb#44
  def autocorrect_notice; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/copyright.rb#75
  def encoding_token?(processed_source, token_index); end

  # source://rubocop//lib/rubocop/cop/style/copyright.rb#61
  def insert_notice_before(processed_source); end

  # source://rubocop//lib/rubocop/cop/style/copyright.rb#40
  def notice; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/copyright.rb#82
  def notice_found?(processed_source); end

  # source://rubocop//lib/rubocop/cop/style/copyright.rb#48
  def offense_range; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/copyright.rb#68
  def shebang_token?(processed_source, token_index); end

  # @raise [Warning]
  #
  # source://rubocop//lib/rubocop/cop/style/copyright.rb#52
  def verify_autocorrect_notice!; end
end

# source://rubocop//lib/rubocop/cop/style/copyright.rb#23
RuboCop::Cop::Style::Copyright::AUTOCORRECT_EMPTY_WARNING = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/copyright.rb#22
RuboCop::Cop::Style::Copyright::MSG = T.let(T.unsafe(nil), String)

# Checks for inheritance from `Data.define` to avoid creating the anonymous parent class.
#
# @example
#   # bad
#   class Person < Data.define(:first_name, :last_name)
#   def age
#   42
#   end
#   end
#
#   # good
#   Person = Data.define(:first_name, :last_name) do
#   def age
#   42
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/style/data_inheritance.rb#26
class RuboCop::Cop::Style::DataInheritance < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop//lib/rubocop/cop/style/data_inheritance.rb#48
  def data_define?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/data_inheritance.rb#36
  def on_class(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/data_inheritance.rb#55
  def correct_parent(parent, corrector); end

  # source://rubocop//lib/rubocop/cop/style/data_inheritance.rb#65
  def range_for_empty_class_body(class_node, data_define); end
end

# source://rubocop//lib/rubocop/cop/style/data_inheritance.rb#31
RuboCop::Cop::Style::DataInheritance::MSG = T.let(T.unsafe(nil), String)

# Checks for consistent usage of the `DateTime` class over the
# `Time` class. This cop is disabled by default since these classes,
# although highly overlapping, have particularities that make them not
# replaceable in certain situations when dealing with multiple timezones
# and/or DST.
#
# @example
#
#   # bad - uses `DateTime` for current time
#   DateTime.now
#
#   # good - uses `Time` for current time
#   Time.now
#
#   # bad - uses `DateTime` for modern date
#   DateTime.iso8601('2016-06-29')
#
#   # good - uses `Time` for modern date
#   Time.iso8601('2016-06-29')
#
#   # good - uses `DateTime` with start argument for historical date
#   DateTime.iso8601('1751-04-23', Date::ENGLAND)
# @example AllowCoercion: false (default)
#
#   # bad - coerces to `DateTime`
#   something.to_datetime
#
#   # good - coerces to `Time`
#   something.to_time
# @example AllowCoercion: true
#
#   # good
#   something.to_datetime
#
#   # good
#   something.to_time
#
# source://rubocop//lib/rubocop/cop/style/date_time.rb#49
class RuboCop::Cop::Style::DateTime < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/date_time.rb#56
  def date_time?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/date_time.rb#61
  def historic_date?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/date_time.rb#70
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/style/date_time.rb#66
  def to_datetime?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/style/date_time.rb#85
  def autocorrect(corrector, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/date_time.rb#81
  def disallow_coercion?; end
end

# source://rubocop//lib/rubocop/cop/style/date_time.rb#52
RuboCop::Cop::Style::DateTime::CLASS_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/date_time.rb#53
RuboCop::Cop::Style::DateTime::COERCION_MSG = T.let(T.unsafe(nil), String)

# Checks for parentheses in the definition of a method,
# that does not take any arguments. Both instance and
# class/singleton methods are checked.
#
# @example
#
#   # bad
#   def foo()
#   do_something
#   end
#
#   # good
#   def foo
#   do_something
#   end
#
#   # bad
#   def foo() = do_something
#
#   # good
#   def foo = do_something
#
#   # good (without parentheses it's a syntax error)
#   def foo() do_something end
# @example
#
#   # bad
#   def Baz.foo()
#   do_something
#   end
#
#   # good
#   def Baz.foo
#   do_something
#   end
#
# source://rubocop//lib/rubocop/cop/style/def_with_parentheses.rb#42
class RuboCop::Cop::Style::DefWithParentheses < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/def_with_parentheses.rb#47
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/style/def_with_parentheses.rb#47
  def on_defs(node); end
end

# source://rubocop//lib/rubocop/cop/style/def_with_parentheses.rb#45
RuboCop::Cop::Style::DefWithParentheses::MSG = T.let(T.unsafe(nil), String)

# Checks for places where the `#__dir__` method can replace more
# complex constructs to retrieve a canonicalized absolute path to the
# current file.
#
# @example
#   # bad
#   path = File.expand_path(File.dirname(__FILE__))
#
#   # bad
#   path = File.dirname(File.realpath(__FILE__))
#
#   # good
#   path = __dir__
#
# source://rubocop//lib/rubocop/cop/style/dir.rb#19
class RuboCop::Cop::Style::Dir < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop//lib/rubocop/cop/style/dir.rb#29
  def dir_replacement?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/dir.rb#34
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/dir.rb#44
  def file_keyword?(node); end
end

# source://rubocop//lib/rubocop/cop/style/dir.rb#25
RuboCop::Cop::Style::Dir::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/dir.rb#26
RuboCop::Cop::Style::Dir::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Prefer to use `Dir.empty?('path/to/dir')` when checking if a directory is empty.
#
# @example
#   # bad
#   Dir.entries('path/to/dir').size == 2
#   Dir.children('path/to/dir').empty?
#   Dir.children('path/to/dir').size == 0
#   Dir.each_child('path/to/dir').none?
#
#   # good
#   Dir.empty?('path/to/dir')
#
# source://rubocop//lib/rubocop/cop/style/dir_empty.rb#18
class RuboCop::Cop::Style::DirEmpty < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop//lib/rubocop/cop/style/dir_empty.rb#28
  def offensive?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/dir_empty.rb#39
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/dir_empty.rb#51
  def bang(node); end
end

# source://rubocop//lib/rubocop/cop/style/dir_empty.rb#22
RuboCop::Cop::Style::DirEmpty::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/dir_empty.rb#23
RuboCop::Cop::Style::DirEmpty::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Detects comments to enable/disable RuboCop.
# This is useful if want to make sure that every RuboCop error gets fixed
# and not quickly disabled with a comment.
#
# Specific cops can be allowed with the `AllowedCops` configuration. Note that
#
# @example
#   # bad
#   # rubocop:disable Metrics/AbcSize
#   def foo
#   end
#   # rubocop:enable Metrics/AbcSize
#
#   # good
#   def foo
#   end
# @example AllowedCops: [Metrics/AbcSize]
#   # good
#   # rubocop:disable Metrics/AbcSize
#   def foo
#   end
#   # rubocop:enable Metrics/AbcSize
#
# source://rubocop//lib/rubocop/cop/style/disable_cops_within_source_code_directive.rb#33
class RuboCop::Cop::Style::DisableCopsWithinSourceCodeDirective < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/disable_cops_within_source_code_directive.rb#40
  def on_new_investigation; end

  private

  # source://rubocop//lib/rubocop/cop/style/disable_cops_within_source_code_directive.rb#77
  def allowed_cops; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/disable_cops_within_source_code_directive.rb#81
  def any_cops_allowed?; end

  # source://rubocop//lib/rubocop/cop/style/disable_cops_within_source_code_directive.rb#72
  def directive_cops(comment); end

  # source://rubocop//lib/rubocop/cop/style/disable_cops_within_source_code_directive.rb#53
  def register_offense(comment, directive_cops, disallowed_cops); end
end

# source://rubocop//lib/rubocop/cop/style/disable_cops_within_source_code_directive.rb#37
RuboCop::Cop::Style::DisableCopsWithinSourceCodeDirective::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/disable_cops_within_source_code_directive.rb#38
RuboCop::Cop::Style::DisableCopsWithinSourceCodeDirective::MSG_FOR_COPS = T.let(T.unsafe(nil), String)

# When using `class_eval` (or other `eval`) with string interpolation,
# add a comment block showing its appearance if interpolated (a practice used in Rails code).
#
# @example
#   # from activesupport/lib/active_support/core_ext/string/output_safety.rb
#
#   # bad
#   UNSAFE_STRING_METHODS.each do |unsafe_method|
#   if 'String'.respond_to?(unsafe_method)
#   class_eval <<-EOT, __FILE__, __LINE__ + 1
#   def #{unsafe_method}(*params, &block)
#   to_str.#{unsafe_method}(*params, &block)
#   end
#
#   def #{unsafe_method}!(*params)
#   @dirty = true
#   super
#   end
#   EOT
#   end
#   end
#
#   # good, inline comments in heredoc
#   UNSAFE_STRING_METHODS.each do |unsafe_method|
#   if 'String'.respond_to?(unsafe_method)
#   class_eval <<-EOT, __FILE__, __LINE__ + 1
#   def #{unsafe_method}(*params, &block)       # def capitalize(*params, &block)
#   to_str.#{unsafe_method}(*params, &block)  #   to_str.capitalize(*params, &block)
#   end                                         # end
#
#   def #{unsafe_method}!(*params)              # def capitalize!(*params)
#   @dirty = true                             #   @dirty = true
#   super                                     #   super
#   end                                         # end
#   EOT
#   end
#   end
#
#   # good, block comments in heredoc
#   class_eval <<-EOT, __FILE__, __LINE__ + 1
#   # def capitalize!(*params)
#   #   @dirty = true
#   #   super
#   # end
#
#   def #{unsafe_method}!(*params)
#   @dirty = true
#   super
#   end
#   EOT
#
#   # good, block comments before heredoc
#   class_eval(
#   # def capitalize!(*params)
#   #   @dirty = true
#   #   super
#   # end
#
#   <<-EOT, __FILE__, __LINE__ + 1
#   def #{unsafe_method}!(*params)
#   @dirty = true
#   super
#   end
#   EOT
#   )
#
#   # bad - interpolated string without comment
#   class_eval("def #{unsafe_method}!(*params); end")
#
#   # good - with inline comment or replace it with block comment using heredoc
#   class_eval("def #{unsafe_method}!(*params); end # def capitalize!(*params); end")
#
# source://rubocop//lib/rubocop/cop/style/document_dynamic_eval_definition.rb#77
class RuboCop::Cop::Style::DocumentDynamicEvalDefinition < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/style/document_dynamic_eval_definition.rb#84
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/document_dynamic_eval_definition.rb#107
  def comment_block_docs?(arg_node); end

  # source://rubocop//lib/rubocop/cop/style/document_dynamic_eval_definition.rb#147
  def comment_regexp(arg_node); end

  # source://rubocop//lib/rubocop/cop/style/document_dynamic_eval_definition.rb#126
  def heredoc_comment_blocks(heredoc_body); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/document_dynamic_eval_definition.rb#100
  def inline_comment_docs?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/document_dynamic_eval_definition.rb#96
  def interpolated?(arg_node); end

  # source://rubocop//lib/rubocop/cop/style/document_dynamic_eval_definition.rb#136
  def merge_adjacent_comments(line, index, hash); end

  # source://rubocop//lib/rubocop/cop/style/document_dynamic_eval_definition.rb#117
  def preceding_comment_blocks(node); end

  # source://rubocop//lib/rubocop/cop/style/document_dynamic_eval_definition.rb#156
  def source_to_regexp(source); end
end

# source://rubocop//lib/rubocop/cop/style/document_dynamic_eval_definition.rb#78
RuboCop::Cop::Style::DocumentDynamicEvalDefinition::BLOCK_COMMENT_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/style/document_dynamic_eval_definition.rb#79
RuboCop::Cop::Style::DocumentDynamicEvalDefinition::COMMENT_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/style/document_dynamic_eval_definition.rb#80
RuboCop::Cop::Style::DocumentDynamicEvalDefinition::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/document_dynamic_eval_definition.rb#82
RuboCop::Cop::Style::DocumentDynamicEvalDefinition::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for missing top-level documentation of classes and
# modules. Classes with no body are exempt from the check and so are
# namespace modules - modules that have nothing in their bodies except
# classes, other modules, constant definitions or constant visibility
# declarations.
#
# The documentation requirement is annulled if the class or module has
# same for all its children.
#
# @example
#   # bad
#   class Person
#   # ...
#   end
#
#   module Math
#   end
#
#   # good
#   # Description/Explanation of Person class
#   class Person
#   # ...
#   end
#
#   # allowed
#   # Class without body
#   class Person
#   end
#
#   # Namespace - A namespace can be a class or a module
#   # Containing a class
#   module Namespace
#   # Description/Explanation of Person class
#   class Person
#   # ...
#   end
#   end
#
#   # Containing constant visibility declaration
#   module Namespace
#   class Private
#   end
#
#   private_constant :Private
#   end
#
#   # Containing constant definition
#   module Namespace
#   Public = Class.new
#   end
#
#   # Macro calls
#   module Namespace
#   extend Foo
#   end
# @example AllowedConstants: ['ClassMethods']
#
#   # good
#   module A
#   module ClassMethods
#   # ...
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/style/documentation.rb#72
class RuboCop::Cop::Style::Documentation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::DocumentationComment
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/style/documentation.rb#79
  def constant_definition?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/documentation.rb#85
  def constant_visibility_declaration?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/documentation.rb#90
  def include_statement?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/documentation.rb#94
  def on_class(node); end

  # source://rubocop//lib/rubocop/cop/style/documentation.rb#100
  def on_module(node); end

  # source://rubocop//lib/rubocop/cop/style/documentation.rb#82
  def outer_module(param0); end

  private

  # source://rubocop//lib/rubocop/cop/style/documentation.rb#174
  def allowed_constants; end

  # source://rubocop//lib/rubocop/cop/style/documentation.rb#106
  def check(node, body); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/documentation.rb#147
  def compact_namespace?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/documentation.rb#143
  def constant_allowed?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/documentation.rb#139
  def constant_declaration?(node); end

  # source://rubocop//lib/rubocop/cop/style/documentation.rb#178
  def identifier(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/documentation.rb#123
  def include_statement_only?(body); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/documentation.rb#129
  def namespace?(node); end

  # source://rubocop//lib/rubocop/cop/style/documentation.rb#170
  def nodoc(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/documentation.rb#166
  def nodoc?(comment, require_all: T.unsafe(nil)); end

  # Note: How end-of-line comments are associated with code changed in
  # parser-2.2.0.4.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/documentation.rb#156
  def nodoc_comment?(node, require_all: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/documentation.rb#118
  def nodoc_self_or_outer_module?(node); end

  # source://rubocop//lib/rubocop/cop/style/documentation.rb#186
  def qualify_const(node); end
end

# source://rubocop//lib/rubocop/cop/style/documentation.rb#76
RuboCop::Cop::Style::Documentation::MSG = T.let(T.unsafe(nil), String)

# Checks for missing documentation comment for public methods.
# It can optionally be configured to also require documentation for
# non-public methods.
#
# NOTE: This cop allows `initialize` method because `initialize` is
# a special method called from `new`. In some programming languages
# they are called constructor to distinguish it from method.
#
# @example
#
#   # bad
#
#   class Foo
#   def bar
#   puts baz
#   end
#   end
#
#   module Foo
#   def bar
#   puts baz
#   end
#   end
#
#   def foo.bar
#   puts baz
#   end
#
#   # good
#
#   class Foo
#   # Documentation
#   def bar
#   puts baz
#   end
#   end
#
#   module Foo
#   # Documentation
#   def bar
#   puts baz
#   end
#   end
#
#   # Documentation
#   def foo.bar
#   puts baz
#   end
# @example RequireForNonPublicMethods: false (default)
#   # good
#   class Foo
#   protected
#   def do_something
#   end
#   end
#
#   class Foo
#   private
#   def do_something
#   end
#   end
# @example RequireForNonPublicMethods: true
#   # bad
#   class Foo
#   protected
#   def do_something
#   end
#   end
#
#   class Foo
#   private
#   def do_something
#   end
#   end
#
#   # good
#   class Foo
#   protected
#   # Documentation
#   def do_something
#   end
#   end
#
#   class Foo
#   private
#   # Documentation
#   def do_something
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/style/documentation_method.rb#98
class RuboCop::Cop::Style::DocumentationMethod < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::DocumentationComment
  include ::RuboCop::Cop::VisibilityHelp
  include ::RuboCop::Cop::DefNode

  # source://rubocop//lib/rubocop/cop/style/documentation_method.rb#105
  def modifier_node?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/documentation_method.rb#109
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/style/documentation_method.rb#109
  def on_defs(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/documentation_method.rb#119
  def check(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/documentation_method.rb#126
  def require_for_non_public_methods?; end
end

# source://rubocop//lib/rubocop/cop/style/documentation_method.rb#102
RuboCop::Cop::Style::DocumentationMethod::MSG = T.let(T.unsafe(nil), String)

# Detects double disable comments on one line. This is mostly to catch
# automatically generated comments that need to be regenerated.
#
# @example
#   # bad
#   def f # rubocop:disable Style/For # rubocop:disable Metrics/AbcSize
#   end
#
#   # good
#   # rubocop:disable Metrics/AbcSize
#   def f # rubocop:disable Style/For
#   end
#   # rubocop:enable Metrics/AbcSize
#
#   # if both fit on one line
#   def f # rubocop:disable Style/For, Metrics/AbcSize
#   end
#
# source://rubocop//lib/rubocop/cop/style/double_cop_disable_directive.rb#27
class RuboCop::Cop::Style::DoubleCopDisableDirective < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/double_cop_disable_directive.rb#34
  def on_new_investigation; end
end

# source://rubocop//lib/rubocop/cop/style/double_cop_disable_directive.rb#32
RuboCop::Cop::Style::DoubleCopDisableDirective::MSG = T.let(T.unsafe(nil), String)

# Checks for uses of double negation (`!!`) to convert something to a boolean value.
#
# When using `EnforcedStyle: allowed_in_returns`, allow double negation in contexts
# that use boolean as a return value. When using `EnforcedStyle: forbidden`, double negation
# should be forbidden always.
#
# NOTE: when `something` is a boolean value
# `!!something` and `!something.nil?` are not the same thing.
# As you're unlikely to write code that can accept values of any type
# this is rarely a problem in practice.
#
# @example
#   # bad
#   !!something
#
#   # good
#   !something.nil?
# @example EnforcedStyle: allowed_in_returns (default)
#   # good
#   def foo?
#   !!return_value
#   end
#
#   define_method :foo? do
#   !!return_value
#   end
#
#   define_singleton_method :foo? do
#   !!return_value
#   end
# @example EnforcedStyle: forbidden
#   # bad
#   def foo?
#   !!return_value
#   end
#
#   define_method :foo? do
#   !!return_value
#   end
#
#   define_singleton_method :foo? do
#   !!return_value
#   end
#
# source://rubocop//lib/rubocop/cop/style/double_negation.rb#61
class RuboCop::Cop::Style::DoubleNegation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/double_negation.rb#69
  def double_negative?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/double_negation.rb#71
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/double_negation.rb#84
  def allowed_in_returns?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/double_negation.rb#111
  def define_method?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/double_negation.rb#138
  def double_negative_condition_return_value?(node, last_child, conditional_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/double_negation.rb#88
  def end_of_method_definition?(node); end

  # source://rubocop//lib/rubocop/cop/style/double_negation.rb#120
  def find_conditional_node_from_ascendant(node); end

  # source://rubocop//lib/rubocop/cop/style/double_negation.rb#103
  def find_def_node_from_ascendant(node); end

  # source://rubocop//lib/rubocop/cop/style/double_negation.rb#127
  def find_last_child(node); end

  # source://rubocop//lib/rubocop/cop/style/double_negation.rb#147
  def find_parent_not_enumerable(node); end
end

# source://rubocop//lib/rubocop/cop/style/double_negation.rb#65
RuboCop::Cop::Style::DoubleNegation::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/double_negation.rb#66
RuboCop::Cop::Style::DoubleNegation::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for loops which iterate a constant number of times,
# using a Range literal and `#each`. This can be done more readably using
# `Integer#times`.
#
# This check only applies if the block takes no parameters.
#
# @example
#   # bad
#   (1..5).each { }
#
#   # good
#   5.times { }
# @example
#   # bad
#   (0...10).each {}
#
#   # good
#   10.times {}
#
# source://rubocop//lib/rubocop/cop/style/each_for_simple_loop.rb#25
class RuboCop::Cop::Style::EachForSimpleLoop < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/each_for_simple_loop.rb#53
  def each_range(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/each_for_simple_loop.rb#65
  def each_range_with_zero_origin?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/each_for_simple_loop.rb#77
  def each_range_without_block_argument?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/each_for_simple_loop.rb#30
  def on_block(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/each_for_simple_loop.rb#48
  def offending?(node); end
end

# source://rubocop//lib/rubocop/cop/style/each_for_simple_loop.rb#28
RuboCop::Cop::Style::EachForSimpleLoop::MSG = T.let(T.unsafe(nil), String)

# Looks for inject / reduce calls where the passed in object is
# returned at the end and so could be replaced by each_with_object without
# the need to return the object at the end.
#
# However, we can't replace with each_with_object if the accumulator
# parameter is assigned to within the block.
#
# @example
#   # bad
#   [1, 2].inject({}) { |a, e| a[e] = e; a }
#
#   # good
#   [1, 2].each_with_object({}) { |e, a| a[e] = e }
#
# source://rubocop//lib/rubocop/cop/style/each_with_object.rb#19
class RuboCop::Cop::Style::EachWithObject < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/each_with_object.rb#60
  def each_with_object_block_candidate?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/each_with_object.rb#65
  def each_with_object_numblock_candidate?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/each_with_object.rb#26
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/style/each_with_object.rb#43
  def on_numblock(node); end

  private

  # if the accumulator parameter is assigned to in the block,
  # then we can't convert to each_with_object
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/each_with_object.rb#102
  def accumulator_param_assigned_to?(body, args); end

  # source://rubocop//lib/rubocop/cop/style/each_with_object.rb#69
  def autocorrect_block(corrector, node, return_value); end

  # source://rubocop//lib/rubocop/cop/style/each_with_object.rb#84
  def autocorrect_numblock(corrector, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/each_with_object.rb#121
  def first_argument_returned?(args, return_value); end

  # source://rubocop//lib/rubocop/cop/style/each_with_object.rb#114
  def return_value(body); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/each_with_object.rb#129
  def return_value_occupies_whole_line?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/each_with_object.rb#96
  def simple_method_arg?(method_arg); end

  # source://rubocop//lib/rubocop/cop/style/each_with_object.rb#133
  def whole_line_expression(node); end
end

# source://rubocop//lib/rubocop/cop/style/each_with_object.rb#24
RuboCop::Cop::Style::EachWithObject::METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/each_with_object.rb#23
RuboCop::Cop::Style::EachWithObject::MSG = T.let(T.unsafe(nil), String)

# Checks for pipes for empty block parameters. Pipes for empty
# block parameters do not cause syntax errors, but they are redundant.
#
# @example
#   # bad
#   a do ||
#   do_something
#   end
#
#   # bad
#   a { || do_something }
#
#   # good
#   a do
#   end
#
#   # good
#   a { do_something }
#
# source://rubocop//lib/rubocop/cop/style/empty_block_parameter.rb#24
class RuboCop::Cop::Style::EmptyBlockParameter < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::EmptyParameter
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/empty_block_parameter.rb#31
  def on_block(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/empty_block_parameter.rb#38
  def autocorrect(corrector, node); end
end

# source://rubocop//lib/rubocop/cop/style/empty_block_parameter.rb#29
RuboCop::Cop::Style::EmptyBlockParameter::MSG = T.let(T.unsafe(nil), String)

# Checks for case statements with an empty condition.
#
# @example
#
#   # bad:
#   case
#   when x == 0
#   puts 'x is 0'
#   when y == 0
#   puts 'y is 0'
#   else
#   puts 'neither is 0'
#   end
#
#   # good:
#   if x == 0
#   puts 'x is 0'
#   elsif y == 0
#   puts 'y is 0'
#   else
#   puts 'neither is 0'
#   end
#
#   # good: (the case condition node is not empty)
#   case n
#   when 0
#   puts 'zero'
#   when 1
#   puts 'one'
#   else
#   puts 'more'
#   end
#
# source://rubocop//lib/rubocop/cop/style/empty_case_condition.rb#38
class RuboCop::Cop::Style::EmptyCaseCondition < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/empty_case_condition.rb#44
  def on_case(case_node); end

  private

  # source://rubocop//lib/rubocop/cop/style/empty_case_condition.rb#58
  def autocorrect(corrector, case_node); end

  # source://rubocop//lib/rubocop/cop/style/empty_case_condition.rb#65
  def correct_case_when(corrector, case_node, when_nodes); end

  # source://rubocop//lib/rubocop/cop/style/empty_case_condition.rb#77
  def correct_when_conditions(corrector, when_nodes); end

  # source://rubocop//lib/rubocop/cop/style/empty_case_condition.rb#92
  def keep_first_when_comment(case_range, corrector); end

  # source://rubocop//lib/rubocop/cop/style/empty_case_condition.rb#102
  def replace_then_with_line_break(corrector, conditions, when_node); end
end

# source://rubocop//lib/rubocop/cop/style/empty_case_condition.rb#42
RuboCop::Cop::Style::EmptyCaseCondition::MSG = T.let(T.unsafe(nil), String)

# Checks for empty else-clauses, possibly including comments and/or an
# explicit `nil` depending on the EnforcedStyle.
#
# @example EnforcedStyle: both (default)
#   # warn on empty else and else with nil in it
#
#   # bad
#   if condition
#   statement
#   else
#   nil
#   end
#
#   # bad
#   if condition
#   statement
#   else
#   end
#
#   # good
#   if condition
#   statement
#   else
#   statement
#   end
#
#   # good
#   if condition
#   statement
#   end
# @example EnforcedStyle: empty
#   # warn only on empty else
#
#   # bad
#   if condition
#   statement
#   else
#   end
#
#   # good
#   if condition
#   statement
#   else
#   nil
#   end
#
#   # good
#   if condition
#   statement
#   else
#   statement
#   end
#
#   # good
#   if condition
#   statement
#   end
# @example EnforcedStyle: nil
#   # warn on else with nil in it
#
#   # bad
#   if condition
#   statement
#   else
#   nil
#   end
#
#   # good
#   if condition
#   statement
#   else
#   end
#
#   # good
#   if condition
#   statement
#   else
#   statement
#   end
#
#   # good
#   if condition
#   statement
#   end
# @example AllowComments: false (default)
#
#   # bad
#   if condition
#   statement
#   else
#   # something comment
#   nil
#   end
#
#   # bad
#   if condition
#   statement
#   else
#   # something comment
#   end
# @example AllowComments: true
#
#   # good
#   if condition
#   statement
#   else
#   # something comment
#   nil
#   end
#
#   # good
#   if condition
#   statement
#   else
#   # something comment
#   end
#
# source://rubocop//lib/rubocop/cop/style/empty_else.rb#127
class RuboCop::Cop::Style::EmptyElse < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::OnNormalIfUnless
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/empty_else.rb#139
  def on_case(node); end

  # source://rubocop//lib/rubocop/cop/style/empty_else.rb#135
  def on_normal_if_unless(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/empty_else.rb#172
  def autocorrect(corrector, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/empty_else.rb#193
  def autocorrect_forbidden?(type); end

  # source://rubocop//lib/rubocop/cop/style/empty_else.rb#186
  def base_node(node); end

  # source://rubocop//lib/rubocop/cop/style/empty_else.rb#145
  def check(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/empty_else.rb#180
  def comment_in_else?(loc); end

  # source://rubocop//lib/rubocop/cop/style/empty_else.rb#160
  def empty_check(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/empty_else.rb#156
  def empty_style?; end

  # source://rubocop//lib/rubocop/cop/style/empty_else.rb#197
  def missing_else_style; end

  # source://rubocop//lib/rubocop/cop/style/empty_else.rb#166
  def nil_check(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/empty_else.rb#152
  def nil_style?; end
end

# source://rubocop//lib/rubocop/cop/style/empty_else.rb#133
RuboCop::Cop::Style::EmptyElse::MSG = T.let(T.unsafe(nil), String)

# Checks for using empty heredoc to reduce redundancy.
#
# @example
#
#   # bad
#   <<~EOS
#   EOS
#
#   <<-EOS
#   EOS
#
#   <<EOS
#   EOS
#
#   # good
#   ''
#
#   # bad
#   do_something(<<~EOS)
#   EOS
#
#   do_something(<<-EOS)
#   EOS
#
#   do_something(<<EOS)
#   EOS
#
#   # good
#   do_something('')
#
# source://rubocop//lib/rubocop/cop/style/empty_heredoc.rb#36
class RuboCop::Cop::Style::EmptyHeredoc < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Heredoc
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/empty_heredoc.rb#43
  def on_heredoc(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/empty_heredoc.rb#63
  def enforce_double_quotes?; end

  # source://rubocop//lib/rubocop/cop/style/empty_heredoc.rb#59
  def preferred_string_literal; end

  # source://rubocop//lib/rubocop/cop/style/empty_heredoc.rb#67
  def string_literals_config; end
end

# source://rubocop//lib/rubocop/cop/style/empty_heredoc.rb#41
RuboCop::Cop::Style::EmptyHeredoc::MSG = T.let(T.unsafe(nil), String)

# Checks for parentheses for empty lambda parameters. Parentheses
# for empty lambda parameters do not cause syntax errors, but they are
# redundant.
#
# @example
#   # bad
#   -> () { do_something }
#
#   # good
#   -> { do_something }
#
#   # good
#   -> (arg) { do_something(arg) }
#
# source://rubocop//lib/rubocop/cop/style/empty_lambda_parameter.rb#19
class RuboCop::Cop::Style::EmptyLambdaParameter < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::EmptyParameter
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/empty_lambda_parameter.rb#26
  def on_block(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/empty_lambda_parameter.rb#35
  def autocorrect(corrector, node); end
end

# source://rubocop//lib/rubocop/cop/style/empty_lambda_parameter.rb#24
RuboCop::Cop::Style::EmptyLambdaParameter::MSG = T.let(T.unsafe(nil), String)

# Checks for the use of a method, the result of which
# would be a literal, like an empty array, hash, or string.
#
# @example
#   # bad
#   a = Array.new
#   h = Hash.new
#   s = String.new
#
#   # good
#   a = []
#   h = {}
#   s = ''
#
# source://rubocop//lib/rubocop/cop/style/empty_literal.rb#19
class RuboCop::Cop::Style::EmptyLiteral < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/empty_literal.rb#31
  def array_node(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/empty_literal.rb#40
  def array_with_block(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/empty_literal.rb#34
  def hash_node(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/empty_literal.rb#43
  def hash_with_block(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/empty_literal.rb#50
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/style/empty_literal.rb#37
  def str_node(param0 = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/style/empty_literal.rb#111
  def correction(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/empty_literal.rb#74
  def enforce_double_quotes?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/empty_literal.rb#82
  def first_argument_unparenthesized?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/empty_literal.rb#129
  def frozen_strings?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/empty_literal.rb#102
  def offense_array_node?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/empty_literal.rb#106
  def offense_hash_node?(node); end

  # source://rubocop//lib/rubocop/cop/style/empty_literal.rb#60
  def offense_message(node); end

  # source://rubocop//lib/rubocop/cop/style/empty_literal.rb#70
  def preferred_string_literal; end

  # source://rubocop//lib/rubocop/cop/style/empty_literal.rb#89
  def replacement_range(node); end

  # source://rubocop//lib/rubocop/cop/style/empty_literal.rb#78
  def string_literals_config; end
end

# source://rubocop//lib/rubocop/cop/style/empty_literal.rb#24
RuboCop::Cop::Style::EmptyLiteral::ARR_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/empty_literal.rb#25
RuboCop::Cop::Style::EmptyLiteral::HASH_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/empty_literal.rb#28
RuboCop::Cop::Style::EmptyLiteral::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/empty_literal.rb#26
RuboCop::Cop::Style::EmptyLiteral::STR_MSG = T.let(T.unsafe(nil), String)

# Checks for the formatting of empty method definitions.
# By default it enforces empty method definitions to go on a single
# line (compact style), but it can be configured to enforce the `end`
# to go on its own line (expanded style).
#
# NOTE: A method definition is not considered empty if it contains
# comments.
#
# NOTE: Autocorrection will not be applied for the `compact` style
# if the resulting code is longer than the `Max` configuration for
# `Layout/LineLength`, but an offense will still be registered.
#
# @example EnforcedStyle: compact (default)
#   # bad
#   def foo(bar)
#   end
#
#   def self.foo(bar)
#   end
#
#   # good
#   def foo(bar); end
#
#   def foo(bar)
#   # baz
#   end
#
#   def self.foo(bar); end
# @example EnforcedStyle: expanded
#   # bad
#   def foo(bar); end
#
#   def self.foo(bar); end
#
#   # good
#   def foo(bar)
#   end
#
#   def self.foo(bar)
#   end
#
# source://rubocop//lib/rubocop/cop/style/empty_method.rb#47
class RuboCop::Cop::Style::EmptyMethod < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/empty_method.rb#54
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/style/empty_method.rb#54
  def on_defs(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/empty_method.rb#95
  def compact?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/empty_method.rb#103
  def compact_style?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/empty_method.rb#73
  def correct_style?(node); end

  # source://rubocop//lib/rubocop/cop/style/empty_method.rb#77
  def corrected(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/empty_method.rb#99
  def expanded?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/empty_method.rb#107
  def expanded_style?; end

  # source://rubocop//lib/rubocop/cop/style/empty_method.rb#89
  def joint(node); end

  # source://rubocop//lib/rubocop/cop/style/empty_method.rb#111
  def max_line_length; end

  # source://rubocop//lib/rubocop/cop/style/empty_method.rb#69
  def message(_range); end
end

# source://rubocop//lib/rubocop/cop/style/empty_method.rb#51
RuboCop::Cop::Style::EmptyMethod::MSG_COMPACT = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/empty_method.rb#52
RuboCop::Cop::Style::EmptyMethod::MSG_EXPANDED = T.let(T.unsafe(nil), String)

# Checks ensures source files have no utf-8 encoding comments.
#
# @example
#   # bad
#   # encoding: UTF-8
#   # coding: UTF-8
#   # -*- coding: UTF-8 -*-
#
# source://rubocop//lib/rubocop/cop/style/encoding.rb#12
class RuboCop::Cop::Style::Encoding < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/encoding.rb#20
  def on_new_investigation; end

  private

  # source://rubocop//lib/rubocop/cop/style/encoding.rb#32
  def comments; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/encoding.rb#43
  def offense?(comment); end

  # source://rubocop//lib/rubocop/cop/style/encoding.rb#47
  def register_offense(line_number, comment); end
end

# source://rubocop//lib/rubocop/cop/style/encoding.rb#17
RuboCop::Cop::Style::Encoding::ENCODING_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/style/encoding.rb#16
RuboCop::Cop::Style::Encoding::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/encoding.rb#18
RuboCop::Cop::Style::Encoding::SHEBANG = T.let(T.unsafe(nil), String)

# Checks for END blocks.
#
# @example
#   # bad
#   END { puts 'Goodbye!' }
#
#   # good
#   at_exit { puts 'Goodbye!' }
#
# source://rubocop//lib/rubocop/cop/style/end_block.rb#15
class RuboCop::Cop::Style::EndBlock < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/end_block.rb#20
  def on_postexe(node); end
end

# source://rubocop//lib/rubocop/cop/style/end_block.rb#18
RuboCop::Cop::Style::EndBlock::MSG = T.let(T.unsafe(nil), String)

# Checks for endless methods.
#
# It can enforce either the use of endless methods definitions
# for single-lined method bodies, or disallow endless methods.
#
# Other method definition types are not considered by this cop.
#
# The supported styles are:
#
# * allow_single_line (default) - only single line endless method definitions are allowed.
# * allow_always - all endless method definitions are allowed.
# * disallow - all endless method definitions are disallowed.
#
# NOTE: Incorrect endless method definitions will always be
# corrected to a multi-line definition.
#
# @example EnforcedStyle: allow_single_line (default)
#   # good
#   def my_method() = x
#
#   # bad, multi-line endless method
#   def my_method() = x.foo
#   .bar
#   .baz
# @example EnforcedStyle: allow_always
#   # good
#   def my_method() = x
#
#   # good
#   def my_method() = x.foo
#   .bar
#   .baz
# @example EnforcedStyle: disallow
#   # bad
#   def my_method() = x
#
#   # bad
#   def my_method() = x.foo
#   .bar
#   .baz
#
# source://rubocop//lib/rubocop/cop/style/endless_method.rb#49
class RuboCop::Cop::Style::EndlessMethod < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::TargetRubyVersion
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/endless_method.rb#60
  def on_def(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/endless_method.rb#95
  def arguments(node, missing = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/endless_method.rb#85
  def correct_to_multiline(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/endless_method.rb#70
  def handle_allow_style(node); end

  # source://rubocop//lib/rubocop/cop/style/endless_method.rb#79
  def handle_disallow_style(node); end
end

# source://rubocop//lib/rubocop/cop/style/endless_method.rb#56
RuboCop::Cop::Style::EndlessMethod::CORRECTION_STYLES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/endless_method.rb#57
RuboCop::Cop::Style::EndlessMethod::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/endless_method.rb#58
RuboCop::Cop::Style::EndlessMethod::MSG_MULTI_LINE = T.let(T.unsafe(nil), String)

# Checks for consistent usage of `ENV['HOME']`. If `nil` is used as
# the second argument of `ENV.fetch`, it is treated as a bad case like `ENV[]`.
#
# @example
#
#   # bad
#   ENV['HOME']
#   ENV.fetch('HOME', nil)
#
#   # good
#   Dir.home
#
#   # good
#   ENV.fetch('HOME', default)
#
# source://rubocop//lib/rubocop/cop/style/env_home.rb#31
class RuboCop::Cop::Style::EnvHome < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/env_home.rb#38
  def env_home?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/env_home.rb#45
  def on_send(node); end
end

# source://rubocop//lib/rubocop/cop/style/env_home.rb#34
RuboCop::Cop::Style::EnvHome::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/env_home.rb#35
RuboCop::Cop::Style::EnvHome::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Ensures that eval methods (`eval`, `instance_eval`, `class_eval`
# and `module_eval`) are given filename and line number values (`__FILE__`
# and `__LINE__`). This data is used to ensure that any errors raised
# within the evaluated code will be given the correct identification
# in a backtrace.
#
# The cop also checks that the line number given relative to `__LINE__` is
# correct.
#
# This cop will autocorrect incorrect or missing filename and line number
# values. However, if `eval` is called without a binding argument, the cop
# will not attempt to automatically add a binding, or add filename and
# line values.
#
# This cop works only when a string literal is given as a code string.
# No offense is reported if a string variable is given as below:
#
# @example
#   # bad
#   eval <<-RUBY
#   def do_something
#   end
#   RUBY
#
#   # bad
#   C.class_eval <<-RUBY
#   def do_something
#   end
#   RUBY
#
#   # good
#   eval <<-RUBY, binding, __FILE__, __LINE__ + 1
#   def do_something
#   end
#   RUBY
#
#   # good
#   C.class_eval <<-RUBY, __FILE__, __LINE__ + 1
#   def do_something
#   end
#   RUBY
# @example
#   # not checked
#   code = <<-RUBY
#   def do_something
#   end
#   RUBY
#   eval code
#
# source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#56
class RuboCop::Cop::Style::EvalWithLocation < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#74
  def line_with_offset?(param0 = T.unsafe(nil), param1, param2); end

  # source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#81
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#69
  def valid_eval_receiver?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#195
  def add_offense_for_different_line(node, line_node, line_diff); end

  # source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#142
  def add_offense_for_incorrect_line(method_name, line_node, sign, line_diff); end

  # source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#210
  def add_offense_for_missing_line(node, code); end

  # source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#217
  def add_offense_for_missing_location(node, code); end

  # source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#189
  def add_offense_for_same_line(node, line_node); end

  # source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#154
  def check_file(node, file_node); end

  # source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#167
  def check_line(node, code); end

  # source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#95
  def check_location(node, code); end

  # source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#202
  def expected_line(sign, line_diff); end

  # source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#122
  def file_and_line(node); end

  # source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#177
  def line_difference(line_node, code); end

  # source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#229
  def missing_line(node, code); end

  # source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#109
  def register_offense(node, &block); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#114
  def special_file_keyword?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#118
  def special_line_keyword?(node); end

  # source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#181
  def string_first_line(str_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#127
  def with_binding?(node); end

  # FIXME: It's a Style/ConditionalAssignment's false positive.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#133
  def with_lineno?(node); end
end

# source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#59
RuboCop::Cop::Style::EvalWithLocation::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#60
RuboCop::Cop::Style::EvalWithLocation::MSG_EVAL = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#61
RuboCop::Cop::Style::EvalWithLocation::MSG_INCORRECT_FILE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#63
RuboCop::Cop::Style::EvalWithLocation::MSG_INCORRECT_LINE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#66
RuboCop::Cop::Style::EvalWithLocation::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for places where `Integer#even?` or `Integer#odd?`
# can be used.
#
# @example
#
#   # bad
#   if x % 2 == 0
#   end
#
#   # good
#   if x.even?
#   end
#
# source://rubocop//lib/rubocop/cop/style/even_odd.rb#18
class RuboCop::Cop::Style::EvenOdd < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/even_odd.rb#25
  def even_odd_candidate?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/even_odd.rb#33
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/even_odd.rb#45
  def replacement_method(arg, method); end
end

# source://rubocop//lib/rubocop/cop/style/even_odd.rb#21
RuboCop::Cop::Style::EvenOdd::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/even_odd.rb#22
RuboCop::Cop::Style::EvenOdd::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for use of the `File.expand_path` arguments.
# Likewise, it also checks for the `Pathname.new` argument.
#
# Contrastive bad case and good case are alternately shown in
# the following examples.
#
# @example
#   # bad
#   File.expand_path('..', __FILE__)
#
#   # good
#   File.expand_path(__dir__)
#
#   # bad
#   File.expand_path('../..', __FILE__)
#
#   # good
#   File.expand_path('..', __dir__)
#
#   # bad
#   File.expand_path('.', __FILE__)
#
#   # good
#   File.expand_path(__FILE__)
#
#   # bad
#   Pathname(__FILE__).parent.expand_path
#
#   # good
#   Pathname(__dir__).expand_path
#
#   # bad
#   Pathname.new(__FILE__).parent.expand_path
#
#   # good
#   Pathname.new(__dir__).expand_path
#
# source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#43
class RuboCop::Cop::Style::ExpandPathArguments < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#58
  def file_expand_path(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#82
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#74
  def pathname_new_parent_expand_path(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#66
  def pathname_parent_expand_path(param0 = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#189
  def arguments_range(node); end

  # source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#100
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#135
  def autocorrect_expand_path(corrector, current_path, default_dir); end

  # source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#162
  def depth(current_path); end

  # source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#113
  def inspect_offense_for_expand_path(node, current_path, default_dir); end

  # source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#168
  def parent_path(current_path); end

  # source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#182
  def remove_parent_method(corrector, default_dir); end

  # source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#155
  def strip_surrounded_quotes!(path_string); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#109
  def unrecommended_argument?(default_dir); end
end

# source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#47
RuboCop::Cop::Style::ExpandPathArguments::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#49
RuboCop::Cop::Style::ExpandPathArguments::PATHNAME_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#51
RuboCop::Cop::Style::ExpandPathArguments::PATHNAME_NEW_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#55
RuboCop::Cop::Style::ExpandPathArguments::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Enforces the use of explicit block argument to avoid writing
# block literal that just passes its arguments to another block.
#
# NOTE: This cop only registers an offense if the block args match the
# yield args exactly.
#
# @example
#   # bad
#   def with_tmp_dir
#   Dir.mktmpdir do |tmp_dir|
#   Dir.chdir(tmp_dir) { |dir| yield dir } # block just passes arguments
#   end
#   end
#
#   # bad
#   def nine_times
#   9.times { yield }
#   end
#
#   # good
#   def with_tmp_dir(&block)
#   Dir.mktmpdir do |tmp_dir|
#   Dir.chdir(tmp_dir, &block)
#   end
#   end
#
#   with_tmp_dir do |dir|
#   puts "dir is accessible as a parameter and pwd is set: #{dir}"
#   end
#
#   # good
#   def nine_times(&block)
#   9.times(&block)
#   end
#
# source://rubocop//lib/rubocop/cop/style/explicit_block_argument.rb#41
class RuboCop::Cop::Style::ExplicitBlockArgument < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # @return [ExplicitBlockArgument] a new instance of ExplicitBlockArgument
  #
  # source://rubocop//lib/rubocop/cop/style/explicit_block_argument.rb#57
  def initialize(config = T.unsafe(nil), options = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/explicit_block_argument.rb#62
  def on_yield(node); end

  # source://rubocop//lib/rubocop/cop/style/explicit_block_argument.rb#49
  def yielding_block?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/style/explicit_block_argument.rb#108
  def add_block_argument(node, corrector, block_name); end

  # source://rubocop//lib/rubocop/cop/style/explicit_block_argument.rb#147
  def block_body_range(block_node, send_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/explicit_block_argument.rb#125
  def call_like?(node); end

  # source://rubocop//lib/rubocop/cop/style/explicit_block_argument.rb#137
  def correct_call_node(node, corrector, block_name); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/explicit_block_argument.rb#120
  def empty_arguments?(node); end

  # source://rubocop//lib/rubocop/cop/style/explicit_block_argument.rb#87
  def extract_block_name(def_node); end

  # source://rubocop//lib/rubocop/cop/style/explicit_block_argument.rb#129
  def insert_argument(node, corrector, block_name); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/explicit_block_argument.rb#95
  def yielding_arguments?(block_args, yield_args); end

  class << self
    # source://rubocop//lib/rubocop/cop/style/explicit_block_argument.rb#53
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop//lib/rubocop/cop/style/explicit_block_argument.rb#45
RuboCop::Cop::Style::ExplicitBlockArgument::MSG = T.let(T.unsafe(nil), String)

# Enforces consistency when using exponential notation
# for numbers in the code (eg 1.2e4). Different styles are supported:
#
# * `scientific` which enforces a mantissa between 1 (inclusive) and 10 (exclusive).
# * `engineering` which enforces the exponent to be a multiple of 3 and the mantissa
#   to be between 0.1 (inclusive) and 10 (exclusive).
# * `integral` which enforces the mantissa to always be a whole number without
#   trailing zeroes.
#
# @example EnforcedStyle: scientific (default)
#   # Enforces a mantissa between 1 (inclusive) and 10 (exclusive).
#
#   # bad
#   10e6
#   0.3e4
#   11.7e5
#   3.14e0
#
#   # good
#   1e7
#   3e3
#   1.17e6
#   3.14
# @example EnforcedStyle: engineering
#   # Enforces using multiple of 3 exponents,
#   # mantissa should be between 0.1 (inclusive) and 1000 (exclusive)
#
#   # bad
#   3.2e7
#   0.1e5
#   12e5
#   1232e6
#
#   # good
#   32e6
#   10e3
#   1.2e6
#   1.232e9
# @example EnforcedStyle: integral
#   # Enforces the mantissa to have no decimal part and no
#   # trailing zeroes.
#
#   # bad
#   3.2e7
#   0.1e5
#   120e4
#
#   # good
#   32e6
#   1e4
#   12e5
#
# source://rubocop//lib/rubocop/cop/style/exponential_notation.rb#60
class RuboCop::Cop::Style::ExponentialNotation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop//lib/rubocop/cop/style/exponential_notation.rb#68
  def on_float(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/exponential_notation.rb#79
  def engineering?(node); end

  # source://rubocop//lib/rubocop/cop/style/exponential_notation.rb#90
  def integral(node); end

  # source://rubocop//lib/rubocop/cop/style/exponential_notation.rb#110
  def message(_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/exponential_notation.rb#95
  def offense?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/exponential_notation.rb#74
  def scientific?(node); end
end

# source://rubocop//lib/rubocop/cop/style/exponential_notation.rb#62
RuboCop::Cop::Style::ExponentialNotation::MESSAGES = T.let(T.unsafe(nil), Hash)

# Suggests `ENV.fetch` for the replacement of `ENV[]`.
# `ENV[]` silently fails and returns `nil` when the environment variable is unset,
# which may cause unexpected behaviors when the developer forgets to set it.
# On the other hand, `ENV.fetch` raises KeyError or returns the explicitly
# specified default value.
#
# @example
#   # bad
#   ENV['X']
#   x = ENV['X']
#
#   # good
#   ENV.fetch('X')
#   x = ENV.fetch('X')
#
#   # also good
#   !ENV['X']
#   ENV['X'].some_method # (e.g. `.nil?`)
#
# source://rubocop//lib/rubocop/cop/style/fetch_env_var.rb#25
class RuboCop::Cop::Style::FetchEnvVar < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/fetch_env_var.rb#31
  def env_with_bracket?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/fetch_env_var.rb#35
  def on_send(node); end

  private

  # The following are allowed cases:
  #
  # - Used as a flag (e.g., `if ENV['X']` or `!ENV['X']`) because
  #   it simply checks whether the variable is set.
  # - Receiving a message with dot syntax, e.g. `ENV['X'].nil?`.
  # - `ENV['key']` assigned by logical AND/OR assignment.
  # - `ENV['key']` is the LHS of a `||`.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/fetch_env_var.rb#105
  def allowable_use?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/fetch_env_var.rb#48
  def allowed_var?(node); end

  # The following are allowed cases:
  #
  # - `ENV['key']` is a receiver of `||=`, e.g. `ENV['X'] ||= y`.
  # - `ENV['key']` is a receiver of `&&=`, e.g. `ENV['X'] &&= y`.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/fetch_env_var.rb#113
  def assigned?(node); end

  # Check if the node is a receiver and receives a message with dot syntax.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/fetch_env_var.rb#89
  def message_chained_with_dot?(node); end

  # source://rubocop//lib/rubocop/cop/style/fetch_env_var.rb#126
  def new_code(name_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/fetch_env_var.rb#84
  def offensive?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/fetch_env_var.rb#120
  def or_lhs?(node); end

  # Avoid offending in the following cases:
  # `ENV['key'] if ENV['key'] = x`
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/fetch_env_var.rb#80
  def partial_matched?(node, condition); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/fetch_env_var.rb#53
  def used_as_flag?(node); end

  # source://rubocop//lib/rubocop/cop/style/fetch_env_var.rb#60
  def used_if_condition_in_body(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/fetch_env_var.rb#69
  def used_in_condition?(node, condition); end
end

# source://rubocop//lib/rubocop/cop/style/fetch_env_var.rb#28
RuboCop::Cop::Style::FetchEnvVar::MSG = T.let(T.unsafe(nil), String)

# Prefer to use `File.empty?('path/to/file')` when checking if a file is empty.
#
# @example
#   # bad
#   File.zero?('path/to/file')
#   File.size('path/to/file') == 0
#   File.size('path/to/file') >= 0
#   File.size('path/to/file').zero?
#   File.read('path/to/file').empty?
#   File.binread('path/to/file') == ''
#   FileTest.zero?('path/to/file')
#
#   # good
#   File.empty?('path/to/file')
#   FileTest.empty?('path/to/file')
#
# source://rubocop//lib/rubocop/cop/style/file_empty.rb#27
class RuboCop::Cop::Style::FileEmpty < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop//lib/rubocop/cop/style/file_empty.rb#37
  def offensive?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/file_empty.rb#49
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/file_empty.rb#62
  def bang(node); end
end

# source://rubocop//lib/rubocop/cop/style/file_empty.rb#31
RuboCop::Cop::Style::FileEmpty::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/file_empty.rb#32
RuboCop::Cop::Style::FileEmpty::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Favor `File.(bin)read` convenience methods.
#
# @example
#   ## text mode
#   # bad
#   File.open(filename).read
#   File.open(filename, &:read)
#   File.open(filename) { |f| f.read }
#   File.open(filename) do |f|
#   f.read
#   end
#   File.open(filename, 'r').read
#   File.open(filename, 'r', &:read)
#   File.open(filename, 'r') do |f|
#   f.read
#   end
#
#   # good
#   File.read(filename)
# @example
#   ## binary mode
#   # bad
#   File.open(filename, 'rb').read
#   File.open(filename, 'rb', &:read)
#   File.open(filename, 'rb') do |f|
#   f.read
#   end
#
#   # good
#   File.binread(filename)
#
# source://rubocop//lib/rubocop/cop/style/file_read.rb#38
class RuboCop::Cop::Style::FileRead < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/file_read.rb#65
  def block_read?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/file_read.rb#49
  def file_open?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/file_read.rb#69
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/style/file_read.rb#60
  def send_read?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/style/file_read.rb#84
  def evidence(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/file_read.rb#100
  def file_open_read?(node); end

  # source://rubocop//lib/rubocop/cop/style/file_read.rb#106
  def read_method(mode); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/file_read.rb#92
  def read_node?(node, block_pass); end
end

# source://rubocop//lib/rubocop/cop/style/file_read.rb#42
RuboCop::Cop::Style::FileRead::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/file_read.rb#46
RuboCop::Cop::Style::FileRead::READ_FILE_START_TO_FINISH_MODES = T.let(T.unsafe(nil), Set)

# source://rubocop//lib/rubocop/cop/style/file_read.rb#44
RuboCop::Cop::Style::FileRead::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Favor `File.(bin)write` convenience methods.
#
# NOTE: There are different method signatures between `File.write` (class method)
# and `File#write` (instance method). The following case will be allowed because
# static analysis does not know the contents of the splat argument:
#
# [source,ruby]
# ----
# File.open(filename, 'w') do |f|
#   f.write(*objects)
# end
# ----
#
# @example
#   ## text mode
#   # bad
#   File.open(filename, 'w').write(content)
#   File.open(filename, 'w') do |f|
#   f.write(content)
#   end
#
#   # good
#   File.write(filename, content)
# @example
#   ## binary mode
#   # bad
#   File.open(filename, 'wb').write(content)
#   File.open(filename, 'wb') do |f|
#   f.write(content)
#   end
#
#   # good
#   File.binwrite(filename, content)
#
# source://rubocop//lib/rubocop/cop/style/file_write.rb#41
class RuboCop::Cop::Style::FileWrite < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/file_write.rb#68
  def block_write?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/file_write.rb#85
  def evidence(node); end

  # source://rubocop//lib/rubocop/cop/style/file_write.rb#52
  def file_open?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/file_write.rb#72
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/style/file_write.rb#63
  def send_write?(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  # @yield [content]
  #
  # source://rubocop//lib/rubocop/cop/style/file_write.rb#95
  def file_open_write?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/file_write.rb#123
  def heredoc?(write_node); end

  # source://rubocop//lib/rubocop/cop/style/file_write.rb#128
  def heredoc_range(first_argument); end

  # source://rubocop//lib/rubocop/cop/style/file_write.rb#108
  def replacement(mode, filename, content, write_node); end

  # source://rubocop//lib/rubocop/cop/style/file_write.rb#104
  def write_method(mode); end
end

# source://rubocop//lib/rubocop/cop/style/file_write.rb#45
RuboCop::Cop::Style::FileWrite::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/file_write.rb#47
RuboCop::Cop::Style::FileWrite::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Set)

# source://rubocop//lib/rubocop/cop/style/file_write.rb#49
RuboCop::Cop::Style::FileWrite::TRUNCATING_WRITE_MODES = T.let(T.unsafe(nil), Set)

# Checks for division with integers coerced to floats.
# It is recommended to either always use `fdiv` or coerce one side only.
# This cop also provides other options for code consistency.
#
# @example EnforcedStyle: single_coerce (default)
#   # bad
#   a.to_f / b.to_f
#
#   # good
#   a.to_f / b
#   a / b.to_f
# @example EnforcedStyle: left_coerce
#   # bad
#   a / b.to_f
#   a.to_f / b.to_f
#
#   # good
#   a.to_f / b
# @example EnforcedStyle: right_coerce
#   # bad
#   a.to_f / b
#   a.to_f / b.to_f
#
#   # good
#   a / b.to_f
# @example EnforcedStyle: fdiv
#   # bad
#   a / b.to_f
#   a.to_f / b
#   a.to_f / b.to_f
#
#   # good
#   a.fdiv(b)
#
# source://rubocop//lib/rubocop/cop/style/float_division.rb#53
class RuboCop::Cop::Style::FloatDivision < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/float_division.rb#79
  def any_coerce?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/float_division.rb#75
  def both_coerce?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/float_division.rb#71
  def left_coerce?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/float_division.rb#83
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/style/float_division.rb#67
  def right_coerce?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/style/float_division.rb#121
  def add_to_f_method(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/float_division.rb#130
  def correct_from_slash_to_fdiv(corrector, node, receiver, argument); end

  # source://rubocop//lib/rubocop/cop/style/float_division.rb#141
  def extract_receiver_source(node); end

  # source://rubocop//lib/rubocop/cop/style/float_division.rb#117
  def message(_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/float_division.rb#102
  def offense_condition?(node); end

  # source://rubocop//lib/rubocop/cop/style/float_division.rb#125
  def remove_to_f_method(corrector, send_node); end
end

# source://rubocop//lib/rubocop/cop/style/float_division.rb#57
RuboCop::Cop::Style::FloatDivision::MESSAGES = T.let(T.unsafe(nil), Hash)

# source://rubocop//lib/rubocop/cop/style/float_division.rb#64
RuboCop::Cop::Style::FloatDivision::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Looks for uses of the `for` keyword or `each` method. The
# preferred alternative is set in the EnforcedStyle configuration
# parameter. An `each` call with a block on a single line is always
# allowed.
#
# @example EnforcedStyle: each (default)
#   # bad
#   def foo
#   for n in [1, 2, 3] do
#   puts n
#   end
#   end
#
#   # good
#   def foo
#   [1, 2, 3].each do |n|
#   puts n
#   end
#   end
# @example EnforcedStyle: for
#   # bad
#   def foo
#   [1, 2, 3].each do |n|
#   puts n
#   end
#   end
#
#   # good
#   def foo
#   for n in [1, 2, 3] do
#   puts n
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/style/for.rb#45
class RuboCop::Cop::Style::For < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/for.rb#65
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/style/for.rb#54
  def on_for(node); end

  # source://rubocop//lib/rubocop/cop/style/for.rb#65
  def on_numblock(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/for.rb#82
  def suspect_enumerable?(node); end
end

# source://rubocop//lib/rubocop/cop/style/for.rb#50
RuboCop::Cop::Style::For::EACH_LENGTH = T.let(T.unsafe(nil), Integer)

# source://rubocop//lib/rubocop/cop/style/for.rb#51
RuboCop::Cop::Style::For::PREFER_EACH = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/for.rb#52
RuboCop::Cop::Style::For::PREFER_FOR = T.let(T.unsafe(nil), String)

# Enforces the use of a single string formatting utility.
# Valid options include Kernel#format, Kernel#sprintf and String#%.
#
# The detection of String#% cannot be implemented in a reliable
# manner for all cases, so only two scenarios are considered -
# if the first argument is a string literal and if the second
# argument is an array literal.
#
# @example EnforcedStyle: format (default)
#   # bad
#   puts sprintf('%10s', 'hoge')
#   puts '%10s' % 'hoge'
#
#   # good
#   puts format('%10s', 'hoge')
# @example EnforcedStyle: sprintf
#   # bad
#   puts format('%10s', 'hoge')
#   puts '%10s' % 'hoge'
#
#   # good
#   puts sprintf('%10s', 'hoge')
# @example EnforcedStyle: percent
#   # bad
#   puts format('%10s', 'hoge')
#   puts sprintf('%10s', 'hoge')
#
#   # good
#   puts '%10s' % 'hoge'
#
# source://rubocop//lib/rubocop/cop/style/format_string.rb#38
class RuboCop::Cop::Style::FormatString < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/format_string.rb#46
  def formatter(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/format_string.rb#59
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/style/format_string.rb#55
  def variable_argument?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/style/format_string.rb#81
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/format_string.rb#97
  def autocorrect_from_percent(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/format_string.rb#111
  def autocorrect_to_percent(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/format_string.rb#124
  def format_single_parameter(arg); end

  # source://rubocop//lib/rubocop/cop/style/format_string.rb#73
  def message(detected_style); end

  # source://rubocop//lib/rubocop/cop/style/format_string.rb#77
  def method_name(style_name); end
end

# source://rubocop//lib/rubocop/cop/style/format_string.rb#42
RuboCop::Cop::Style::FormatString::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/format_string.rb#43
RuboCop::Cop::Style::FormatString::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Use a consistent style for named format string tokens.
#
# NOTE: `unannotated` style cop only works for strings
# which are passed as arguments to those methods:
# `printf`, `sprintf`, `format`, `%`.
# The reason is that _unannotated_ format is very similar
# to encoded URLs or Date/Time formatting strings.
#
# This cop can be customized allowed methods with `AllowedMethods`.
# By default, there are no methods to allowed.
#
# It is allowed to contain unannotated token
# if the number of them is less than or equals to
# `MaxUnannotatedPlaceholdersAllowed`.
#
# @example AllowedPatterns: ['redirect']
#
#   # good
#   redirect('foo/%{bar_id}')
# @example EnforcedStyle: template
#
#   # bad
#   format('%<greeting>s', greeting: 'Hello')
#   format('%s', 'Hello')
#
#   # good
#   format('%{greeting}', greeting: 'Hello')
# @example EnforcedStyle: unannotated
#
#   # bad
#   format('%<greeting>s', greeting: 'Hello')
#   format('%{greeting}', greeting: 'Hello')
#
#   # good
#   format('%s', 'Hello')
# @example MaxUnannotatedPlaceholdersAllowed: 0
#
#   # bad
#   format('%06d', 10)
#   format('%s %s.', 'Hello', 'world')
#
#   # good
#   format('%<number>06d', number: 10)
# @example MaxUnannotatedPlaceholdersAllowed: 1 (default)
#
#   # bad
#   format('%s %s.', 'Hello', 'world')
#
#   # good
#   format('%06d', 10)
# @example AllowedMethods: [] (default)
#
#   # bad
#   redirect('foo/%{bar_id}')
# @example AllowedMethods: [redirect]
#
#   # good
#   redirect('foo/%{bar_id}')
# @example AllowedPatterns: [] (default)
#
#   # bad
#   redirect('foo/%{bar_id}')
# @example EnforcedStyle: annotated (default)
#
#   # bad
#   format('%{greeting}', greeting: 'Hello')
#   format('%s', 'Hello')
#
#   # good
#   format('%<greeting>s', greeting: 'Hello')
#
# source://rubocop//lib/rubocop/cop/style/format_string_token.rb#85
class RuboCop::Cop::Style::FormatStringToken < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::AllowedPattern
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/format_string_token.rb#106
  def format_string_in_typical_context?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/format_string_token.rb#91
  def on_str(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/format_string_token.rb#213
  def allowed_unannotated?(detections); end

  # source://rubocop//lib/rubocop/cop/style/format_string_token.rb#139
  def autocorrect_sequence(corrector, detected_sequence, token_range); end

  # source://rubocop//lib/rubocop/cop/style/format_string_token.rb#124
  def check_sequence(detected_sequence, token_range); end

  # source://rubocop//lib/rubocop/cop/style/format_string_token.rb#203
  def collect_detections(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/format_string_token.rb#135
  def correctable_sequence?(detected_type); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/format_string_token.rb#113
  def format_string_token?(node); end

  # source://rubocop//lib/rubocop/cop/style/format_string_token.rb#222
  def max_unannotated_placeholders_allowed; end

  # source://rubocop//lib/rubocop/cop/style/format_string_token.rb#160
  def message(detected_style); end

  # source://rubocop//lib/rubocop/cop/style/format_string_token.rb#165
  def message_text(style); end

  # source://rubocop//lib/rubocop/cop/style/format_string_token.rb#180
  def str_contents(source_map); end

  # source://rubocop//lib/rubocop/cop/style/format_string_token.rb#190
  def token_ranges(contents); end

  # source://rubocop//lib/rubocop/cop/style/format_string_token.rb#174
  def tokens(str_node, &block); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/format_string_token.rb#156
  def unannotated_format?(node, detected_style); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/format_string_token.rb#117
  def use_allowed_method?(node); end
end

# Helps you transition from mutable string literals
# to frozen string literals.
# of files to enable frozen string literals. Frozen string literals may be
# default in future Ruby. The comment will be added below a shebang and
# encoding comment. The frozen string literal comment is only valid in Ruby 2.3+.
#
# Note that the cop will accept files where the comment exists but is set
# to `false` instead of `true`.
#
# To require a blank line after this comment, please see
# `Layout/EmptyLineAfterMagicComment` cop.
#
# @example EnforcedStyle: always (default)
#   # The `always` style will always add the frozen string literal comment
#   # to a file, regardless of the Ruby version or if `freeze` or `<<` are
#   # called on a string literal.
#   # bad
#   module Bar
#   # ...
#   end
#
#   # good
#   # frozen_string_literal: true
#
#   module Bar
#   # ...
#   end
#
#   # good
#   # frozen_string_literal: false
#
#   module Bar
#   # ...
#   end
# @example EnforcedStyle: never
#   # The `never` will enforce that the frozen string literal comment does
#   # not exist in a file.
#   # bad
#   # frozen_string_literal: true
#
#   module Baz
#   # ...
#   end
#
#   # good
#   module Baz
#   # ...
#   end
# @example EnforcedStyle: always_true
#   # The `always_true` style enforces that the frozen string literal
#   # comment is set to `true`. This is a stricter option than `always`
#   # and forces projects to use frozen string literals.
#   # bad
#   # frozen_string_literal: false
#
#   module Baz
#   # ...
#   end
#
#   # bad
#   module Baz
#   # ...
#   end
#
#   # good
#   # frozen_string_literal: true
#
#   module Bar
#   # ...
#   end
#
# source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#84
class RuboCop::Cop::Style::FrozenStringLiteralComment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#99
  def on_new_investigation; end

  private

  # source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#176
  def disabled_offense(processed_source); end

  # source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#188
  def enable_comment(corrector); end

  # source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#120
  def ensure_comment(processed_source); end

  # source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#126
  def ensure_enabled_comment(processed_source); end

  # source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#114
  def ensure_no_comment(processed_source); end

  # source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#212
  def following_comment; end

  # source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#150
  def frozen_string_literal_comment(processed_source); end

  # source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#194
  def insert_comment(corrector); end

  # source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#137
  def last_special_comment(processed_source); end

  # source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#204
  def line_range(line); end

  # source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#156
  def missing_offense(processed_source); end

  # source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#162
  def missing_true_offense(processed_source); end

  # source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#208
  def preceding_comment; end

  # source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#184
  def remove_comment(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#168
  def unnecessary_comment_offense(processed_source); end
end

# source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#96
RuboCop::Cop::Style::FrozenStringLiteralComment::MSG_DISABLED = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#94
RuboCop::Cop::Style::FrozenStringLiteralComment::MSG_MISSING = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#93
RuboCop::Cop::Style::FrozenStringLiteralComment::MSG_MISSING_TRUE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#95
RuboCop::Cop::Style::FrozenStringLiteralComment::MSG_UNNECESSARY = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#97
RuboCop::Cop::Style::FrozenStringLiteralComment::SHEBANG = T.let(T.unsafe(nil), String)

# Enforces the use of `$stdout/$stderr/$stdin` instead of `STDOUT/STDERR/STDIN`.
# `STDOUT/STDERR/STDIN` are constants, and while you can actually
# reassign (possibly to redirect some stream) constants in Ruby, you'll get
# an interpreter warning if you do so.
#
# @example
#   # bad
#   STDOUT.puts('hello')
#
#   hash = { out: STDOUT, key: value }
#
#   def m(out = STDOUT)
#   out.puts('hello')
#   end
#
#   # good
#   $stdout.puts('hello')
#
#   hash = { out: $stdout, key: value }
#
#   def m(out = $stdout)
#   out.puts('hello')
#   end
#
# source://rubocop//lib/rubocop/cop/style/global_std_stream.rb#34
class RuboCop::Cop::Style::GlobalStdStream < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/global_std_stream.rb#42
  def const_to_gvar_assignment?(param0 = T.unsafe(nil), param1); end

  # source://rubocop//lib/rubocop/cop/style/global_std_stream.rb#46
  def on_const(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/global_std_stream.rb#64
  def gvar_name(const_name); end

  # source://rubocop//lib/rubocop/cop/style/global_std_stream.rb#60
  def message(const_name); end
end

# source://rubocop//lib/rubocop/cop/style/global_std_stream.rb#37
RuboCop::Cop::Style::GlobalStdStream::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/global_std_stream.rb#39
RuboCop::Cop::Style::GlobalStdStream::STD_STREAMS = T.let(T.unsafe(nil), Set)

# Looks for uses of global variables.
# It does not report offenses for built-in global variables.
# Built-in global variables are allowed by default. Additionally
# users can allow additional variables via the AllowedVariables option.
#
# Note that backreferences like $1, $2, etc are not global variables.
#
# @example
#   # bad
#   $foo = 2
#   bar = $foo + 5
#
#   # good
#   FOO = 2
#   foo = 2
#   $stdin.read
#
# source://rubocop//lib/rubocop/cop/style/global_vars.rb#22
class RuboCop::Cop::Style::GlobalVars < ::RuboCop::Cop::Base
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/global_vars.rb#60
  def allowed_var?(global_var); end

  # source://rubocop//lib/rubocop/cop/style/global_vars.rb#72
  def check(node); end

  # source://rubocop//lib/rubocop/cop/style/global_vars.rb#64
  def on_gvar(node); end

  # source://rubocop//lib/rubocop/cop/style/global_vars.rb#68
  def on_gvasgn(node); end

  # source://rubocop//lib/rubocop/cop/style/global_vars.rb#56
  def user_vars; end
end

# built-in global variables and their English aliases
# https://www.zenspider.com/ruby/quickref.html
#
# source://rubocop//lib/rubocop/cop/style/global_vars.rb#27
RuboCop::Cop::Style::GlobalVars::BUILT_IN_VARS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/global_vars.rb#23
RuboCop::Cop::Style::GlobalVars::MSG = T.let(T.unsafe(nil), String)

# Use a guard clause instead of wrapping the code inside a conditional
# expression
#
# A condition with an `elsif` or `else` branch is allowed unless
# one of `return`, `break`, `next`, `raise`, or `fail` is used
# in the body of the conditional expression.
#
# NOTE: Autocorrect works in most cases except with if-else statements
#   that contain logical operators such as `foo || raise('exception')`
#
# @example
#   # bad
#   def test
#   if something
#   work
#   end
#   end
#
#   # good
#   def test
#   return unless something
#
#   work
#   end
#
#   # also good
#   def test
#   work if something
#   end
#
#   # bad
#   if something
#   raise 'exception'
#   else
#   ok
#   end
#
#   # good
#   raise 'exception' if something
#   ok
#
#   # bad
#   if something
#   foo || raise('exception')
#   else
#   ok
#   end
#
#   # good
#   foo || raise('exception') if something
#   ok
# @example AllowConsecutiveConditionals: false (default)
#   # bad
#   def test
#   if foo?
#   work
#   end
#
#   if bar?  # <- reports an offense
#   work
#   end
#   end
# @example AllowConsecutiveConditionals: true
#   # good
#   def test
#   if foo?
#   work
#   end
#
#   if bar?
#   work
#   end
#   end
#
#   # bad
#   def test
#   if foo?
#   work
#   end
#
#   do_something
#
#   if bar?  # <- reports an offense
#   work
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/style/guard_clause.rb#95
class RuboCop::Cop::Style::GuardClause < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::LineLengthHelp
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::MinBodyLength
  include ::RuboCop::Cop::StatementModifier
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/guard_clause.rb#104
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/style/guard_clause.rb#104
  def on_defs(node); end

  # source://rubocop//lib/rubocop/cop/style/guard_clause.rb#113
  def on_if(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/guard_clause.rb#247
  def accepted_form?(node, ending: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/guard_clause.rb#255
  def accepted_if?(node, ending); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/guard_clause.rb#269
  def allowed_consecutive_conditionals?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/guard_clause.rb#237
  def and_or_guard_clause?(guard_clause); end

  # source://rubocop//lib/rubocop/cop/style/guard_clause.rb#184
  def autocorrect(corrector, node, condition, replacement, guard); end

  # source://rubocop//lib/rubocop/cop/style/guard_clause.rb#208
  def autocorrect_heredoc_argument(corrector, node, heredoc_branch, leave_branch, guard); end

  # source://rubocop//lib/rubocop/cop/style/guard_clause.rb#133
  def check_ending_body(body); end

  # source://rubocop//lib/rubocop/cop/style/guard_clause.rb#144
  def check_ending_if(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/guard_clause.rb#154
  def consecutive_conditionals?(parent, node); end

  # source://rubocop//lib/rubocop/cop/style/guard_clause.rb#229
  def guard_clause_source(guard_clause); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/guard_clause.rb#204
  def heredoc?(argument); end

  # source://rubocop//lib/rubocop/cop/style/guard_clause.rb#220
  def range_of_branch_to_remove(node, guard); end

  # source://rubocop//lib/rubocop/cop/style/guard_clause.rb#162
  def register_offense(node, scope_exiting_keyword, conditional_keyword, guard = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/guard_clause.rb#265
  def remove_whole_lines(corrector, range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/guard_clause.rb#242
  def too_long_for_single_line?(node, example); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/guard_clause.rb#251
  def trivial?(node); end
end

# source://rubocop//lib/rubocop/cop/style/guard_clause.rb#101
RuboCop::Cop::Style::GuardClause::MSG = T.let(T.unsafe(nil), String)

# Checks for presence or absence of braces around hash literal as a last
# array item depending on configuration.
#
# NOTE: This cop will ignore arrays where all items are hashes, regardless of
# EnforcedStyle.
#
# @example EnforcedStyle: braces (default)
#   # bad
#   [1, 2, one: 1, two: 2]
#
#   # good
#   [1, 2, { one: 1, two: 2 }]
#
#   # good
#   [{ one: 1 }, { two: 2 }]
# @example EnforcedStyle: no_braces
#   # bad
#   [1, 2, { one: 1, two: 2 }]
#
#   # good
#   [1, 2, one: 1, two: 2]
#
#   # good
#   [{ one: 1 }, { two: 2 }]
#
# source://rubocop//lib/rubocop/cop/style/hash_as_last_array_item.rb#31
class RuboCop::Cop::Style::HashAsLastArrayItem < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/hash_as_last_array_item.rb#36
  def on_hash(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/hash_as_last_array_item.rb#85
  def braces_style?; end

  # source://rubocop//lib/rubocop/cop/style/hash_as_last_array_item.rb#66
  def check_braces(node); end

  # source://rubocop//lib/rubocop/cop/style/hash_as_last_array_item.rb#74
  def check_no_braces(node); end

  # source://rubocop//lib/rubocop/cop/style/hash_as_last_array_item.rb#50
  def containing_array(hash_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/hash_as_last_array_item.rb#61
  def explicit_array?(array); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/hash_as_last_array_item.rb#55
  def last_array_item?(array, node); end

  # source://rubocop//lib/rubocop/cop/style/hash_as_last_array_item.rb#89
  def remove_last_element_trailing_comma(corrector, node); end
end

# Checks the usage of pre-2.1 `Hash[args]` method of converting enumerables and
# sequences of values to hashes.
#
# Correction code from splat argument (`Hash[*ary]`) is not simply determined. For example,
# `Hash[*ary]` can be replaced with `ary.each_slice(2).to_h` but it will be complicated.
# So, `AllowSplatArgument` option is true by default to allow splat argument for simple code.
#
# @example
#   # bad
#   Hash[ary]
#
#   # good
#   ary.to_h
#
#   # bad
#   Hash[key1, value1, key2, value2]
#
#   # good
#   {key1 => value1, key2 => value2}
# @example AllowSplatArgument: true (default)
#   # good
#   Hash[*ary]
# @example AllowSplatArgument: false
#   # bad
#   Hash[*ary]
#
# source://rubocop//lib/rubocop/cop/style/hash_conversion.rb#34
class RuboCop::Cop::Style::HashConversion < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/hash_conversion.rb#44
  def hash_from_array?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/hash_conversion.rb#46
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/hash_conversion.rb#128
  def allowed_splat_argument?; end

  # source://rubocop//lib/rubocop/cop/style/hash_conversion.rb#121
  def args_to_hash(args); end

  # source://rubocop//lib/rubocop/cop/style/hash_conversion.rb#108
  def multi_argument(node); end

  # source://rubocop//lib/rubocop/cop/style/hash_conversion.rb#84
  def register_offense_for_hash(node, hash_argument); end

  # source://rubocop//lib/rubocop/cop/style/hash_conversion.rb#93
  def register_offense_for_zip_method(node, zip_method); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/hash_conversion.rb#103
  def requires_parens?(node); end

  # source://rubocop//lib/rubocop/cop/style/hash_conversion.rb#61
  def single_argument(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/hash_conversion.rb#78
  def use_zip_method_without_argument?(first_argument); end
end

# source://rubocop//lib/rubocop/cop/style/hash_conversion.rb#39
RuboCop::Cop::Style::HashConversion::MSG_LITERAL_HASH_ARG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/hash_conversion.rb#38
RuboCop::Cop::Style::HashConversion::MSG_LITERAL_MULTI_ARG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/hash_conversion.rb#40
RuboCop::Cop::Style::HashConversion::MSG_SPLAT = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/hash_conversion.rb#37
RuboCop::Cop::Style::HashConversion::MSG_TO_H = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/hash_conversion.rb#41
RuboCop::Cop::Style::HashConversion::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for uses of `each_key` and `each_value` Hash methods.
#
# NOTE: If you have an array of two-element arrays, you can put
#   parentheses around the block arguments to indicate that you're not
#   working with a hash, and suppress RuboCop offenses.
#
# @example
#   # bad
#   hash.keys.each { |k| p k }
#   hash.values.each { |v| p v }
#
#   # good
#   hash.each_key { |k| p k }
#   hash.each_value { |v| p v }
# @example AllowedReceivers: ['execute']
#   # good
#   execute(sql).keys.each { |v| p v }
#   execute(sql).values.each { |v| p v }
#
# source://rubocop//lib/rubocop/cop/style/hash_each_methods.rb#30
class RuboCop::Cop::Style::HashEachMethods < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Lint::UnusedArgument
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/hash_each_methods.rb#37
  def kv_each(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/hash_each_methods.rb#42
  def kv_each_with_block_pass(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/hash_each_methods.rb#46
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/style/hash_each_methods.rb#54
  def on_block_pass(node); end

  # source://rubocop//lib/rubocop/cop/style/hash_each_methods.rb#46
  def on_numblock(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/hash_each_methods.rb#120
  def allowed_receiver?(receiver); end

  # source://rubocop//lib/rubocop/cop/style/hash_each_methods.rb#138
  def allowed_receivers; end

  # source://rubocop//lib/rubocop/cop/style/hash_each_methods.rb#85
  def check_argument(variable); end

  # source://rubocop//lib/rubocop/cop/style/hash_each_methods.rb#109
  def correct_args(node, corrector); end

  # source://rubocop//lib/rubocop/cop/style/hash_each_methods.rb#95
  def correct_implicit(node, corrector, method_name); end

  # source://rubocop//lib/rubocop/cop/style/hash_each_methods.rb#100
  def correct_key_value_each(node, corrector); end

  # source://rubocop//lib/rubocop/cop/style/hash_each_methods.rb#81
  def format_message(method_name); end

  # source://rubocop//lib/rubocop/cop/style/hash_each_methods.rb#116
  def kv_range(outer_node); end

  # source://rubocop//lib/rubocop/cop/style/hash_each_methods.rb#126
  def receiver_name(receiver); end

  # source://rubocop//lib/rubocop/cop/style/hash_each_methods.rb#62
  def register_kv_offense(target, method); end

  # source://rubocop//lib/rubocop/cop/style/hash_each_methods.rb#71
  def register_kv_with_block_pass_offense(node, target, method); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/hash_each_methods.rb#91
  def used?(arg); end
end

# source://rubocop//lib/rubocop/cop/style/hash_each_methods.rb#34
RuboCop::Cop::Style::HashEachMethods::MSG = T.let(T.unsafe(nil), String)

# Checks for usages of `Hash#reject`, `Hash#select`, and `Hash#filter` methods
# that can be replaced with `Hash#except` method.
#
# This cop should only be enabled on Ruby version 3.0 or higher.
# (`Hash#except` was added in Ruby 3.0.)
#
# For safe detection, it is limited to commonly used string and symbol comparisons
# when used `==`.
# And do not check `Hash#delete_if` and `Hash#keep_if` to change receiver object.
#
# @example
#
#   # bad
#   {foo: 1, bar: 2, baz: 3}.reject {|k, v| k == :bar }
#   {foo: 1, bar: 2, baz: 3}.select {|k, v| k != :bar }
#   {foo: 1, bar: 2, baz: 3}.filter {|k, v| k != :bar }
#   {foo: 1, bar: 2, baz: 3}.reject {|k, v| %i[foo bar].include?(k) }
#   {foo: 1, bar: 2, baz: 3}.select {|k, v| !%i[foo bar].include?(k) }
#   {foo: 1, bar: 2, baz: 3}.filter {|k, v| !%i[foo bar].include?(k) }
#
#   # good
#   {foo: 1, bar: 2, baz: 3}.except(:bar)
#
# source://rubocop//lib/rubocop/cop/style/hash_except.rb#33
class RuboCop::Cop::Style::HashExcept < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::TargetRubyVersion
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/hash_except.rb#60
  def bad_method_with_active_support?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/hash_except.rb#44
  def bad_method_with_poro?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/hash_except.rb#75
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/hash_except.rb#92
  def bad_method?(block); end

  # source://rubocop//lib/rubocop/cop/style/hash_except.rb#154
  def decorate_source(value); end

  # source://rubocop//lib/rubocop/cop/style/hash_except.rb#162
  def except_key(node); end

  # source://rubocop//lib/rubocop/cop/style/hash_except.rb#141
  def except_key_source(key); end

  # source://rubocop//lib/rubocop/cop/style/hash_except.rb#135
  def extract_body_if_negated(body); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/hash_except.rb#116
  def included?(negated, body); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/hash_except.rb#120
  def not_included?(negated, body); end

  # source://rubocop//lib/rubocop/cop/style/hash_except.rb#171
  def offense_range(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/hash_except.rb#124
  def safe_to_register_offense?(block, except_key); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/hash_except.rb#100
  def semantically_except_method?(send, block); end
end

# source://rubocop//lib/rubocop/cop/style/hash_except.rb#40
RuboCop::Cop::Style::HashExcept::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/hash_except.rb#41
RuboCop::Cop::Style::HashExcept::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for places where `case-when` represents a simple 1:1
# mapping and can be replaced with a hash lookup.
#
# @example MinBranchesCount: 3 (default)
#   # bad
#   case country
#   when 'europe'
#   'http://eu.example.com'
#   when 'america'
#   'http://us.example.com'
#   when 'australia'
#   'http://au.example.com'
#   end
#
#   # good
#   SITES = {
#   'europe'    => 'http://eu.example.com',
#   'america'   => 'http://us.example.com',
#   'australia' => 'http://au.example.com'
#   }
#   SITES[country]
# @example MinBranchesCount: 4
#   # good
#   case country
#   when 'europe'
#   'http://eu.example.com'
#   when 'america'
#   'http://us.example.com'
#   when 'australia'
#   'http://au.example.com'
#   end
#
# source://rubocop//lib/rubocop/cop/style/hash_like_case.rb#39
class RuboCop::Cop::Style::HashLikeCase < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::MinBranchesCount

  # source://rubocop//lib/rubocop/cop/style/hash_like_case.rb#45
  def hash_like_case?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/hash_like_case.rb#53
  def on_case(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/hash_like_case.rb#65
  def nodes_of_same_type?(nodes); end
end

# source://rubocop//lib/rubocop/cop/style/hash_like_case.rb#42
RuboCop::Cop::Style::HashLikeCase::MSG = T.let(T.unsafe(nil), String)

# Checks hash literal syntax.
#
# It can enforce either the use of the class hash rocket syntax or
# the use of the newer Ruby 1.9 syntax (when applicable).
#
# A separate offense is registered for each problematic pair.
#
# The supported styles are:
#
# * ruby19 - forces use of the 1.9 syntax (e.g. `{a: 1}`) when hashes have
# all symbols for keys
# * hash_rockets - forces use of hash rockets for all hashes
# * no_mixed_keys - simply checks for hashes with mixed syntaxes
# * ruby19_no_mixed_keys - forces use of ruby 1.9 syntax and forbids mixed
# syntax hashes
#
# This cop has `EnforcedShorthandSyntax` option.
# It can enforce either the use of the explicit hash value syntax or
# the use of Ruby 3.1's hash value shorthand syntax.
#
# The supported styles are:
#
# * always - forces use of the 3.1 syntax (e.g. {foo:})
# * never - forces use of explicit hash literal value
# * either - accepts both shorthand and explicit use of hash literal value
# * consistent - forces use of the 3.1 syntax only if all values can be omitted in the hash
#
# @example EnforcedShorthandSyntax: consistent
#
#   # bad - `foo` and `bar` values can be omitted
#   {foo: foo, bar: bar}
#
#   # bad - `bar` value can be omitted
#   {foo:, bar: bar}
#
#   # bad - mixed syntaxes
#   {foo:, bar: baz}
#
#   # good
#   {foo:, bar:}
#
#   # good - can't omit `baz`
#   {foo: foo, bar: baz}
# @example EnforcedStyle: hash_rockets
#   # bad
#   {a: 1, b: 2}
#   {c: 1, 'd' => 5}
#
#   # good
#   {:a => 1, :b => 2}
# @example EnforcedStyle: no_mixed_keys
#   # bad
#   {:a => 1, b: 2}
#   {c: 1, 'd' => 2}
#
#   # good
#   {:a => 1, :b => 2}
#   {c: 1, d: 2}
# @example EnforcedStyle: ruby19_no_mixed_keys
#   # bad
#   {:a => 1, :b => 2}
#   {c: 2, 'd' => 3} # should just use hash rockets
#
#   # good
#   {a: 1, b: 2}
#   {:c => 3, 'd' => 4}
# @example EnforcedShorthandSyntax: always (default)
#
#   # bad
#   {foo: foo, bar: bar}
#
#   # good
#   {foo:, bar:}
# @example EnforcedShorthandSyntax: never
#
#   # bad
#   {foo:, bar:}
#
#   # good
#   {foo: foo, bar: bar}
# @example EnforcedShorthandSyntax: either
#
#   # good
#   {foo: foo, bar: bar}
#
#   # good
#   {foo: foo, bar:}
#
#   # good
#   {foo:, bar:}
# @example EnforcedStyle: ruby19 (default)
#   # bad
#   {:a => 2}
#   {b: 1, :c => 2}
#
#   # good
#   {a: 2, b: 1}
#   {:c => 2, 'd' => 2} # acceptable since 'd' isn't a symbol
#   {d: 1, 'e' => 2} # technically not forbidden
#
# source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#113
class RuboCop::Cop::Style::HashSyntax < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::HashShorthandSyntax
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#167
  def alternative_style; end

  # source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#145
  def hash_rockets_check(pairs); end

  # source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#159
  def no_mixed_keys_check(pairs); end

  # source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#123
  def on_hash(node); end

  # source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#141
  def ruby19_check(pairs); end

  # source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#149
  def ruby19_no_mixed_keys_check(pairs); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#198
  def acceptable_19_syntax_symbol?(sym_name); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#252
  def argument_without_space?(node); end

  # source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#178
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#256
  def autocorrect_hash_rockets(corrector, pair_node); end

  # source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#265
  def autocorrect_no_mixed_keys(corrector, pair_node); end

  # source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#231
  def autocorrect_ruby19(corrector, pair_node); end

  # source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#216
  def check(pairs, delim, msg); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#273
  def force_hash_rockets?(pairs); end

  # source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#244
  def range_for_autocorrect_ruby19(pair_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#188
  def sym_indices?(pairs); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#192
  def word_symbol_pair?(pair); end
end

# source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#119
RuboCop::Cop::Style::HashSyntax::MSG_19 = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#121
RuboCop::Cop::Style::HashSyntax::MSG_HASH_ROCKETS = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#120
RuboCop::Cop::Style::HashSyntax::MSG_NO_MIXED_KEYS = T.let(T.unsafe(nil), String)

# Looks for uses of `_.each_with_object({}) {...}`,
# `_.map {...}.to_h`, and `Hash[_.map {...}]` that are actually just
# transforming the keys of a hash, and tries to use a simpler & faster
# call to `transform_keys` instead.
# It should only be enabled on Ruby version 2.5 or newer.
# (`transform_keys` was added in Ruby 2.5.)
#
# @example
#   # bad
#   {a: 1, b: 2}.each_with_object({}) { |(k, v), h| h[foo(k)] = v }
#   Hash[{a: 1, b: 2}.collect { |k, v| [foo(k), v] }]
#   {a: 1, b: 2}.map { |k, v| [k.to_s, v] }.to_h
#   {a: 1, b: 2}.to_h { |k, v| [k.to_s, v] }
#
#   # good
#   {a: 1, b: 2}.transform_keys { |k| foo(k) }
#   {a: 1, b: 2}.transform_keys { |k| k.to_s }
#
# source://rubocop//lib/rubocop/cop/style/hash_transform_keys.rb#28
class RuboCop::Cop::Style::HashTransformKeys < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::HashTransformMethod
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop//lib/rubocop/cop/style/hash_transform_keys.rb#36
  def on_bad_each_with_object(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/hash_transform_keys.rb#48
  def on_bad_hash_brackets_map(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/hash_transform_keys.rb#61
  def on_bad_map_to_h(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/hash_transform_keys.rb#73
  def on_bad_to_h(param0 = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/style/hash_transform_keys.rb#84
  def extract_captures(match); end

  # source://rubocop//lib/rubocop/cop/style/hash_transform_keys.rb#89
  def new_method_name; end
end

# Looks for uses of `_.each_with_object({}) {...}`,
# `_.map {...}.to_h`, and `Hash[_.map {...}]` that are actually just
# transforming the values of a hash, and tries to use a simpler & faster
# call to `transform_values` instead.
#
# @example
#   # bad
#   {a: 1, b: 2}.each_with_object({}) { |(k, v), h| h[k] = foo(v) }
#   Hash[{a: 1, b: 2}.collect { |k, v| [k, foo(v)] }]
#   {a: 1, b: 2}.map { |k, v| [k, v * v] }.to_h
#   {a: 1, b: 2}.to_h { |k, v| [k, v * v] }
#
#   # good
#   {a: 1, b: 2}.transform_values { |v| foo(v) }
#   {a: 1, b: 2}.transform_values { |v| v * v }
#
# source://rubocop//lib/rubocop/cop/style/hash_transform_values.rb#26
class RuboCop::Cop::Style::HashTransformValues < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::HashTransformMethod
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop//lib/rubocop/cop/style/hash_transform_values.rb#34
  def on_bad_each_with_object(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/hash_transform_values.rb#46
  def on_bad_hash_brackets_map(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/hash_transform_values.rb#59
  def on_bad_map_to_h(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/hash_transform_values.rb#71
  def on_bad_to_h(param0 = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/style/hash_transform_values.rb#82
  def extract_captures(match); end

  # source://rubocop//lib/rubocop/cop/style/hash_transform_values.rb#87
  def new_method_name; end
end

# Checks for identical expressions at the beginning or end of
# each branch of a conditional expression. Such expressions should normally
# be placed outside the conditional expression - before or after it.
#
# NOTE: The cop is poorly named and some people might think that it actually
# checks for duplicated conditional branches. The name will probably be changed
# in a future major RuboCop release.
#
# @example
#   # bad
#   if condition
#   do_x
#   do_z
#   else
#   do_y
#   do_z
#   end
#
#   # good
#   if condition
#   do_x
#   else
#   do_y
#   end
#   do_z
#
#   # bad
#   if condition
#   do_z
#   do_x
#   else
#   do_z
#   do_y
#   end
#
#   # good
#   do_z
#   if condition
#   do_x
#   else
#   do_y
#   end
#
#   # bad
#   case foo
#   when 1
#   do_x
#   when 2
#   do_x
#   else
#   do_x
#   end
#
#   # good
#   case foo
#   when 1
#   do_x
#   do_y
#   when 2
#   # nothing
#   else
#   do_x
#   do_z
#   end
#
#   # bad
#   case foo
#   in 1
#   do_x
#   in 2
#   do_x
#   else
#   do_x
#   end
#
#   # good
#   case foo
#   in 1
#   do_x
#   do_y
#   in 2
#   # nothing
#   else
#   do_x
#   do_z
#   end
#
# source://rubocop//lib/rubocop/cop/style/identical_conditional_branches.rb#110
class RuboCop::Cop::Style::IdenticalConditionalBranches < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/identical_conditional_branches.rb#123
  def on_case(node); end

  # source://rubocop//lib/rubocop/cop/style/identical_conditional_branches.rb#130
  def on_case_match(node); end

  # source://rubocop//lib/rubocop/cop/style/identical_conditional_branches.rb#116
  def on_if(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/identical_conditional_branches.rb#140
  def check_branches(node, branches); end

  # source://rubocop//lib/rubocop/cop/style/identical_conditional_branches.rb#167
  def check_expressions(node, expressions, insert_position); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/identical_conditional_branches.rb#156
  def duplicated_expressions?(node, expressions); end

  # `elsif` branches show up in the if node as nested `else` branches. We
  # need to recursively iterate over all `else` branches.
  #
  # source://rubocop//lib/rubocop/cop/style/identical_conditional_branches.rb#204
  def expand_elses(branch); end

  # source://rubocop//lib/rubocop/cop/style/identical_conditional_branches.rb#219
  def head(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/identical_conditional_branches.rb#188
  def last_child_of_parent?(node); end

  # source://rubocop//lib/rubocop/cop/style/identical_conditional_branches.rb#198
  def message(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/identical_conditional_branches.rb#194
  def single_child_branch?(branch_node); end

  # source://rubocop//lib/rubocop/cop/style/identical_conditional_branches.rb#215
  def tail(node); end
end

# source://rubocop//lib/rubocop/cop/style/identical_conditional_branches.rb#114
RuboCop::Cop::Style::IdenticalConditionalBranches::MSG = T.let(T.unsafe(nil), String)

# Corrector to correct conditional assignment in `if` statements.
#
# source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#558
class RuboCop::Cop::Style::IfCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper

  class << self
    # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#563
    def correct(corrector, cop, node); end

    # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#567
    def move_assignment_inside_condition(corrector, node); end

    private

    # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#581
    def extract_tail_branches(node); end

    # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#588
    def move_branch_inside_condition(corrector, branch, condition, assignment, column); end
  end
end

# If the `else` branch of a conditional consists solely of an `if` node,
# it can be combined with the `else` to become an `elsif`.
# This helps to keep the nesting level from getting too deep.
#
# @example
#   # bad
#   if condition_a
#   action_a
#   else
#   if condition_b
#   action_b
#   else
#   action_c
#   end
#   end
#
#   # good
#   if condition_a
#   action_a
#   elsif condition_b
#   action_b
#   else
#   action_c
#   end
# @example AllowIfModifier: false (default)
#   # bad
#   if condition_a
#   action_a
#   else
#   action_b if condition_b
#   end
#
#   # good
#   if condition_a
#   action_a
#   elsif condition_b
#   action_b
#   end
# @example AllowIfModifier: true
#   # good
#   if condition_a
#   action_a
#   else
#   action_b if condition_b
#   end
#
#   # good
#   if condition_a
#   action_a
#   elsif condition_b
#   action_b
#   end
#
# source://rubocop//lib/rubocop/cop/style/if_inside_else.rb#61
class RuboCop::Cop::Style::IfInsideElse < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/if_inside_else.rb#67
  def on_if(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/if_inside_else.rb#144
  def allow_if_modifier?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/if_inside_else.rb#140
  def allow_if_modifier_in_else_branch?(else_branch); end

  # source://rubocop//lib/rubocop/cop/style/if_inside_else.rb#82
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/if_inside_else.rb#111
  def correct_to_elsif_from_if_inside_else_form(corrector, node, condition); end

  # source://rubocop//lib/rubocop/cop/style/if_inside_else.rb#103
  def correct_to_elsif_from_modifier_form(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/if_inside_else.rb#129
  def find_end_range(node); end

  # source://rubocop//lib/rubocop/cop/style/if_inside_else.rb#136
  def if_condition_range(node, condition); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/if_inside_else.rb#125
  def then?(node); end
end

# source://rubocop//lib/rubocop/cop/style/if_inside_else.rb#65
RuboCop::Cop::Style::IfInsideElse::MSG = T.let(T.unsafe(nil), String)

# Checks for `if` and `unless` statements that would fit on one line if
# written as modifier `if`/`unless`. The cop also checks for modifier
# `if`/`unless` lines that exceed the maximum line length.
#
# The maximum line length is configured in the `Layout/LineLength`
# cop. The tab size is configured in the `IndentationWidth` of the
# `Layout/IndentationStyle` cop.
#
# One-line pattern matching is always allowed. To ensure that there are few cases
# where the match variable is not used, and to prevent oversights. The variable `x`
# becomes undefined and raises `NameError` when the following example is changed to
# the modifier form:
#
# [source,ruby]
# ----
# if [42] in [x]
#   x # `x` is undefined when using modifier form.
# end
# ----
#
# NOTE: It is allowed when `defined?` argument has an undefined value,
# because using the modifier form causes the following incompatibility:
#
# [source,ruby]
# ----
# unless defined?(undefined_foo)
#   undefined_foo = 'default_value'
# end
# undefined_foo # => 'default_value'
#
# undefined_bar = 'default_value' unless defined?(undefined_bar)
# undefined_bar # => nil
# ----
#
# @example
#   # bad
#   if condition
#   do_stuff(bar)
#   end
#
#   unless qux.empty?
#   Foo.do_something
#   end
#
#   do_something_with_a_long_name(arg) if long_condition_that_prevents_code_fit_on_single_line
#
#   # good
#   do_stuff(bar) if condition
#   Foo.do_something unless qux.empty?
#
#   if long_condition_that_prevents_code_fit_on_single_line
#   do_something_with_a_long_name(arg)
#   end
#
#   if short_condition # a long comment that makes it too long if it were just a single line
#   do_something
#   end
#
# source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#63
class RuboCop::Cop::Style::IfUnlessModifier < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::LineLengthHelp
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::StatementModifier
  include ::RuboCop::Cop::AllowedPattern
  include ::RuboCop::Cop::CommentsHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#80
  def on_if(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#168
  def allowed_patterns; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#228
  def another_statement_on_same_line?(node); end

  # source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#129
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#282
  def comment_on_node_line(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#101
  def defined_argument_is_undefined?(if_node, defined_node); end

  # source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#93
  def defined_nodes(condition); end

  # source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#269
  def extract_heredoc_from(last_argument); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#212
  def line_length_enabled_at_line?(line); end

  # source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#121
  def message(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#216
  def named_capture_in_condition?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#220
  def non_eligible_node?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#224
  def non_simple_if_unless?(node); end

  # source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#111
  def pattern_matching_nodes(condition); end

  # source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#286
  def remove_comment(corrector, _node, comment); end

  # source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#276
  def remove_heredoc(corrector, heredoc); end

  # source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#138
  def replacement_for_modifier_form(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#262
  def to_modifier_form_with_move_comment(node, indentation, comment); end

  # source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#242
  def to_normal_form(node, indentation); end

  # source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#250
  def to_normal_form_with_heredoc(node, indentation, heredoc); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#162
  def too_long_due_to_comment_after_modifier?(node, comment); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#157
  def too_long_due_to_modifier?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#203
  def too_long_line_based_on_allow_uri?(line); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#186
  def too_long_line_based_on_config?(range, line); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#195
  def too_long_line_based_on_ignore_cop_directives?(range, line); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#173
  def too_long_single_line?(node); end

  class << self
    # source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#76
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#71
RuboCop::Cop::Style::IfUnlessModifier::MSG_USE_MODIFIER = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#74
RuboCop::Cop::Style::IfUnlessModifier::MSG_USE_NORMAL = T.let(T.unsafe(nil), String)

# Checks for if and unless statements used as modifiers of other if or
# unless statements.
#
# @example
#
#   # bad
#   tired? ? 'stop' : 'go faster' if running?
#
#   # bad
#   if tired?
#   "please stop"
#   else
#   "keep going"
#   end if running?
#
#   # good
#   if running?
#   tired? ? 'stop' : 'go faster'
#   end
#
# source://rubocop//lib/rubocop/cop/style/if_unless_modifier_of_if_unless.rb#25
class RuboCop::Cop::Style::IfUnlessModifierOfIfUnless < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::LineLengthHelp
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::StatementModifier
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/if_unless_modifier_of_if_unless.rb#31
  def on_if(node); end
end

# source://rubocop//lib/rubocop/cop/style/if_unless_modifier_of_if_unless.rb#29
RuboCop::Cop::Style::IfUnlessModifierOfIfUnless::MSG = T.let(T.unsafe(nil), String)

# Checks for redundant `if` with boolean literal branches.
# It checks only conditions to return boolean value (`true` or `false`) for safe detection.
# The conditions to be checked are comparison methods, predicate methods, and
# double negation (!!).
# `nonzero?` method is allowed by default.
# These are customizable with `AllowedMethods` option.
#
# This cop targets only `if`s with a single `elsif` or `else` branch. The following
# code will be allowed, because it has two `elsif` branches:
#
# [source,ruby]
# ----
# if foo
#   true
# elsif bar > baz
#   true
# elsif qux > quux # Single `elsif` is warned, but two or more `elsif`s are not.
#   true
# else
#   false
# end
# ----
#
# @example
#   # bad
#   if foo == bar
#   true
#   else
#   false
#   end
#
#   # bad
#   foo == bar ? true : false
#
#   # good
#   foo == bar
# @example
#   # bad
#   if foo.do_something?
#   true
#   else
#   false
#   end
#
#   # good (but potentially an unsafe correction)
#   foo.do_something?
# @example AllowedMethods: ['nonzero?'] (default)
#   # good
#   num.nonzero? ? true : false
#
# source://rubocop//lib/rubocop/cop/style/if_with_boolean_literal_branches.rb#62
class RuboCop::Cop::Style::IfWithBooleanLiteralBranches < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::AllowedMethods
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/if_with_boolean_literal_branches.rb#74
  def double_negative?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/if_with_boolean_literal_branches.rb#70
  def if_with_boolean_literal_branches?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/if_with_boolean_literal_branches.rb#76
  def on_if(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/if_with_boolean_literal_branches.rb#134
  def assume_boolean_value?(condition); end

  # source://rubocop//lib/rubocop/cop/style/if_with_boolean_literal_branches.rb#114
  def message(node, keyword); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/if_with_boolean_literal_branches.rb#96
  def multiple_elsif?(node); end

  # source://rubocop//lib/rubocop/cop/style/if_with_boolean_literal_branches.rb#102
  def offense_range_with_keyword(node, condition); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/if_with_boolean_literal_branches.rb#151
  def opposite_condition?(node); end

  # source://rubocop//lib/rubocop/cop/style/if_with_boolean_literal_branches.rb#141
  def replacement_condition(node, condition); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/if_with_boolean_literal_branches.rb#156
  def require_parentheses?(condition); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/if_with_boolean_literal_branches.rb#120
  def return_boolean_value?(condition); end
end

# source://rubocop//lib/rubocop/cop/style/if_with_boolean_literal_branches.rb#66
RuboCop::Cop::Style::IfWithBooleanLiteralBranches::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/if_with_boolean_literal_branches.rb#67
RuboCop::Cop::Style::IfWithBooleanLiteralBranches::MSG_FOR_ELSIF = T.let(T.unsafe(nil), String)

# Checks for uses of semicolon in if statements.
#
# @example
#
#   # bad
#   result = if some_condition; something else another_thing end
#
#   # good
#   result = some_condition ? something : another_thing
#
# source://rubocop//lib/rubocop/cop/style/if_with_semicolon.rb#16
class RuboCop::Cop::Style::IfWithSemicolon < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::OnNormalIfUnless
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/if_with_semicolon.rb#23
  def on_normal_if_unless(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/if_with_semicolon.rb#38
  def autocorrect(node); end

  # source://rubocop//lib/rubocop/cop/style/if_with_semicolon.rb#56
  def build_else_branch(second_condition); end

  # source://rubocop//lib/rubocop/cop/style/if_with_semicolon.rb#47
  def correct_elsif(node); end
end

# source://rubocop//lib/rubocop/cop/style/if_with_semicolon.rb#20
RuboCop::Cop::Style::IfWithSemicolon::MSG_IF_ELSE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/if_with_semicolon.rb#21
RuboCop::Cop::Style::IfWithSemicolon::MSG_TERNARY = T.let(T.unsafe(nil), String)

# Checks for `raise` or `fail` statements which do not specify an
# explicit exception class. (This raises a `RuntimeError`. Some projects
# might prefer to use exception classes which more precisely identify the
# nature of the error.)
#
# @example
#   # bad
#   raise 'Error message here'
#
#   # good
#   raise ArgumentError, 'Error message here'
#
# source://rubocop//lib/rubocop/cop/style/implicit_runtime_error.rb#17
class RuboCop::Cop::Style::ImplicitRuntimeError < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/style/implicit_runtime_error.rb#23
  def implicit_runtime_error_raise_or_fail(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/implicit_runtime_error.rb#26
  def on_send(node); end
end

# source://rubocop//lib/rubocop/cop/style/implicit_runtime_error.rb#18
RuboCop::Cop::Style::ImplicitRuntimeError::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/implicit_runtime_error.rb#20
RuboCop::Cop::Style::ImplicitRuntimeError::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for `in;` uses in `case` expressions.
#
# @example
#   # bad
#   case expression
#   in pattern_a; foo
#   in pattern_b; bar
#   end
#
#   # good
#   case expression
#   in pattern_a then foo
#   in pattern_b then bar
#   end
#
# source://rubocop//lib/rubocop/cop/style/in_pattern_then.rb#21
class RuboCop::Cop::Style::InPatternThen < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop//lib/rubocop/cop/style/in_pattern_then.rb#29
  def on_in_pattern(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/in_pattern_then.rb#46
  def alternative_pattern_source(pattern); end
end

# source://rubocop//lib/rubocop/cop/style/in_pattern_then.rb#27
RuboCop::Cop::Style::InPatternThen::MSG = T.let(T.unsafe(nil), String)

# Use `Kernel#loop` for infinite loops.
#
# @example
#   # bad
#   while true
#   work
#   end
#
#   # good
#   loop do
#   work
#   end
#
# source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#23
class RuboCop::Cop::Style::InfiniteLoop < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#35
  def after_leaving_scope(scope, _variable_table); end

  # source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#44
  def on_until(node); end

  # source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#44
  def on_until_post(node); end

  # source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#40
  def on_while(node); end

  # source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#40
  def on_while_post(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#84
  def assigned_before_loop?(var, range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#80
  def assigned_inside_loop?(var, range); end

  # source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#70
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#103
  def modifier_replacement(node); end

  # source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#114
  def non_modifier_range(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#89
  def referenced_after_loop?(var, range); end

  # source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#94
  def replace_begin_end_with_modifier(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#99
  def replace_source(corrector, range, replacement); end

  # source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#53
  def while_or_until(node); end

  class << self
    # source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#31
    def joining_forces; end
  end
end

# source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#27
RuboCop::Cop::Style::InfiniteLoop::LEADING_SPACE = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#29
RuboCop::Cop::Style::InfiniteLoop::MSG = T.let(T.unsafe(nil), String)

# Checks for trailing inline comments.
#
# @example
#
#   # good
#   foo.each do |f|
#   # Standalone comment
#   f.bar
#   end
#
#   # bad
#   foo.each do |f|
#   f.bar # Trailing inline comment
#   end
#
# source://rubocop//lib/rubocop/cop/style/inline_comment.rb#20
class RuboCop::Cop::Style::InlineComment < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/style/inline_comment.rb#23
  def on_new_investigation; end
end

# source://rubocop//lib/rubocop/cop/style/inline_comment.rb#21
RuboCop::Cop::Style::InlineComment::MSG = T.let(T.unsafe(nil), String)

# Check for usages of not (`not` or `!`) called on a method
# when an inverse of that method can be used instead.
#
# Methods that can be inverted by a not (`not` or `!`) should be defined
# in `InverseMethods`.
#
# Methods that are inverted by inverting the return
# of the block that is passed to the method should be defined in
# `InverseBlocks`.
#
# @example
#   # bad
#   !foo.none?
#   !foo.any? { |f| f.even? }
#   !foo.blank?
#   !(foo == bar)
#   foo.select { |f| !f.even? }
#   foo.reject { |f| f != 7 }
#
#   # good
#   foo.none?
#   foo.blank?
#   foo.any? { |f| f.even? }
#   foo != bar
#   foo == bar
#   !!('foo' =~ /^\w+$/)
#   !(foo.class < Numeric) # Checking class hierarchy is allowed
#   # Blocks with guard clauses are ignored:
#   foo.select do |f|
#   next if f.zero?
#   f != 1
#   end
#
# source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#43
class RuboCop::Cop::Style::InverseMethods < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#70
  def inverse_block?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#61
  def inverse_candidate?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#91
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#91
  def on_numblock(node); end

  # source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#78
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#176
  def camel_case_constant?(node); end

  # source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#120
  def correct_inverse_block(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#111
  def correct_inverse_method(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#127
  def correct_inverse_selector(block, corrector); end

  # source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#180
  def dot_range(loc); end

  # source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#163
  def end_parentheses(node, method_call); end

  # source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#149
  def inverse_blocks; end

  # source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#144
  def inverse_methods; end

  # source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#190
  def message(method, inverse); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#153
  def negated?(node); end

  # source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#157
  def not_to_receiver(node, method_call); end

  # When comparing classes, `!(Integer < Numeric)` is not the same as
  # `Integer > Numeric`.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#171
  def possible_class_hierarchy_check?(lhs, rhs, method); end

  # source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#184
  def remove_end_parenthesis(corrector, node, method, method_call); end

  class << self
    # source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#56
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#52
RuboCop::Cop::Style::InverseMethods::CAMEL_CASE = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#49
RuboCop::Cop::Style::InverseMethods::CLASS_COMPARISON_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#50
RuboCop::Cop::Style::InverseMethods::EQUALITY_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#48
RuboCop::Cop::Style::InverseMethods::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#51
RuboCop::Cop::Style::InverseMethods::NEGATED_EQUALITY_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#54
RuboCop::Cop::Style::InverseMethods::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for usages of `unless` which can be replaced by `if` with inverted condition.
# Code without `unless` is easier to read, but that is subjective, so this cop
# is disabled by default.
#
# Methods that can be inverted should be defined in `InverseMethods`. Note that
# the relationship of inverse methods needs to be defined in both directions.
# For example,
#   InverseMethods:
#     :!=: :==
#     :even?: :odd?
#     :odd?: :even?
#
#  will suggest both `even?` and `odd?` to be inverted, but only `!=` (and not `==`).
#
# @example
#   # bad (simple condition)
#   foo unless !bar
#   foo unless x != y
#   foo unless x >= 10
#   foo unless x.even?
#
#   # good
#   foo if bar
#   foo if x == y
#   foo if x < 10
#   foo if x.odd?
#
#   # bad (complex condition)
#   foo unless x != y || x.even?
#
#   # good
#   foo if x == y && x.odd?
#
#   # good (if)
#   foo if !condition
#
# source://rubocop//lib/rubocop/cop/style/invertible_unless_condition.rb#47
class RuboCop::Cop::Style::InvertibleUnlessCondition < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/invertible_unless_condition.rb#52
  def on_if(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/invertible_unless_condition.rb#87
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/invertible_unless_condition.rb#100
  def autocorrect_send_node(corrector, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/invertible_unless_condition.rb#81
  def inheritance_check?(node); end

  # source://rubocop//lib/rubocop/cop/style/invertible_unless_condition.rb#108
  def inverse_methods; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/invertible_unless_condition.rb#66
  def invertible?(node); end
end

# source://rubocop//lib/rubocop/cop/style/invertible_unless_condition.rb#50
RuboCop::Cop::Style::InvertibleUnlessCondition::MSG = T.let(T.unsafe(nil), String)

# Checks for hardcoded IP addresses, which can make code
# brittle. IP addresses are likely to need to be changed when code
# is deployed to a different server or environment, which may break
# a deployment if forgotten. Prefer setting IP addresses in ENV or
# other configuration.
#
# @example
#
#   # bad
#   ip_address = '127.59.241.29'
#
#   # good
#   ip_address = ENV['DEPLOYMENT_IP_ADDRESS']
#
# source://rubocop//lib/rubocop/cop/style/ip_addresses.rb#21
class RuboCop::Cop::Style::IpAddresses < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::StringHelp

  # Dummy implementation of method in ConfigurableEnforcedStyle that is
  # called from StringHelp.
  #
  # source://rubocop//lib/rubocop/cop/style/ip_addresses.rb#46
  def correct_style_detected; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/ip_addresses.rb#27
  def offense?(node); end

  # Dummy implementation of method in ConfigurableEnforcedStyle that is
  # called from StringHelp.
  #
  # source://rubocop//lib/rubocop/cop/style/ip_addresses.rb#42
  def opposite_style_detected; end

  private

  # source://rubocop//lib/rubocop/cop/style/ip_addresses.rb#50
  def allowed_addresses; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/ip_addresses.rb#55
  def could_be_ip?(str); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/ip_addresses.rb#68
  def starts_with_hex_or_colon?(str); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/ip_addresses.rb#64
  def too_long?(str); end
end

# IPv4-mapped IPv6 is the longest
#
# source://rubocop//lib/rubocop/cop/style/ip_addresses.rb#24
RuboCop::Cop::Style::IpAddresses::IPV6_MAX_SIZE = T.let(T.unsafe(nil), Integer)

# source://rubocop//lib/rubocop/cop/style/ip_addresses.rb#25
RuboCop::Cop::Style::IpAddresses::MSG = T.let(T.unsafe(nil), String)

# Enforces that optional keyword parameters are placed at the
# end of the parameters list.
#
# This improves readability, because when looking through the source,
# it is expected to find required parameters at the beginning of parameters list
# and optional parameters at the end.
#
# @example
#   # bad
#   def some_method(first: false, second:, third: 10)
#   # body omitted
#   end
#
#   # good
#   def some_method(second:, first: false, third: 10)
#   # body omitted
#   end
#
#   # bad
#   do_something do |first: false, second:, third: 10|
#   # body omitted
#   end
#
#   # good
#   do_something do |second:, first: false, third: 10|
#   # body omitted
#   end
#
# source://rubocop//lib/rubocop/cop/style/keyword_parameters_order.rb#34
class RuboCop::Cop::Style::KeywordParametersOrder < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/keyword_parameters_order.rb#40
  def on_kwoptarg(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/keyword_parameters_order.rb#58
  def append_newline_to_last_kwoptarg(arguments, corrector); end

  # source://rubocop//lib/rubocop/cop/style/keyword_parameters_order.rb#66
  def remove_kwargs(kwarg_nodes, corrector); end
end

# source://rubocop//lib/rubocop/cop/style/keyword_parameters_order.rb#38
RuboCop::Cop::Style::KeywordParametersOrder::MSG = T.let(T.unsafe(nil), String)

# (by default) checks for uses of the lambda literal syntax for
# single line lambdas, and the method call syntax for multiline lambdas.
# It is configurable to enforce one of the styles for both single line
# and multiline lambdas as well.
#
# @example EnforcedStyle: line_count_dependent (default)
#   # bad
#   f = lambda { |x| x }
#   f = ->(x) do
#   x
#   end
#
#   # good
#   f = ->(x) { x }
#   f = lambda do |x|
#   x
#   end
# @example EnforcedStyle: lambda
#   # bad
#   f = ->(x) { x }
#   f = ->(x) do
#   x
#   end
#
#   # good
#   f = lambda { |x| x }
#   f = lambda do |x|
#   x
#   end
# @example EnforcedStyle: literal
#   # bad
#   f = lambda { |x| x }
#   f = lambda do |x|
#   x
#   end
#
#   # good
#   f = ->(x) { x }
#   f = ->(x) do
#   x
#   end
#
# source://rubocop//lib/rubocop/cop/style/lambda.rb#49
class RuboCop::Cop::Style::Lambda < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/lambda.rb#64
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/style/lambda.rb#64
  def on_numblock(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/lambda.rb#115
  def arguments_with_whitespace(node); end

  # source://rubocop//lib/rubocop/cop/style/lambda.rb#104
  def autocorrect_method_to_literal(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/lambda.rb#119
  def lambda_arg_string(args); end

  # source://rubocop//lib/rubocop/cop/style/lambda.rb#89
  def message(node, selector); end

  # source://rubocop//lib/rubocop/cop/style/lambda.rb#95
  def message_line_modifier(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/lambda.rb#83
  def offending_selector?(node, selector); end
end

# source://rubocop//lib/rubocop/cop/style/lambda.rb#53
RuboCop::Cop::Style::Lambda::LITERAL_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/lambda.rb#54
RuboCop::Cop::Style::Lambda::METHOD_MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/lambda.rb#56
RuboCop::Cop::Style::Lambda::OFFENDING_SELECTORS = T.let(T.unsafe(nil), Hash)

# Checks for use of the lambda.(args) syntax.
#
# @example EnforcedStyle: call (default)
#   # bad
#   lambda.(x, y)
#
#   # good
#   lambda.call(x, y)
# @example EnforcedStyle: braces
#   # bad
#   lambda.call(x, y)
#
#   # good
#   lambda.(x, y)
#
# source://rubocop//lib/rubocop/cop/style/lambda_call.rb#21
class RuboCop::Cop::Style::LambdaCall < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/lambda_call.rb#28
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/lambda_call.rb#62
  def explicit_style?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/lambda_call.rb#58
  def implicit_style?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/lambda_call.rb#46
  def offense?(node); end

  # source://rubocop//lib/rubocop/cop/style/lambda_call.rb#50
  def prefer(node); end
end

# source://rubocop//lib/rubocop/cop/style/lambda_call.rb#25
RuboCop::Cop::Style::LambdaCall::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/lambda_call.rb#26
RuboCop::Cop::Style::LambdaCall::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for string literal concatenation at
# the end of a line.
#
# @example
#
#   # bad
#   some_str = 'ala' +
#   'bala'
#
#   some_str = 'ala' <<
#   'bala'
#
#   # good
#   some_str = 'ala' \
#   'bala'
#
# source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#35
class RuboCop::Cop::Style::LineEndConcatenation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#51
  def on_new_investigation; end

  private

  # source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#74
  def autocorrect(corrector, operator_range); end

  # source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#57
  def check_token_set(index); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#101
  def eligible_next_successor?(next_successor); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#97
  def eligible_operator?(operator); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#105
  def eligible_predecessor?(predecessor); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#93
  def eligible_successor?(successor); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#87
  def eligible_token_set?(predecessor, operator, successor); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#124
  def standard_string_literal?(token); end

  # source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#109
  def token_after_last_string(successor, base_index); end

  class << self
    # source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#47
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#42
RuboCop::Cop::Style::LineEndConcatenation::COMPLEX_STRING_BEGIN_TOKEN = T.let(T.unsafe(nil), Symbol)

# source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#43
RuboCop::Cop::Style::LineEndConcatenation::COMPLEX_STRING_END_TOKEN = T.let(T.unsafe(nil), Symbol)

# source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#40
RuboCop::Cop::Style::LineEndConcatenation::CONCAT_TOKEN_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#44
RuboCop::Cop::Style::LineEndConcatenation::HIGH_PRECEDENCE_OP_TOKEN_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#39
RuboCop::Cop::Style::LineEndConcatenation::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#45
RuboCop::Cop::Style::LineEndConcatenation::QUOTE_DELIMITERS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#41
RuboCop::Cop::Style::LineEndConcatenation::SIMPLE_STRING_TOKEN_TYPE = T.let(T.unsafe(nil), Symbol)

# Ensures magic comments are written consistently throughout your code base.
# Looks for discrepancies in separators (`-` vs `_`) and capitalization for
# both magic comment directives and values.
#
# Required capitalization can be set with the `DirectiveCapitalization` and
# `ValueCapitalization` configuration keys.
#
# NOTE: If one of these configuration is set to nil, any capitalization is allowed.
#
# @example ValueCapitalization: uppercase
#   # bad
#   # frozen-string-literal: true
#
#   # good
#   # frozen-string-literal: TRUE
# @example EnforcedStyle: kebab_case
#   # The `kebab_case` style will enforce that the frozen string literal
#   # comment is written in kebab case. (Words separated by hyphens)
#   # bad
#   # frozen_string_literal: true
#
#   module Baz
#   # ...
#   end
#
#   # good
#   # frozen-string-literal: true
#
#   module Baz
#   # ...
#   end
# @example DirectiveCapitalization: lowercase (default)
#   # bad
#   # FROZEN-STRING-LITERAL: true
#
#   # good
#   # frozen-string-literal: true
# @example DirectiveCapitalization: uppercase
#   # bad
#   # frozen-string-literal: true
#
#   # good
#   # FROZEN-STRING-LITERAL: true
# @example DirectiveCapitalization: nil
#   # any capitalization is accepted
#
#   # good
#   # frozen-string-literal: true
#
#   # good
#   # FROZEN-STRING-LITERAL: true
# @example ValueCapitalization: nil (default)
#   # any capitalization is accepted
#
#   # good
#   # frozen-string-literal: true
#
#   # good
#   # frozen-string-literal: TRUE
# @example ValueCapitalization: lowercase
#   # when a value is not given, any capitalization is accepted
#
#   # bad
#   # frozen-string-literal: TRUE
#
#   # good
#   # frozen-string-literal: TRUE
# @example EnforcedStyle: snake_case (default)
#   # The `snake_case` style will enforce that the frozen string literal
#   # comment is written in snake case. (Words separated by underscores)
#   # bad
#   # frozen-string-literal: true
#
#   module Bar
#   # ...
#   end
#
#   # good
#   # frozen_string_literal: false
#
#   module Bar
#   # ...
#   end
#
# source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#97
class RuboCop::Cop::Style::MagicCommentFormat < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#156
  def on_new_investigation; end

  private

  # source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#241
  def correct_separator; end

  # source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#279
  def directive_capitalization; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#197
  def directive_offends?(directive); end

  # source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#233
  def expected_style; end

  # source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#183
  def find_issues(comment); end

  # source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#207
  def fix_directives(issues); end

  # source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#221
  def fix_values(issues); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#245
  def incorrect_separator?(text); end

  # source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#173
  def leading_comment_lines; end

  # source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#275
  def line_range(line); end

  # source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#167
  def magic_comments; end

  # source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#202
  def register_offenses(issues); end

  # source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#264
  def replace_capitalization(text, style); end

  # source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#260
  def replace_separator(text); end

  # source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#301
  def supported_capitalizations; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#295
  def valid_capitalization?(style); end

  # source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#287
  def value_capitalization; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#249
  def wrong_capitalization?(text, expected_case); end

  # source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#237
  def wrong_separator; end
end

# Value object to extract source ranges for the different parts of a magic comment
#
# source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#107
class RuboCop::Cop::Style::MagicCommentFormat::CommentRange
  extend ::Forwardable

  # @return [CommentRange] a new instance of CommentRange
  #
  # source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#119
  def initialize(comment); end

  # Returns the value of attribute comment.
  #
  # source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#117
  def comment; end

  # A magic comment can contain one directive (normal style) or
  # multiple directives (emacs style)
  #
  # source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#125
  def directives; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def loc(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def text(*args, **_arg1, &block); end

  # A magic comment can contain one value (normal style) or
  # multiple directives (emacs style)
  #
  # source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#141
  def values; end
end

# source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#110
RuboCop::Cop::Style::MagicCommentFormat::CommentRange::DIRECTIVE_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#114
RuboCop::Cop::Style::MagicCommentFormat::CommentRange::VALUE_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#102
RuboCop::Cop::Style::MagicCommentFormat::KEBAB_SEPARATOR = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#103
RuboCop::Cop::Style::MagicCommentFormat::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#104
RuboCop::Cop::Style::MagicCommentFormat::MSG_VALUE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#101
RuboCop::Cop::Style::MagicCommentFormat::SNAKE_SEPARATOR = T.let(T.unsafe(nil), String)

# Prefer `select` or `reject` over `map { ... }.compact`.
#
# @example
#
#   # bad
#   array.map { |e| some_condition? ? e : next }.compact
#
#   # bad
#   array.map do |e|
#   if some_condition?
#   e
#   else
#   next
#   end
#   end.compact
#
#   # bad
#   array.map do |e|
#   next if some_condition?
#
#   e
#   end.compact
#
#   # bad
#   array.map do |e|
#   e if some_condition?
#   end.compact
#
#   # good
#   array.select { |e| some_condition? }
#
#   # good
#   array.reject { |e| some_condition? }
#
# source://rubocop//lib/rubocop/cop/style/map_compact_with_conditional_block.rb#40
class RuboCop::Cop::Style::MapCompactWithConditionalBlock < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/map_compact_with_conditional_block.rb#46
  def map_and_compact?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/map_compact_with_conditional_block.rb#72
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/map_compact_with_conditional_block.rb#125
  def range(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/map_compact_with_conditional_block.rb#91
  def returns_block_argument?(block_argument_node, return_value_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/map_compact_with_conditional_block.rb#95
  def truthy_branch?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/map_compact_with_conditional_block.rb#115
  def truthy_branch_for_guard?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/map_compact_with_conditional_block.rb#105
  def truthy_branch_for_if?(node); end
end

# source://rubocop//lib/rubocop/cop/style/map_compact_with_conditional_block.rb#43
RuboCop::Cop::Style::MapCompactWithConditionalBlock::MSG = T.let(T.unsafe(nil), String)

# Looks for uses of `map.to_h` or `collect.to_h` that could be
# written with just `to_h` in Ruby >= 2.6.
#
# NOTE: `Style/HashTransformKeys` and `Style/HashTransformValues` will
# also change this pattern if only hash keys or hash values are being
# transformed.
#
# @example
#   # bad
#   something.map { |v| [v, v * 2] }.to_h
#
#   # good
#   something.to_h { |v| [v, v * 2] }
#
#   # bad
#   {foo: bar}.collect { |k, v| [k.to_s, v.do_something] }.to_h
#
#   # good
#   {foo: bar}.to_h { |k, v| [k.to_s, v.do_something] }
#
# source://rubocop//lib/rubocop/cop/style/map_to_hash.rb#30
class RuboCop::Cop::Style::MapToHash < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop//lib/rubocop/cop/style/map_to_hash.rb#41
  def map_to_h?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/map_to_hash.rb#48
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/map_to_hash.rb#62
  def autocorrect(corrector, to_h, map); end
end

# source://rubocop//lib/rubocop/cop/style/map_to_hash.rb#37
RuboCop::Cop::Style::MapToHash::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/map_to_hash.rb#38
RuboCop::Cop::Style::MapToHash::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Looks for uses of `map.to_set` or `collect.to_set` that could be
# written with just `to_set`.
#
# @example
#   # bad
#   something.map { |i| i * 2 }.to_set
#
#   # good
#   something.to_set { |i| i * 2 }
#
#   # bad
#   [1, 2, 3].collect { |i| i.to_s }.to_set
#
#   # good
#   [1, 2, 3].to_set { |i| i.to_s }
#
# source://rubocop//lib/rubocop/cop/style/map_to_set.rb#26
class RuboCop::Cop::Style::MapToSet < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/map_to_set.rb#34
  def map_to_set?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/map_to_set.rb#41
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/map_to_set.rb#55
  def autocorrect(corrector, to_set, map); end
end

# source://rubocop//lib/rubocop/cop/style/map_to_set.rb#30
RuboCop::Cop::Style::MapToSet::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/map_to_set.rb#31
RuboCop::Cop::Style::MapToSet::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Enforces the presence (default) or absence of parentheses in
# method calls containing parameters.
#
# In the default style (require_parentheses), macro methods are allowed.
# Additional methods can be added to the `AllowedMethods` or
# `AllowedPatterns` list. These options are valid only in the default
# style. Macros can be included by either setting `IgnoreMacros` to false
# or adding specific macros to the `IncludedMacros` list.
#
# Precedence of options is as follows:
#
# 1. `AllowedMethods`
# 2. `AllowedPatterns`
# 3. `IncludedMacros`
#
# If a method is listed in both `IncludedMacros` and `AllowedMethods`,
# then the latter takes precedence (that is, the method is allowed).
#
# In the alternative style (omit_parentheses), there are three additional
# options.
#
# 1. `AllowParenthesesInChaining` is `false` by default. Setting it to
#    `true` allows the presence of parentheses in the last call during
#    method chaining.
#
# 2. `AllowParenthesesInMultilineCall` is `false` by default. Setting it
#     to `true` allows the presence of parentheses in multi-line method
#     calls.
#
# 3. `AllowParenthesesInCamelCaseMethod` is `false` by default. This
#     allows the presence of parentheses when calling a method whose name
#     begins with a capital letter and which has no arguments. Setting it
#     to `true` allows the presence of parentheses in such a method call
#     even with arguments.
#
# NOTE: The style of `omit_parentheses` allows parentheses in cases where
# omitting them results in ambiguous or syntactically incorrect code.
#
# Non-exhaustive list of examples:
#
# - Parentheses are required allowed in method calls with arguments inside
#   literals, logical operators, setting default values in position and
#   keyword arguments, chaining and more.
# - Parentheses are allowed in method calls with arguments inside
#   operators to avoid ambiguity.
#   triple-dot syntax introduced in Ruby 2.7 as omitting them starts an
#   endless range.
# - Parentheses are allowed when forwarding arguments with the
#   triple-dot syntax introduced in Ruby 2.7 as omitting them starts an
#   endless range.
# - Parentheses are required in calls with arguments when inside an
#   endless method definition introduced in Ruby 3.0.
# - Ruby 3.1's hash omission syntax allows parentheses if the method call
#   is in conditionals and requires parentheses if the call
#   is not the value-returning expression. See
#   https://bugs.ruby-lang.org/issues/18396.
# - Parentheses are required in anonymous arguments, keyword arguments
#   and block passing in Ruby 3.2.
#
# @example AllowParenthesesInStringInterpolation: true
#
#   # good
#   "#{t('this.is.good')}"
#
#   # good
#   "#{t 'this.is.also.good'}"
# @example EnforcedStyle: omit_parentheses
#
#   # bad
#   array.delete(e)
#
#   # good
#   array.delete e
#
#   # bad
#   action.enforce(strict: true)
#
#   # good
#   action.enforce strict: true
#
#   # good
#   # Parentheses are allowed for code that can be ambiguous without
#   # them.
#   action.enforce(condition) || other_condition
#
#   # good
#   # Parentheses are allowed for calls that won't produce valid Ruby
#   # without them.
#   yield path, File.basename(path)
#
#   # good
#   # Omitting the parentheses in Ruby 3.1 hash omission syntax can lead
#   # to ambiguous code. We allow them in conditionals and non-last
#   # expressions. See https://bugs.ruby-lang.org/issues/18396
#   if meets(criteria:, action:)
#   safe_action(action) || dangerous_action(action)
#   end
# @example IgnoreMacros: true (default)
#
#   # good
#   class Foo
#   bar :baz
#   end
# @example IgnoreMacros: false
#
#   # bad
#   class Foo
#   bar :baz
#   end
# @example AllowParenthesesInMultilineCall: false (default)
#
#   # bad
#   foo.enforce(
#   strict: true
#   )
#
#   # good
#   foo.enforce \
#   strict: true
# @example AllowParenthesesInMultilineCall: true
#
#   # good
#   foo.enforce(
#   strict: true
#   )
#
#   # good
#   foo.enforce \
#   strict: true
# @example AllowParenthesesInChaining: false (default)
#
#   # bad
#   foo().bar(1)
#
#   # good
#   foo().bar 1
# @example AllowParenthesesInChaining: true
#
#   # good
#   foo().bar(1)
#
#   # good
#   foo().bar 1
# @example AllowParenthesesInCamelCaseMethod: false (default)
#
#   # bad
#   Array(1)
#
#   # good
#   Array 1
# @example AllowParenthesesInCamelCaseMethod: true
#
#   # good
#   Array(1)
#
#   # good
#   Array 1
# @example AllowParenthesesInStringInterpolation: false (default)
#
#   # bad
#   "#{t('this.is.bad')}"
#
#   # good
#   "#{t 'this.is.better'}"
# @example EnforcedStyle: require_parentheses (default)
#
#   # bad
#   array.delete e
#
#   # good
#   array.delete(e)
#
#   # good
#   # Operators don't need parens
#   foo == bar
#
#   # good
#   # Setter methods don't need parens
#   foo.bar = baz
#
#   # okay with `puts` listed in `AllowedMethods`
#   puts 'test'
#
#   # okay with `^assert` listed in `AllowedPatterns`
#   assert_equal 'test', x
#
# source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#202
class RuboCop::Cop::Style::MethodCallWithArgsParentheses < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::AllowedPattern
  include ::RuboCop::Cop::Style::MethodCallWithArgsParentheses::RequireParentheses
  include ::RuboCop::Cop::Style::MethodCallWithArgsParentheses::OmitParentheses
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#217
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#217
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#217
  def on_super(node); end

  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#217
  def on_yield(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#226
  def args_begin(node); end

  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#235
  def args_end(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#239
  def args_parenthesized?(node); end

  class << self
    # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#213
    def autocorrect_incompatible_with; end
  end
end

# Style omit_parentheses
#
# source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#9
module RuboCop::Cop::Style::MethodCallWithArgsParentheses::OmitParentheses
  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#70
  def allowed_camel_case_method_call?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#159
  def allowed_chained_call_with_parentheses?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#155
  def allowed_multiline_call_with_parentheses?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#75
  def allowed_string_interpolation_method_call?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#168
  def ambiguous_literal?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#197
  def assigned_before?(node, target); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#205
  def assignment_in_condition?(node); end

  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#31
  def autocorrect(corrector, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#142
  def call_as_argument_or_chain?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#99
  def call_in_literals?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#110
  def call_in_logical_operators?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#119
  def call_in_optional_arguments?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#123
  def call_in_single_line_inheritance?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#127
  def call_with_ambiguous_arguments?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#137
  def call_with_braced_block?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#215
  def forwards_anonymous_rest_arguments?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#184
  def hash_literal?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#148
  def hash_literal_in_arguments?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#44
  def inside_endless_method_def?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#201
  def inside_string_interpolation?(node); end

  # Require hash value omission be enclosed in parentheses to prevent the following issue:
  # https://bugs.ruby-lang.org/issues/18396.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#58
  def last_expression?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#87
  def legitimate_call_with_parentheses?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#180
  def logical_operator?(node); end

  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#40
  def offense_range(node); end

  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#16
  def omit_parentheses(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#80
  def parentheses_at_the_end_of_multiline_call?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#188
  def regexp_slash_literal?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#49
  def require_parentheses_for_hash_value_omission?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#172
  def splat?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#66
  def super_call_without_arguments?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#62
  def syntax_like_method_call?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#176
  def ternary_if?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#192
  def unary_literal?(node); end
end

# source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#11
RuboCop::Cop::Style::MethodCallWithArgsParentheses::OmitParentheses::OMIT_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#10
RuboCop::Cop::Style::MethodCallWithArgsParentheses::OmitParentheses::TRAILING_WHITESPACE_REGEX = T.let(T.unsafe(nil), Regexp)

# Style require_parentheses
#
# source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/require_parentheses.rb#8
module RuboCop::Cop::Style::MethodCallWithArgsParentheses::RequireParentheses
  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/require_parentheses.rb#27
  def allowed_method_name?(name); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/require_parentheses.rb#31
  def eligible_for_parentheses_omission?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/require_parentheses.rb#39
  def ignored_macro?(node); end

  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/require_parentheses.rb#35
  def included_macros_list; end

  # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/require_parentheses.rb#14
  def require_parentheses(node); end
end

# source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/require_parentheses.rb#9
RuboCop::Cop::Style::MethodCallWithArgsParentheses::RequireParentheses::REQUIRE_MSG = T.let(T.unsafe(nil), String)

# Checks for unwanted parentheses in parameterless method calls.
#
# This cop can be customized allowed methods with `AllowedMethods`.
# By default, there are no methods to allowed.
#
# @example
#   # bad
#   object.some_method()
#
#   # good
#   object.some_method
# @example AllowedMethods: [] (default)
#   # bad
#   object.foo()
# @example AllowedMethods: [foo]
#   # good
#   object.foo()
#
# source://rubocop//lib/rubocop/cop/style/method_call_without_args_parentheses.rb#26
class RuboCop::Cop::Style::MethodCallWithoutArgsParentheses < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::AllowedPattern
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/method_call_without_args_parentheses.rb#33
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_without_args_parentheses.rb#60
  def allowed_method_name?(name); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_without_args_parentheses.rb#74
  def any_assignment?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_without_args_parentheses.rb#56
  def default_argument?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_without_args_parentheses.rb#52
  def ineligible_node?(node); end

  # source://rubocop//lib/rubocop/cop/style/method_call_without_args_parentheses.rb#97
  def offense_range(node); end

  # source://rubocop//lib/rubocop/cop/style/method_call_without_args_parentheses.rb#45
  def register_offense(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_without_args_parentheses.rb#64
  def same_name_assignment?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_call_without_args_parentheses.rb#90
  def variable_in_mass_assignment?(variable_name, node); end
end

# source://rubocop//lib/rubocop/cop/style/method_call_without_args_parentheses.rb#31
RuboCop::Cop::Style::MethodCallWithoutArgsParentheses::MSG = T.let(T.unsafe(nil), String)

# Checks for methods called on a do...end block. The point of
# this check is that it's easy to miss the call tacked on to the block
# when reading code.
#
# @example
#   # bad
#   a do
#   b
#   end.c
#
#   # good
#   a { b }.c
#
#   # good
#   foo = a do
#   b
#   end
#   foo.c
#
# source://rubocop//lib/rubocop/cop/style/method_called_on_do_end_block.rb#24
class RuboCop::Cop::Style::MethodCalledOnDoEndBlock < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/style/method_called_on_do_end_block.rb#29
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/style/method_called_on_do_end_block.rb#40
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/style/method_called_on_do_end_block.rb#29
  def on_numblock(node); end

  # source://rubocop//lib/rubocop/cop/style/method_called_on_do_end_block.rb#40
  def on_send(node); end
end

# source://rubocop//lib/rubocop/cop/style/method_called_on_do_end_block.rb#27
RuboCop::Cop::Style::MethodCalledOnDoEndBlock::MSG = T.let(T.unsafe(nil), String)

# Checks for parentheses around the arguments in method
# definitions. Both instance and class/singleton methods are checked.
#
# Regardless of style, parentheses are necessary for:
#
# 1. Endless methods
# 2. Argument lists containing a `forward-arg` (`...`)
# 3. Argument lists containing an anonymous rest arguments forwarding (`*`)
# 4. Argument lists containing an anonymous keyword rest arguments forwarding (`**`)
# 5. Argument lists containing an anonymous block forwarding (`&`)
#
# Removing the parens would be a syntax error here.
#
# @example EnforcedStyle: require_parentheses (default)
#   # The `require_parentheses` style requires method definitions
#   # to always use parentheses
#
#   # bad
#   def bar num1, num2
#   num1 + num2
#   end
#
#   def foo descriptive_var_name,
#   another_descriptive_var_name,
#   last_descriptive_var_name
#   do_something
#   end
#
#   # good
#   def bar(num1, num2)
#   num1 + num2
#   end
#
#   def foo(descriptive_var_name,
#   another_descriptive_var_name,
#   last_descriptive_var_name)
#   do_something
#   end
# @example EnforcedStyle: require_no_parentheses
#   # The `require_no_parentheses` style requires method definitions
#   # to never use parentheses
#
#   # bad
#   def bar(num1, num2)
#   num1 + num2
#   end
#
#   def foo(descriptive_var_name,
#   another_descriptive_var_name,
#   last_descriptive_var_name)
#   do_something
#   end
#
#   # good
#   def bar num1, num2
#   num1 + num2
#   end
#
#   def foo descriptive_var_name,
#   another_descriptive_var_name,
#   last_descriptive_var_name
#   do_something
#   end
# @example EnforcedStyle: require_no_parentheses_except_multiline
#   # The `require_no_parentheses_except_multiline` style prefers no
#   # parentheses when method definition arguments fit on single line,
#   # but prefers parentheses when arguments span multiple lines.
#
#   # bad
#   def bar(num1, num2)
#   num1 + num2
#   end
#
#   def foo descriptive_var_name,
#   another_descriptive_var_name,
#   last_descriptive_var_name
#   do_something
#   end
#
#   # good
#   def bar num1, num2
#   num1 + num2
#   end
#
#   def foo(descriptive_var_name,
#   another_descriptive_var_name,
#   last_descriptive_var_name)
#   do_something
#   end
#
# source://rubocop//lib/rubocop/cop/style/method_def_parentheses.rb#97
class RuboCop::Cop::Style::MethodDefParentheses < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/method_def_parentheses.rb#105
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/style/method_def_parentheses.rb#105
  def on_defs(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_def_parentheses.rb#169
  def anonymous_arguments?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_def_parentheses.rb#147
  def arguments_without_parentheses?(node); end

  # source://rubocop//lib/rubocop/cop/style/method_def_parentheses.rb#126
  def correct_arguments(arg_node, corrector); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_def_parentheses.rb#131
  def forced_parentheses?(node); end

  # source://rubocop//lib/rubocop/cop/style/method_def_parentheses.rb#151
  def missing_parentheses(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/method_def_parentheses.rb#142
  def require_parentheses?(args); end

  # source://rubocop//lib/rubocop/cop/style/method_def_parentheses.rb#161
  def unwanted_parentheses(args); end
end

# source://rubocop//lib/rubocop/cop/style/method_def_parentheses.rb#103
RuboCop::Cop::Style::MethodDefParentheses::MSG_MISSING = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/method_def_parentheses.rb#102
RuboCop::Cop::Style::MethodDefParentheses::MSG_PRESENT = T.let(T.unsafe(nil), String)

# Checks for potential uses of `Enumerable#minmax`.
#
# @example
#
#   # bad
#   bar = [foo.min, foo.max]
#   return foo.min, foo.max
#
#   # good
#   bar = foo.minmax
#   return foo.minmax
#
# source://rubocop//lib/rubocop/cop/style/min_max.rb#17
class RuboCop::Cop::Style::MinMax < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/min_max.rb#38
  def min_max_candidate(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/min_max.rb#22
  def on_array(node); end

  # source://rubocop//lib/rubocop/cop/style/min_max.rb#22
  def on_return(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/min_max.rb#55
  def argument_range(node); end

  # source://rubocop//lib/rubocop/cop/style/min_max.rb#42
  def message(offender, receiver); end

  # source://rubocop//lib/rubocop/cop/style/min_max.rb#46
  def offending_range(node); end
end

# source://rubocop//lib/rubocop/cop/style/min_max.rb#20
RuboCop::Cop::Style::MinMax::MSG = T.let(T.unsafe(nil), String)

# Enforces the use of `max` or `min` instead of comparison for greater or less.
#
# NOTE: It can be used if you want to present limit or threshold in Ruby 2.7+.
# That it is slow though. So autocorrection will apply generic `max` or `min`:
#
# [source,ruby]
# ----
# a.clamp(b..) # Same as `[a, b].max`
# a.clamp(..b) # Same as `[a, b].min`
# ----
#
# @example
#
#   # bad
#   a > b ? a : b
#   a >= b ? a : b
#
#   # good
#   [a, b].max
#
#   # bad
#   a < b ? a : b
#   a <= b ? a : b
#
#   # good
#   [a, b].min
#
# source://rubocop//lib/rubocop/cop/style/min_max_comparison.rb#37
class RuboCop::Cop::Style::MinMaxComparison < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/min_max_comparison.rb#46
  def on_if(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/min_max_comparison.rb#72
  def autocorrect(corrector, node, replacement); end

  # source://rubocop//lib/rubocop/cop/style/min_max_comparison.rb#64
  def preferred_method(operator, lhs, rhs, if_branch, else_branch); end
end

# source://rubocop//lib/rubocop/cop/style/min_max_comparison.rb#44
RuboCop::Cop::Style::MinMaxComparison::COMPARISON_OPERATORS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/min_max_comparison.rb#42
RuboCop::Cop::Style::MinMaxComparison::GRATER_OPERATORS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/min_max_comparison.rb#43
RuboCop::Cop::Style::MinMaxComparison::LESS_OPERATORS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/min_max_comparison.rb#41
RuboCop::Cop::Style::MinMaxComparison::MSG = T.let(T.unsafe(nil), String)

# Checks for `if` expressions that do not have an `else` branch.
#
# NOTE: Pattern matching is allowed to have no `else` branch because unlike `if` and `case`,
# it raises `NoMatchingPatternError` if the pattern doesn't match and without having `else`.
#
# Supported styles are: if, case, both.
#
# @example EnforcedStyle: both (default)
#   # warn when an `if` or `case` expression is missing an `else` branch.
#
#   # bad
#   if condition
#   statement
#   end
#
#   # bad
#   case var
#   when condition
#   statement
#   end
#
#   # good
#   if condition
#   statement
#   else
#   # the content of `else` branch will be determined by Style/EmptyElse
#   end
#
#   # good
#   case var
#   when condition
#   statement
#   else
#   # the content of `else` branch will be determined by Style/EmptyElse
#   end
# @example EnforcedStyle: if
#   # warn when an `if` expression is missing an `else` branch.
#
#   # bad
#   if condition
#   statement
#   end
#
#   # good
#   if condition
#   statement
#   else
#   # the content of `else` branch will be determined by Style/EmptyElse
#   end
#
#   # good
#   case var
#   when condition
#   statement
#   end
#
#   # good
#   case var
#   when condition
#   statement
#   else
#   # the content of `else` branch will be determined by Style/EmptyElse
#   end
# @example EnforcedStyle: case
#   # warn when a `case` expression is missing an `else` branch.
#
#   # bad
#   case var
#   when condition
#   statement
#   end
#
#   # good
#   case var
#   when condition
#   statement
#   else
#   # the content of `else` branch will be determined by Style/EmptyElse
#   end
#
#   # good
#   if condition
#   statement
#   end
#
#   # good
#   if condition
#   statement
#   else
#   # the content of `else` branch will be determined by Style/EmptyElse
#   end
#
# source://rubocop//lib/rubocop/cop/style/missing_else.rb#99
class RuboCop::Cop::Style::MissingElse < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::OnNormalIfUnless
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/missing_else.rb#115
  def on_case(node); end

  # source://rubocop//lib/rubocop/cop/style/missing_else.rb#121
  def on_case_match(node); end

  # source://rubocop//lib/rubocop/cop/style/missing_else.rb#108
  def on_normal_if_unless(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/missing_else.rb#146
  def autocorrect(corrector, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/missing_else.rb#159
  def case_style?; end

  # source://rubocop//lib/rubocop/cop/style/missing_else.rb#127
  def check(node); end

  # source://rubocop//lib/rubocop/cop/style/missing_else.rb#181
  def empty_else_config; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/missing_else.rb#171
  def empty_else_cop_enabled?; end

  # source://rubocop//lib/rubocop/cop/style/missing_else.rb#175
  def empty_else_style; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/missing_else.rb#155
  def if_style?; end

  # source://rubocop//lib/rubocop/cop/style/missing_else.rb#135
  def message_template; end

  # source://rubocop//lib/rubocop/cop/style/missing_else.rb#167
  def unless_else_config; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/missing_else.rb#163
  def unless_else_cop_enabled?; end
end

# source://rubocop//lib/rubocop/cop/style/missing_else.rb#104
RuboCop::Cop::Style::MissingElse::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/missing_else.rb#106
RuboCop::Cop::Style::MissingElse::MSG_EMPTY = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/missing_else.rb#105
RuboCop::Cop::Style::MissingElse::MSG_NIL = T.let(T.unsafe(nil), String)

# Checks for the presence of `method_missing` without also
# defining `respond_to_missing?`.
#
# @example
#   #bad
#   def method_missing(name, *args)
#   # ...
#   end
#
#   #good
#   def respond_to_missing?(name, include_private)
#   # ...
#   end
#
#   def method_missing(name, *args)
#   # ...
#   end
#
# source://rubocop//lib/rubocop/cop/style/missing_respond_to_missing.rb#24
class RuboCop::Cop::Style::MissingRespondToMissing < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/style/missing_respond_to_missing.rb#27
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/style/missing_respond_to_missing.rb#27
  def on_defs(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/missing_respond_to_missing.rb#37
  def implements_respond_to_missing?(node); end
end

# source://rubocop//lib/rubocop/cop/style/missing_respond_to_missing.rb#25
RuboCop::Cop::Style::MissingRespondToMissing::MSG = T.let(T.unsafe(nil), String)

# Checks for grouping of mixins in `class` and `module` bodies.
# By default it enforces mixins to be placed in separate declarations,
# but it can be configured to enforce grouping them in one declaration.
#
# @example EnforcedStyle: separated (default)
#   # bad
#   class Foo
#   include Bar, Qox
#   end
#
#   # good
#   class Foo
#   include Qox
#   include Bar
#   end
# @example EnforcedStyle: grouped
#   # bad
#   class Foo
#   extend Bar
#   extend Qox
#   end
#
#   # good
#   class Foo
#   extend Qox, Bar
#   end
#
# source://rubocop//lib/rubocop/cop/style/mixin_grouping.rb#33
class RuboCop::Cop::Style::MixinGrouping < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/mixin_grouping.rb#40
  def on_class(node); end

  # source://rubocop//lib/rubocop/cop/style/mixin_grouping.rb#40
  def on_module(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/mixin_grouping.rb#64
  def check(send_node); end

  # source://rubocop//lib/rubocop/cop/style/mixin_grouping.rb#72
  def check_grouped_style(send_node); end

  # source://rubocop//lib/rubocop/cop/style/mixin_grouping.rb#91
  def check_separated_style(send_node); end

  # source://rubocop//lib/rubocop/cop/style/mixin_grouping.rb#127
  def group_mixins(node, mixins); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/mixin_grouping.rb#110
  def grouped_style?; end

  # source://rubocop//lib/rubocop/cop/style/mixin_grouping.rb#53
  def range_to_remove_for_subsequent_mixin(mixins, node); end

  # source://rubocop//lib/rubocop/cop/style/mixin_grouping.rb#118
  def separate_mixins(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/mixin_grouping.rb#114
  def separated_style?; end

  # source://rubocop//lib/rubocop/cop/style/mixin_grouping.rb#104
  def sibling_mixins(send_node); end
end

# source://rubocop//lib/rubocop/cop/style/mixin_grouping.rb#37
RuboCop::Cop::Style::MixinGrouping::MIXIN_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/mixin_grouping.rb#38
RuboCop::Cop::Style::MixinGrouping::MSG = T.let(T.unsafe(nil), String)

# Checks that `include`, `extend` and `prepend` statements appear
# inside classes and modules, not at the top level, so as to not affect
# the behavior of `Object`.
#
# @example
#   # bad
#   include M
#
#   class C
#   end
#
#   # bad
#   extend M
#
#   class C
#   end
#
#   # bad
#   prepend M
#
#   class C
#   end
#
#   # good
#   class C
#   include M
#   end
#
#   # good
#   class C
#   extend M
#   end
#
#   # good
#   class C
#   prepend M
#   end
#
# source://rubocop//lib/rubocop/cop/style/mixin_usage.rb#43
class RuboCop::Cop::Style::MixinUsage < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/style/mixin_usage.rb#54
  def in_top_level_scope?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/mixin_usage.rb#48
  def include_statement(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/mixin_usage.rb#62
  def on_send(node); end
end

# source://rubocop//lib/rubocop/cop/style/mixin_usage.rb#44
RuboCop::Cop::Style::MixinUsage::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/mixin_usage.rb#45
RuboCop::Cop::Style::MixinUsage::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for use of `extend self` or `module_function` in a module.
#
# Supported styles are: `module_function` (default), `extend_self` and `forbidden`.
#
# A couple of things to keep in mind:
#
# - `forbidden` style prohibits the usage of both styles
# - in default mode (`module_function`), the cop won't be activated when the module
#   contains any private methods
#
# @example EnforcedStyle: module_function (default)
#   # bad
#   module Test
#   extend self
#   # ...
#   end
#
#   # good
#   module Test
#   module_function
#   # ...
#   end
#
#   # good
#   module Test
#   extend self
#   # ...
#   private
#   # ...
#   end
#
#   # good
#   module Test
#   class << self
#   # ...
#   end
#   end
# @example EnforcedStyle: extend_self
#   # bad
#   module Test
#   module_function
#   # ...
#   end
#
#   # good
#   module Test
#   extend self
#   # ...
#   end
#
#   # good
#   module Test
#   class << self
#   # ...
#   end
#   end
# @example EnforcedStyle: forbidden
#   # bad
#   module Test
#   module_function
#   # ...
#   end
#
#   # bad
#   module Test
#   extend self
#   # ...
#   end
#
#   # bad
#   module Test
#   extend self
#   # ...
#   private
#   # ...
#   end
#
#   # good
#   module Test
#   class << self
#   # ...
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/style/module_function.rb#95
class RuboCop::Cop::Style::ModuleFunction < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/module_function.rb#107
  def extend_self_node?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/module_function.rb#104
  def module_function_node?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/module_function.rb#112
  def on_module(node); end

  # source://rubocop//lib/rubocop/cop/style/module_function.rb#110
  def private_directive?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/style/module_function.rb#149
  def check_extend_self(nodes); end

  # source://rubocop//lib/rubocop/cop/style/module_function.rb#155
  def check_forbidden(nodes); end

  # source://rubocop//lib/rubocop/cop/style/module_function.rb#141
  def check_module_function(nodes); end

  # source://rubocop//lib/rubocop/cop/style/module_function.rb#130
  def each_wrong_style(nodes, &block); end

  # source://rubocop//lib/rubocop/cop/style/module_function.rb#162
  def message(_range); end
end

# source://rubocop//lib/rubocop/cop/style/module_function.rb#100
RuboCop::Cop::Style::ModuleFunction::EXTEND_SELF_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/module_function.rb#101
RuboCop::Cop::Style::ModuleFunction::FORBIDDEN_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/module_function.rb#99
RuboCop::Cop::Style::ModuleFunction::MODULE_FUNCTION_MSG = T.let(T.unsafe(nil), String)

# Checks for chaining of a block after another block that spans
# multiple lines.
#
# @example
#
#   # bad
#   Thread.list.select do |t|
#   t.alive?
#   end.map do |t|
#   t.object_id
#   end
#
#   # good
#   alive_threads = Thread.list.select do |t|
#   t.alive?
#   end
#   alive_threads.map do |t|
#   t.object_id
#   end
#
# source://rubocop//lib/rubocop/cop/style/multiline_block_chain.rb#25
class RuboCop::Cop::Style::MultilineBlockChain < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop//lib/rubocop/cop/style/multiline_block_chain.rb#30
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/style/multiline_block_chain.rb#30
  def on_numblock(node); end
end

# source://rubocop//lib/rubocop/cop/style/multiline_block_chain.rb#28
RuboCop::Cop::Style::MultilineBlockChain::MSG = T.let(T.unsafe(nil), String)

# Checks for uses of if/unless modifiers with multiple-lines bodies.
#
# @example
#
#   # bad
#   {
#   result: 'this should not happen'
#   } unless cond
#
#   # good
#   { result: 'ok' } if cond
#
# source://rubocop//lib/rubocop/cop/style/multiline_if_modifier.rb#17
class RuboCop::Cop::Style::MultilineIfModifier < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::LineLengthHelp
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::StatementModifier
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/multiline_if_modifier.rb#25
  def on_if(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/multiline_if_modifier.rb#43
  def indented_body(body, node); end

  # source://rubocop//lib/rubocop/cop/style/multiline_if_modifier.rb#35
  def to_normal_if(node); end
end

# source://rubocop//lib/rubocop/cop/style/multiline_if_modifier.rb#22
RuboCop::Cop::Style::MultilineIfModifier::MSG = T.let(T.unsafe(nil), String)

# Checks for uses of the `then` keyword in multi-line if statements.
#
# @example
#   # bad
#   # This is considered bad practice.
#   if cond then
#   end
#
#   # good
#   # If statements can contain `then` on the same line.
#   if cond then a
#   elsif cond then b
#   end
#
# source://rubocop//lib/rubocop/cop/style/multiline_if_then.rb#19
class RuboCop::Cop::Style::MultilineIfThen < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::OnNormalIfUnless
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/multiline_if_then.rb#28
  def on_normal_if_unless(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/multiline_if_then.rb#38
  def non_modifier_then?(node); end
end

# source://rubocop//lib/rubocop/cop/style/multiline_if_then.rb#26
RuboCop::Cop::Style::MultilineIfThen::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/multiline_if_then.rb#24
RuboCop::Cop::Style::MultilineIfThen::NON_MODIFIER_THEN = T.let(T.unsafe(nil), Regexp)

# Checks uses of the `then` keyword in multi-line `in` statement.
#
# @example
#   # bad
#   case expression
#   in pattern then
#   end
#
#   # good
#   case expression
#   in pattern
#   end
#
#   # good
#   case expression
#   in pattern then do_something
#   end
#
#   # good
#   case expression
#   in pattern then do_something(arg1,
#   arg2)
#   end
#
# source://rubocop//lib/rubocop/cop/style/multiline_in_pattern_then.rb#30
class RuboCop::Cop::Style::MultilineInPatternThen < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop//lib/rubocop/cop/style/multiline_in_pattern_then.rb#39
  def on_in_pattern(node); end

  private

  # Requires `then` for write `in` and its body on the same line.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/multiline_in_pattern_then.rb#51
  def require_then?(in_pattern_node); end
end

# source://rubocop//lib/rubocop/cop/style/multiline_in_pattern_then.rb#37
RuboCop::Cop::Style::MultilineInPatternThen::MSG = T.let(T.unsafe(nil), String)

# Checks expressions wrapping styles for multiline memoization.
#
# @example EnforcedStyle: keyword (default)
#   # bad
#   foo ||= (
#   bar
#   baz
#   )
#
#   # good
#   foo ||= begin
#   bar
#   baz
#   end
# @example EnforcedStyle: braces
#   # bad
#   foo ||= begin
#   bar
#   baz
#   end
#
#   # good
#   foo ||= (
#   bar
#   baz
#   )
#
# source://rubocop//lib/rubocop/cop/style/multiline_memoization.rb#33
class RuboCop::Cop::Style::MultilineMemoization < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/multiline_memoization.rb#56
  def message(_node); end

  # source://rubocop//lib/rubocop/cop/style/multiline_memoization.rb#41
  def on_or_asgn(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/multiline_memoization.rb#62
  def bad_rhs?(rhs); end

  # source://rubocop//lib/rubocop/cop/style/multiline_memoization.rb#72
  def keyword_autocorrect(node, corrector); end

  # source://rubocop//lib/rubocop/cop/style/multiline_memoization.rb#78
  def keyword_begin_str(node, node_buf); end

  # source://rubocop//lib/rubocop/cop/style/multiline_memoization.rb#86
  def keyword_end_str(node, node_buf); end
end

# source://rubocop//lib/rubocop/cop/style/multiline_memoization.rb#39
RuboCop::Cop::Style::MultilineMemoization::BRACES_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/multiline_memoization.rb#38
RuboCop::Cop::Style::MultilineMemoization::KEYWORD_MSG = T.let(T.unsafe(nil), String)

# Checks for method signatures that span multiple lines.
#
# @example
#
#   # good
#
#   def foo(bar, baz)
#   end
#
#   # bad
#
#   def foo(bar,
#   baz)
#   end
#
# source://rubocop//lib/rubocop/cop/style/multiline_method_signature.rb#21
class RuboCop::Cop::Style::MultilineMethodSignature < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/multiline_method_signature.rb#27
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/style/multiline_method_signature.rb#27
  def on_defs(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/multiline_method_signature.rb#57
  def arguments_range(node); end

  # source://rubocop//lib/rubocop/cop/style/multiline_method_signature.rb#38
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/multiline_method_signature.rb#69
  def closing_line(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/multiline_method_signature.rb#73
  def correction_exceeds_max_line_length?(node); end

  # source://rubocop//lib/rubocop/cop/style/multiline_method_signature.rb#81
  def definition_width(node); end

  # source://rubocop//lib/rubocop/cop/style/multiline_method_signature.rb#77
  def indentation_width(node); end

  # source://rubocop//lib/rubocop/cop/style/multiline_method_signature.rb#53
  def last_line_source_of_arguments(arguments); end

  # source://rubocop//lib/rubocop/cop/style/multiline_method_signature.rb#85
  def max_line_length; end

  # source://rubocop//lib/rubocop/cop/style/multiline_method_signature.rb#65
  def opening_line(node); end
end

# source://rubocop//lib/rubocop/cop/style/multiline_method_signature.rb#25
RuboCop::Cop::Style::MultilineMethodSignature::MSG = T.let(T.unsafe(nil), String)

# Checks for multi-line ternary op expressions.
#
# NOTE: `return if ... else ... end` is syntax error. If `return` is used before
# multiline ternary operator expression, it will be autocorrected to single-line
# ternary operator. The same is true for `break`, `next`, and method call.
#
# @example
#   # bad
#   a = cond ?
#   b : c
#   a = cond ? b :
#   c
#   a = cond ?
#   b :
#   c
#
#   return cond ?
#   b :
#   c
#
#   # good
#   a = cond ? b : c
#   a = if cond
#   b
#   else
#   c
#   end
#
#   return cond ? b : c
#
# source://rubocop//lib/rubocop/cop/style/multiline_ternary_operator.rb#36
class RuboCop::Cop::Style::MultilineTernaryOperator < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::CommentsHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/multiline_ternary_operator.rb#44
  def on_if(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/multiline_ternary_operator.rb#60
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/multiline_ternary_operator.rb#84
  def comments_in_condition(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/multiline_ternary_operator.rb#90
  def enforce_single_line_ternary_operator?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/multiline_ternary_operator.rb#56
  def offense?(node); end

  # source://rubocop//lib/rubocop/cop/style/multiline_ternary_operator.rb#70
  def replacement(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/multiline_ternary_operator.rb#94
  def use_assignment_method?(node); end
end

# source://rubocop//lib/rubocop/cop/style/multiline_ternary_operator.rb#40
RuboCop::Cop::Style::MultilineTernaryOperator::MSG_IF = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/multiline_ternary_operator.rb#41
RuboCop::Cop::Style::MultilineTernaryOperator::MSG_SINGLE_LINE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/multiline_ternary_operator.rb#42
RuboCop::Cop::Style::MultilineTernaryOperator::SINGLE_LINE_TYPES = T.let(T.unsafe(nil), Array)

# Checks uses of the `then` keyword
# in multi-line when statements.
#
# @example
#   # bad
#   case foo
#   when bar then
#   end
#
#   # good
#   case foo
#   when bar
#   end
#
#   # good
#   case foo
#   when bar then do_something
#   end
#
#   # good
#   case foo
#   when bar then do_something(arg1,
#   arg2)
#   end
#
# source://rubocop//lib/rubocop/cop/style/multiline_when_then.rb#31
class RuboCop::Cop::Style::MultilineWhenThen < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/multiline_when_then.rb#37
  def on_when(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/multiline_when_then.rb#58
  def accept_node_type?(node); end

  # Requires `then` for write `when` and its body on the same line.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/multiline_when_then.rb#49
  def require_then?(when_node); end
end

# source://rubocop//lib/rubocop/cop/style/multiline_when_then.rb#35
RuboCop::Cop::Style::MultilineWhenThen::MSG = T.let(T.unsafe(nil), String)

# Checks against comparing a variable with multiple items, where
# `Array#include?`, `Set#include?` or a `case` could be used instead
# to avoid code repetition.
# It accepts comparisons of multiple method calls to avoid unnecessary method calls
# by default. It can be configured by `AllowMethodComparison` option.
#
# @example
#   # bad
#   a = 'a'
#   foo if a == 'a' || a == 'b' || a == 'c'
#
#   # good
#   a = 'a'
#   foo if ['a', 'b', 'c'].include?(a)
#
#   VALUES = Set['a', 'b', 'c'].freeze
#   # elsewhere...
#   foo if VALUES.include?(a)
#
#   case foo
#   when 'a', 'b', 'c' then foo
#   # ...
#   end
#
#   # accepted (but consider `case` as above)
#   foo if a == b.lightweight || a == b.heavyweight
# @example AllowMethodComparison: true (default)
#   # good
#   foo if a == b.lightweight || a == b.heavyweight
# @example AllowMethodComparison: false
#   # bad
#   foo if a == b.lightweight || a == b.heavyweight
#
#   # good
#   foo if [b.lightweight, b.heavyweight].include?(a)
#
# source://rubocop//lib/rubocop/cop/style/multiple_comparison.rb#43
class RuboCop::Cop::Style::MultipleComparison < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/multiple_comparison.rb#49
  def on_new_investigation; end

  # source://rubocop//lib/rubocop/cop/style/multiple_comparison.rb#53
  def on_or(node); end

  # source://rubocop//lib/rubocop/cop/style/multiple_comparison.rb#78
  def simple_comparison_lhs?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/multiple_comparison.rb#83
  def simple_comparison_rhs?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/multiple_comparison.rb#75
  def simple_double_comparison?(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/multiple_comparison.rb#151
  def allow_method_comparison?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/multiple_comparison.rb#126
  def comparison?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/multiple_comparison.rb#118
  def nested_comparison?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/multiple_comparison.rb#87
  def nested_variable_comparison?(node); end

  # source://rubocop//lib/rubocop/cop/style/multiple_comparison.rb#146
  def reset_comparison; end

  # source://rubocop//lib/rubocop/cop/style/multiple_comparison.rb#130
  def root_of_or_node(or_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/multiple_comparison.rb#140
  def switch_comparison?(node); end

  # source://rubocop//lib/rubocop/cop/style/multiple_comparison.rb#114
  def variable_name(node); end

  # source://rubocop//lib/rubocop/cop/style/multiple_comparison.rb#93
  def variables_in_node(node); end

  # source://rubocop//lib/rubocop/cop/style/multiple_comparison.rb#101
  def variables_in_simple_node(node); end
end

# source://rubocop//lib/rubocop/cop/style/multiple_comparison.rb#46
RuboCop::Cop::Style::MultipleComparison::MSG = T.let(T.unsafe(nil), String)

# Checks whether some constant value isn't a
# mutable literal (e.g. array or hash).
#
# Strict mode can be used to freeze all constants, rather than
# just literals.
# Strict mode is considered an experimental feature. It has not been
# updated with an exhaustive list of all methods that will produce
# frozen objects so there is a decent chance of getting some false
# positives. Luckily, there is no harm in freezing an already
# frozen object.
#
# From Ruby 3.0, this cop honours the magic comment
# 'shareable_constant_value'. When this magic comment is set to any
# acceptable value other than none, it will suppress the offenses
# raised by this cop. It enforces frozen state.
#
# NOTE: Regexp and Range literals are frozen objects since Ruby 3.0.
#
# NOTE: From Ruby 3.0, interpolated strings are not frozen when
# `# frozen-string-literal: true` is used, so this cop enforces explicit
# freezing for such strings.
#
# NOTE: From Ruby 3.0, this cop allows explicit freezing of constants when
# the `shareable_constant_value` directive is used.
#
# @example EnforcedStyle: literals (default)
#   # bad
#   CONST = [1, 2, 3]
#
#   # good
#   CONST = [1, 2, 3].freeze
#
#   # good
#   CONST = <<~TESTING.freeze
#   This is a heredoc
#   TESTING
#
#   # good
#   CONST = Something.new
# @example EnforcedStyle: strict
#   # bad
#   CONST = Something.new
#
#   # bad
#   CONST = Struct.new do
#   def foo
#   puts 1
#   end
#   end
#
#   # good
#   CONST = Something.new.freeze
#
#   # good
#   CONST = Struct.new do
#   def foo
#   puts 1
#   end
#   end.freeze
# @example
#   # Magic comment - shareable_constant_value: literal
#
#   # bad
#   CONST = [1, 2, 3]
#
#   # good
#   # shareable_constant_value: literal
#   CONST = [1, 2, 3]
#
# source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#83
class RuboCop::Cop::Style::MutableConstant < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Style::MutableConstant::ShareableConstantValue
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#127
  def on_casgn(node); end

  # Some of these patterns may not actually return an immutable object,
  # but we want to consider them immutable for this cop.
  #
  # source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#224
  def operation_produces_immutable_object?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#241
  def range_enclosed_in_parentheses?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#217
  def splat_value(param0 = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#169
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#158
  def check(value); end

  # source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#208
  def correct_splat_expansion(corrector, expr, splat_value); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#200
  def frozen_regexp_or_range_literals?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#190
  def immutable_literal?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#184
  def mutable_literal?(value); end

  # source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#141
  def on_assignment(value); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#204
  def requires_parentheses?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#194
  def shareable_constant_value?(node); end

  # source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#149
  def strict_check(value); end
end

# source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#125
RuboCop::Cop::Style::MutableConstant::MSG = T.let(T.unsafe(nil), String)

# Handles magic comment shareable_constant_value with O(n ^ 2) complexity
# n - number of lines in the source
# Iterates over all lines before a CONSTANT
# until it reaches shareable_constant_value
#
# source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#88
module RuboCop::Cop::Style::MutableConstant::ShareableConstantValue
  private

  # Identifies the most recent magic comment with valid shareable constant values
  # that's in scope for this node
  #
  # source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#102
  def magic_comment_in_scope(node); end

  # source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#110
  def processed_source_till_node(node); end

  # source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#91
  def recent_shareable_value?(node); end

  # source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#114
  def shareable_constant_value_enabled?(value); end

  class << self
    # Identifies the most recent magic comment with valid shareable constant values
    # that's in scope for this node
    #
    # source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#102
    def magic_comment_in_scope(node); end

    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#91
    def recent_shareable_value?(node); end
  end
end

# Checks for uses of if with a negated condition. Only ifs
# without else are considered. There are three different styles:
#
# * both
# * prefix
# * postfix
#
# @example EnforcedStyle: both (default)
#   # enforces `unless` for `prefix` and `postfix` conditionals
#
#   # bad
#
#   if !foo
#   bar
#   end
#
#   # good
#
#   unless foo
#   bar
#   end
#
#   # bad
#
#   bar if !foo
#
#   # good
#
#   bar unless foo
# @example EnforcedStyle: prefix
#   # enforces `unless` for just `prefix` conditionals
#
#   # bad
#
#   if !foo
#   bar
#   end
#
#   # good
#
#   unless foo
#   bar
#   end
#
#   # good
#
#   bar if !foo
# @example EnforcedStyle: postfix
#   # enforces `unless` for just `postfix` conditionals
#
#   # bad
#
#   bar if !foo
#
#   # good
#
#   bar unless foo
#
#   # good
#
#   if !foo
#   bar
#   end
#
# source://rubocop//lib/rubocop/cop/style/negated_if.rb#71
class RuboCop::Cop::Style::NegatedIf < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::NegativeConditional
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/negated_if.rb#76
  def on_if(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/negated_if.rb#92
  def correct_style?(node); end

  # source://rubocop//lib/rubocop/cop/style/negated_if.rb#88
  def message(node); end
end

# Checks for uses of `if-else` and ternary operators with a negated condition
# which can be simplified by inverting condition and swapping branches.
#
# @example
#   # bad
#   if !x
#   do_something
#   else
#   do_something_else
#   end
#
#   # good
#   if x
#   do_something_else
#   else
#   do_something
#   end
#
#   # bad
#   !x ? do_something : do_something_else
#
#   # good
#   x ? do_something_else : do_something
#
# source://rubocop//lib/rubocop/cop/style/negated_if_else_condition.rb#30
class RuboCop::Cop::Style::NegatedIfElseCondition < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/negated_if_else_condition.rb#39
  def double_negation?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/negated_if_else_condition.rb#49
  def on_if(node); end

  # source://rubocop//lib/rubocop/cop/style/negated_if_else_condition.rb#45
  def on_new_investigation; end

  private

  # source://rubocop//lib/rubocop/cop/style/negated_if_else_condition.rb#94
  def correct_negated_condition(corrector, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/negated_if_else_condition.rb#90
  def corrected_ancestor?(node); end

  # Collect the entire else branch, including whitespace and comments
  #
  # source://rubocop//lib/rubocop/cop/style/negated_if_else_condition.rb#125
  def else_range(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/negated_if_else_condition.rb#68
  def if_else?(node); end

  # Collect the entire if branch, including whitespace and comments
  #
  # source://rubocop//lib/rubocop/cop/style/negated_if_else_condition.rb#116
  def if_range(node); end

  # source://rubocop//lib/rubocop/cop/style/negated_if_else_condition.rb#84
  def message(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/negated_if_else_condition.rb#79
  def negated_condition?(node); end

  # source://rubocop//lib/rubocop/cop/style/negated_if_else_condition.rb#107
  def swap_branches(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/negated_if_else_condition.rb#73
  def unwrap_begin_nodes(node); end

  class << self
    # source://rubocop//lib/rubocop/cop/style/negated_if_else_condition.rb#41
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop//lib/rubocop/cop/style/negated_if_else_condition.rb#34
RuboCop::Cop::Style::NegatedIfElseCondition::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/negated_if_else_condition.rb#36
RuboCop::Cop::Style::NegatedIfElseCondition::NEGATED_EQUALITY_METHODS = T.let(T.unsafe(nil), Array)

# Checks for uses of unless with a negated condition. Only unless
# without else are considered. There are three different styles:
#
# * both
# * prefix
# * postfix
#
# @example EnforcedStyle: both (default)
#   # enforces `if` for `prefix` and `postfix` conditionals
#
#   # bad
#   unless !foo
#   bar
#   end
#
#   # good
#   if foo
#   bar
#   end
#
#   # bad
#   bar unless !foo
#
#   # good
#   bar if foo
# @example EnforcedStyle: prefix
#   # enforces `if` for just `prefix` conditionals
#
#   # bad
#   unless !foo
#   bar
#   end
#
#   # good
#   if foo
#   bar
#   end
#
#   # good
#   bar unless !foo
# @example EnforcedStyle: postfix
#   # enforces `if` for just `postfix` conditionals
#
#   # bad
#   bar unless !foo
#
#   # good
#   bar if foo
#
#   # good
#   unless !foo
#   bar
#   end
#
# source://rubocop//lib/rubocop/cop/style/negated_unless.rb#61
class RuboCop::Cop::Style::NegatedUnless < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::NegativeConditional
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/negated_unless.rb#66
  def on_if(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/negated_unless.rb#82
  def correct_style?(node); end

  # source://rubocop//lib/rubocop/cop/style/negated_unless.rb#78
  def message(node); end
end

# Checks for uses of while with a negated condition.
#
# @example
#   # bad
#   while !foo
#   bar
#   end
#
#   # good
#   until foo
#   bar
#   end
#
#   # bad
#   bar until !foo
#
#   # good
#   bar while foo
#   bar while !foo && baz
#
# source://rubocop//lib/rubocop/cop/style/negated_while.rb#25
class RuboCop::Cop::Style::NegatedWhile < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::NegativeConditional
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/negated_while.rb#29
  def on_until(node); end

  # source://rubocop//lib/rubocop/cop/style/negated_while.rb#29
  def on_while(node); end
end

# Checks for nested `File.dirname`.
# It replaces nested `File.dirname` with the level argument introduced in Ruby 3.1.
#
# @example
#
#   # bad
#   File.dirname(File.dirname(path))
#
#   # good
#   File.dirname(path, 2)
#
# source://rubocop//lib/rubocop/cop/style/nested_file_dirname.rb#17
class RuboCop::Cop::Style::NestedFileDirname < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop//lib/rubocop/cop/style/nested_file_dirname.rb#28
  def file_dirname?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/nested_file_dirname.rb#33
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/nested_file_dirname.rb#60
  def offense_range(node); end

  # source://rubocop//lib/rubocop/cop/style/nested_file_dirname.rb#49
  def path_with_dir_level(node, level); end
end

# source://rubocop//lib/rubocop/cop/style/nested_file_dirname.rb#22
RuboCop::Cop::Style::NestedFileDirname::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/nested_file_dirname.rb#23
RuboCop::Cop::Style::NestedFileDirname::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for nested use of if, unless, while and until in their
# modifier form.
#
# @example
#
#   # bad
#   something if a if b
#
#   # good
#   something if b && a
#
# source://rubocop//lib/rubocop/cop/style/nested_modifier.rb#16
class RuboCop::Cop::Style::NestedModifier < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/nested_modifier.rb#22
  def on_if(node); end

  # source://rubocop//lib/rubocop/cop/style/nested_modifier.rb#22
  def on_until(node); end

  # source://rubocop//lib/rubocop/cop/style/nested_modifier.rb#22
  def on_while(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/nested_modifier.rb#85
  def add_parentheses_to_method_arguments(send_node); end

  # source://rubocop//lib/rubocop/cop/style/nested_modifier.rb#42
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/nested_modifier.rb#30
  def check(node); end

  # source://rubocop//lib/rubocop/cop/style/nested_modifier.rb#65
  def left_hand_operand(node, operator); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/nested_modifier.rb#38
  def modifier?(node); end

  # source://rubocop//lib/rubocop/cop/style/nested_modifier.rb#51
  def new_expression(inner_node); end

  # source://rubocop//lib/rubocop/cop/style/nested_modifier.rb#61
  def replacement_operator(keyword); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/nested_modifier.rb#94
  def requires_parens?(node); end

  # source://rubocop//lib/rubocop/cop/style/nested_modifier.rb#71
  def right_hand_operand(node, left_hand_keyword); end
end

# source://rubocop//lib/rubocop/cop/style/nested_modifier.rb#20
RuboCop::Cop::Style::NestedModifier::MSG = T.let(T.unsafe(nil), String)

# Checks for unparenthesized method calls in the argument list
# of a parenthesized method call.
# `be`, `be_a`, `be_an`, `be_between`, `be_falsey`, `be_kind_of`, `be_instance_of`,
# `be_truthy`, `be_within`, `eq`, `eql`, `end_with`, `include`, `match`, `raise_error`,
# `respond_to`, and `start_with` methods are allowed by default.
# These are customizable with `AllowedMethods` option.
#
# @example
#   # good
#   method1(method2(arg))
#
#   # bad
#   method1(method2 arg)
# @example AllowedMethods: [foo]
#   # good
#   method1(foo arg)
#
# source://rubocop//lib/rubocop/cop/style/nested_parenthesized_calls.rb#24
class RuboCop::Cop::Style::NestedParenthesizedCalls < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::AllowedMethods
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/nested_parenthesized_calls.rb#35
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/style/nested_parenthesized_calls.rb#35
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/nested_parenthesized_calls.rb#71
  def allowed?(send_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/nested_parenthesized_calls.rb#65
  def allowed_omission?(send_node); end

  # source://rubocop//lib/rubocop/cop/style/nested_parenthesized_calls.rb#51
  def autocorrect(corrector, nested); end

  class << self
    # source://rubocop//lib/rubocop/cop/style/nested_parenthesized_calls.rb#31
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop//lib/rubocop/cop/style/nested_parenthesized_calls.rb#29
RuboCop::Cop::Style::NestedParenthesizedCalls::MSG = T.let(T.unsafe(nil), String)

# Checks for nested ternary op expressions.
#
# @example
#   # bad
#   a ? (b ? b1 : b2) : a2
#
#   # good
#   if a
#   b ? b1 : b2
#   else
#   a2
#   end
#
# source://rubocop//lib/rubocop/cop/style/nested_ternary_operator.rb#18
class RuboCop::Cop::Style::NestedTernaryOperator < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/nested_ternary_operator.rb#25
  def on_if(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/nested_ternary_operator.rb#48
  def autocorrect(corrector, if_node); end

  # source://rubocop//lib/rubocop/cop/style/nested_ternary_operator.rb#41
  def if_node(node); end

  # source://rubocop//lib/rubocop/cop/style/nested_ternary_operator.rb#55
  def remove_parentheses(source); end

  # source://rubocop//lib/rubocop/cop/style/nested_ternary_operator.rb#61
  def replace_loc_and_whitespace(corrector, range, replacement); end
end

# source://rubocop//lib/rubocop/cop/style/nested_ternary_operator.rb#23
RuboCop::Cop::Style::NestedTernaryOperator::MSG = T.let(T.unsafe(nil), String)

# Use `next` to skip iteration instead of a condition at the end.
#
# @example EnforcedStyle: skip_modifier_ifs (default)
#   # bad
#   [1, 2].each do |a|
#   if a == 1
#   puts a
#   end
#   end
#
#   # good
#   [1, 2].each do |a|
#   next unless a == 1
#   puts a
#   end
#
#   # good
#   [1, 2].each do |a|
#   puts a if a == 1
#   end
# @example EnforcedStyle: always
#   # With `always` all conditions at the end of an iteration needs to be
#   # replaced by next - with `skip_modifier_ifs` the modifier if like
#   # this one are ignored: `[1, 2].each { |a| puts a if a == 1 }`
#
#   # bad
#   [1, 2].each do |a|
#   puts a if a == 1
#   end
#
#   # bad
#   [1, 2].each do |a|
#   if a == 1
#   puts a
#   end
#   end
#
#   # good
#   [1, 2].each do |a|
#   next unless a == 1
#   puts a
#   end
#
# source://rubocop//lib/rubocop/cop/style/next.rb#49
class RuboCop::Cop::Style::Next < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MinBodyLength
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/next.rb#68
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/style/next.rb#76
  def on_for(node); end

  # source://rubocop//lib/rubocop/cop/style/next.rb#62
  def on_new_investigation; end

  # source://rubocop//lib/rubocop/cop/style/next.rb#68
  def on_numblock(node); end

  # source://rubocop//lib/rubocop/cop/style/next.rb#76
  def on_until(node); end

  # source://rubocop//lib/rubocop/cop/style/next.rb#76
  def on_while(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/next.rb#213
  def actual_indent(lines, buffer); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/next.rb#112
  def allowed_modifier_if?(node); end

  # source://rubocop//lib/rubocop/cop/style/next.rb#155
  def autocorrect_block(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/next.rb#145
  def autocorrect_modifier(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/next.rb#84
  def check(node); end

  # source://rubocop//lib/rubocop/cop/style/next.rb#170
  def cond_range(node, cond); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/next.rb#189
  def end_followed_by_whitespace_only?(source_buffer, end_pos); end

  # source://rubocop//lib/rubocop/cop/style/next.rb#180
  def end_range(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/next.rb#98
  def ends_with_condition?(body); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/next.rb#128
  def exit_body_type?(node); end

  # source://rubocop//lib/rubocop/cop/style/next.rb#217
  def heredoc_lines(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/next.rb#120
  def if_else_children?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/next.rb#124
  def if_without_else?(node); end

  # source://rubocop//lib/rubocop/cop/style/next.rb#140
  def offense_location(offense_node); end

  # source://rubocop//lib/rubocop/cop/style/next.rb#134
  def offense_node(body); end

  # Adjust indentation of `lines` to match `node`
  #
  # source://rubocop//lib/rubocop/cop/style/next.rb#204
  def reindent(lines, node, corrector); end

  # source://rubocop//lib/rubocop/cop/style/next.rb#224
  def reindent_line(corrector, lineno, delta, buffer); end

  # source://rubocop//lib/rubocop/cop/style/next.rb#193
  def reindentable_lines(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/next.rb#104
  def simple_if_without_break?(node); end

  class << self
    # source://rubocop//lib/rubocop/cop/style/next.rb#58
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop//lib/rubocop/cop/style/next.rb#56
RuboCop::Cop::Style::Next::EXIT_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/next.rb#55
RuboCop::Cop::Style::Next::MSG = T.let(T.unsafe(nil), String)

# Checks for comparison of something with nil using `==` and
# `nil?`.
#
# Supported styles are: predicate, comparison.
#
# @example EnforcedStyle: predicate (default)
#
#   # bad
#   if x == nil
#   end
#
#   # good
#   if x.nil?
#   end
# @example EnforcedStyle: comparison
#
#   # bad
#   if x.nil?
#   end
#
#   # good
#   if x == nil
#   end
#
# source://rubocop//lib/rubocop/cop/style/nil_comparison.rb#31
class RuboCop::Cop::Style::NilComparison < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/nil_comparison.rb#44
  def nil_check?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/nil_comparison.rb#41
  def nil_comparison?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/nil_comparison.rb#46
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/nil_comparison.rb#65
  def message(_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/nil_comparison.rb#77
  def prefer_comparison?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/nil_comparison.rb#69
  def style_check?(node, &block); end
end

# source://rubocop//lib/rubocop/cop/style/nil_comparison.rb#36
RuboCop::Cop::Style::NilComparison::EXPLICIT_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/nil_comparison.rb#35
RuboCop::Cop::Style::NilComparison::PREDICATE_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/nil_comparison.rb#38
RuboCop::Cop::Style::NilComparison::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for lambdas and procs that always return nil,
# which can be replaced with an empty lambda or proc instead.
#
# @example
#   # bad
#   -> { nil }
#
#   lambda do
#   next nil
#   end
#
#   proc { nil }
#
#   Proc.new do
#   break nil
#   end
#
#   # good
#   -> {}
#
#   lambda do
#   end
#
#   -> (x) { nil if x }
#
#   proc {}
#
#   Proc.new { nil if x }
#
# source://rubocop//lib/rubocop/cop/style/nil_lambda.rb#35
class RuboCop::Cop::Style::NilLambda < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/nil_lambda.rb#42
  def nil_return?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/nil_lambda.rb#46
  def on_block(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/nil_lambda.rb#58
  def autocorrect(corrector, node); end
end

# source://rubocop//lib/rubocop/cop/style/nil_lambda.rb#39
RuboCop::Cop::Style::NilLambda::MSG = T.let(T.unsafe(nil), String)

# Checks for non-nil checks, which are usually redundant.
#
# With `IncludeSemanticChanges` set to `false` by default, this cop
# does not report offenses for `!x.nil?` and does no changes that might
# change behavior.
# Also `IncludeSemanticChanges` set to `false` with `EnforcedStyle: comparison` of
# `Style/NilComparison` cop, this cop does not report offenses for `x != nil` and
# does no changes to `!x.nil?` style.
#
# With `IncludeSemanticChanges` set to `true`, this cop reports offenses
# for `!x.nil?` and autocorrects that and `x != nil` to solely `x`, which
# is *usually* OK, but might change behavior.
#
# @example
#   # bad
#   if x != nil
#   end
#
#   # good
#   if x
#   end
#
#   # Non-nil checks are allowed if they are the final nodes of predicate.
#   # good
#   def signed_in?
#   !current_user.nil?
#   end
# @example IncludeSemanticChanges: false (default)
#   # good
#   if !x.nil?
#   end
# @example IncludeSemanticChanges: true
#   # bad
#   if !x.nil?
#   end
#
# source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#44
class RuboCop::Cop::Style::NonNilCheck < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#59
  def nil_check?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#62
  def not_and_nil_check?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#53
  def not_equal_to_nil?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#73
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#73
  def on_defs(node); end

  # source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#64
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#56
  def unless_check?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#93
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#123
  def autocorrect_comparison(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#137
  def autocorrect_non_nil(corrector, node, inner_node); end

  # source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#145
  def autocorrect_unless_nil(corrector, node, receiver); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#119
  def include_semantic_changes?; end

  # source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#110
  def message(node); end

  # source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#150
  def nil_comparison_style; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#88
  def register_offense?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#104
  def unless_and_nil_check?(send_node); end
end

# source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#48
RuboCop::Cop::Style::NonNilCheck::MSG_FOR_REDUNDANCY = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#47
RuboCop::Cop::Style::NonNilCheck::MSG_FOR_REPLACEMENT = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#50
RuboCop::Cop::Style::NonNilCheck::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for uses of the keyword `not` instead of `!`.
#
# @example
#
#   # bad - parentheses are required because of op precedence
#   x = (not something)
#
#   # good
#   x = !something
#
# source://rubocop//lib/rubocop/cop/style/not.rb#16
class RuboCop::Cop::Style::Not < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/not.rb#32
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/not.rb#60
  def correct_opposite_method(corrector, range, child); end

  # source://rubocop//lib/rubocop/cop/style/not.rb#65
  def correct_with_parens(corrector, range, node); end

  # source://rubocop//lib/rubocop/cop/style/not.rb#70
  def correct_without_parens(corrector, range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/not.rb#50
  def opposite_method?(child); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/not.rb#54
  def requires_parens?(child); end
end

# source://rubocop//lib/rubocop/cop/style/not.rb#20
RuboCop::Cop::Style::Not::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/not.rb#23
RuboCop::Cop::Style::Not::OPPOSITE_METHODS = T.let(T.unsafe(nil), Hash)

# source://rubocop//lib/rubocop/cop/style/not.rb#21
RuboCop::Cop::Style::Not::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for numbered parameters.
#
# It can either restrict the use of numbered parameters to
# single-lined blocks, or disallow completely numbered parameters.
#
# @example EnforcedStyle: allow_single_line (default)
#   # bad
#   collection.each do
#   puts _1
#   end
#
#   # good
#   collection.each { puts _1 }
# @example EnforcedStyle: disallow
#   # bad
#   collection.each { puts _1 }
#
#   # good
#   collection.each { |item| puts item }
#
# source://rubocop//lib/rubocop/cop/style/numbered_parameters.rb#27
class RuboCop::Cop::Style::NumberedParameters < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop//lib/rubocop/cop/style/numbered_parameters.rb#36
  def on_numblock(node); end
end

# source://rubocop//lib/rubocop/cop/style/numbered_parameters.rb#31
RuboCop::Cop::Style::NumberedParameters::MSG_DISALLOW = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/numbered_parameters.rb#32
RuboCop::Cop::Style::NumberedParameters::MSG_MULTI_LINE = T.let(T.unsafe(nil), String)

# Detects use of an excessive amount of numbered parameters in a
# single block. Having too many numbered parameters can make code too
# cryptic and hard to read.
#
# The cop defaults to registering an offense if there is more than 1 numbered
# parameter but this maximum can be configured by setting `Max`.
#
# @example Max: 1 (default)
#   # bad
#   use_multiple_numbered_parameters { _1.call(_2, _3, _4) }
#
#   # good
#   array.each { use_array_element_as_numbered_parameter(_1) }
#   hash.each { use_only_hash_value_as_numbered_parameter(_2) }
#
# source://rubocop//lib/rubocop/cop/style/numbered_parameters_limit.rb#20
class RuboCop::Cop::Style::NumberedParametersLimit < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop//lib/rubocop/cop/exclude_limit.rb#11
  def max=(value); end

  # source://rubocop//lib/rubocop/cop/style/numbered_parameters_limit.rb#32
  def on_numblock(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/numbered_parameters_limit.rb#49
  def max_count; end

  # source://rubocop//lib/rubocop/cop/style/numbered_parameters_limit.rb#43
  def numbered_parameter_nodes(node); end
end

# source://rubocop//lib/rubocop/cop/style/numbered_parameters_limit.rb#24
RuboCop::Cop::Style::NumberedParametersLimit::DEFAULT_MAX_VALUE = T.let(T.unsafe(nil), Integer)

# source://rubocop//lib/rubocop/cop/style/numbered_parameters_limit.rb#29
RuboCop::Cop::Style::NumberedParametersLimit::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/numbered_parameters_limit.rb#30
RuboCop::Cop::Style::NumberedParametersLimit::NUMBERED_PARAMETER_PATTERN = T.let(T.unsafe(nil), Regexp)

# Checks for octal, hex, binary, and decimal literals using
# uppercase prefixes and corrects them to lowercase prefix
# or no prefix (in case of decimals).
#
# @example EnforcedOctalStyle: zero_with_o (default)
#   # bad - missing octal prefix
#   num = 01234
#
#   # bad - uppercase prefix
#   num = 0O1234
#   num = 0X12AB
#   num = 0B10101
#
#   # bad - redundant decimal prefix
#   num = 0D1234
#   num = 0d1234
#
#   # good
#   num = 0o1234
#   num = 0x12AB
#   num = 0b10101
#   num = 1234
# @example EnforcedOctalStyle: zero_only
#   # bad
#   num = 0o1234
#   num = 0O1234
#
#   # good
#   num = 01234
#
# source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#36
class RuboCop::Cop::Style::NumericLiteralPrefix < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::IntegerNode
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#52
  def on_int(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#109
  def format_binary(source); end

  # source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#113
  def format_decimal(source); end

  # source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#105
  def format_hex(source); end

  # source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#97
  def format_octal(source); end

  # source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#101
  def format_octal_zero_only(source); end

  # source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#82
  def hex_bin_dec_literal_type(literal); end

  # source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#68
  def literal_type(node); end

  # source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#64
  def message(node); end

  # source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#74
  def octal_literal_type(literal); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#93
  def octal_zero_only?; end
end

# source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#49
RuboCop::Cop::Style::NumericLiteralPrefix::BINARY_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#43
RuboCop::Cop::Style::NumericLiteralPrefix::BINARY_REGEX = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#50
RuboCop::Cop::Style::NumericLiteralPrefix::DECIMAL_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#44
RuboCop::Cop::Style::NumericLiteralPrefix::DECIMAL_REGEX = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#48
RuboCop::Cop::Style::NumericLiteralPrefix::HEX_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#42
RuboCop::Cop::Style::NumericLiteralPrefix::HEX_REGEX = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#47
RuboCop::Cop::Style::NumericLiteralPrefix::OCTAL_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#41
RuboCop::Cop::Style::NumericLiteralPrefix::OCTAL_REGEX = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#46
RuboCop::Cop::Style::NumericLiteralPrefix::OCTAL_ZERO_ONLY_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#40
RuboCop::Cop::Style::NumericLiteralPrefix::OCTAL_ZERO_ONLY_REGEX = T.let(T.unsafe(nil), Regexp)

# Checks for big numeric literals without `_` between groups
# of digits in them.
#
# Additional allowed patterns can be added by adding regexps to
# the `AllowedPatterns` configuration. All regexps are treated
# as anchored even if the patterns do not contain anchors (so
# `\d{4}_\d{4}` will allow `1234_5678` but not `1234_5678_9012`).
#
# NOTE: Even if `AllowedPatterns` are given, autocorrection will
# only correct to the standard pattern of an `_` every 3 digits.
#
# @example
#
#   # bad
#   1000000
#   1_00_000
#   1_0000
#
#   # good
#   1_000_000
#   1000
# @example Strict: false (default)
#
#   # good
#   10_000_00 # typical representation of $10,000 in cents
# @example Strict: true
#
#   # bad
#   10_000_00 # typical representation of $10,000 in cents
# @example AllowedNumbers: [3000]
#
#   # good
#   3000 # You can specify allowed numbers. (e.g. port number)
#
# source://rubocop//lib/rubocop/cop/style/numeric_literals.rb#43
class RuboCop::Cop::Style::NumericLiterals < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::IntegerNode
  include ::RuboCop::Cop::AllowedPattern
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/exclude_limit.rb#11
  def min_digits=(value); end

  # source://rubocop//lib/rubocop/cop/style/numeric_literals.rb#60
  def on_float(node); end

  # source://rubocop//lib/rubocop/cop/style/numeric_literals.rb#56
  def on_int(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/numeric_literals.rb#118
  def allowed_numbers; end

  # source://rubocop//lib/rubocop/cop/style/numeric_literals.rb#122
  def allowed_patterns; end

  # source://rubocop//lib/rubocop/cop/style/numeric_literals.rb#66
  def check(node); end

  # @param int_part [String]
  #
  # source://rubocop//lib/rubocop/cop/style/numeric_literals.rb#107
  def format_int_part(int_part); end

  # source://rubocop//lib/rubocop/cop/style/numeric_literals.rb#93
  def format_number(node); end

  # source://rubocop//lib/rubocop/cop/style/numeric_literals.rb#114
  def min_digits; end

  # source://rubocop//lib/rubocop/cop/style/numeric_literals.rb#82
  def register_offense(node, &_block); end

  # source://rubocop//lib/rubocop/cop/style/numeric_literals.rb#89
  def short_group_regex; end
end

# source://rubocop//lib/rubocop/cop/style/numeric_literals.rb#49
RuboCop::Cop::Style::NumericLiterals::DELIMITER_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/style/numeric_literals.rb#48
RuboCop::Cop::Style::NumericLiterals::MSG = T.let(T.unsafe(nil), String)

# Checks for usage of comparison operators (`==`,
# `>`, `<`) to test numbers as zero, positive, or negative.
# These can be replaced by their respective predicate methods.
# This cop can also be configured to do the reverse.
#
# This cop can be customized allowed methods with `AllowedMethods`.
# By default, there are no methods to allowed.
#
# This cop disregards `#nonzero?` as its value is truthy or falsey,
# but not `true` and `false`, and thus not always interchangeable with
# `!= 0`.
#
# This cop allows comparisons to global variables, since they are often
# populated with objects which can be compared with integers, but are
# not themselves `Integer` polymorphic.
#
# @example EnforcedStyle: predicate (default)
#   # bad
#   foo == 0
#   0 > foo
#   bar.baz > 0
#
#   # good
#   foo.zero?
#   foo.negative?
#   bar.baz.positive?
# @example EnforcedStyle: comparison
#   # bad
#   foo.zero?
#   foo.negative?
#   bar.baz.positive?
#
#   # good
#   foo == 0
#   0 > foo
#   bar.baz > 0
# @example AllowedMethods: [] (default) with EnforcedStyle: predicate
#   # bad
#   foo == 0
#   0 > foo
#   bar.baz > 0
# @example AllowedMethods: [==] with EnforcedStyle: predicate
#   # good
#   foo == 0
#
#   # bad
#   0 > foo
#   bar.baz > 0
# @example AllowedPatterns: [] (default) with EnforcedStyle: comparison
#   # bad
#   foo.zero?
#   foo.negative?
#   bar.baz.positive?
# @example AllowedPatterns: ['zero'] with EnforcedStyle: predicate
#   # good
#   # bad
#   foo.zero?
#
#   # bad
#   foo.negative?
#   bar.baz.positive?
#
# source://rubocop//lib/rubocop/cop/style/numeric_predicate.rb#78
class RuboCop::Cop::Style::NumericPredicate < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::AllowedPattern
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/numeric_predicate.rb#166
  def comparison(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/numeric_predicate.rb#171
  def inverted_comparison(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/numeric_predicate.rb#90
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/style/numeric_predicate.rb#161
  def predicate(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/numeric_predicate.rb#107
  def allowed_method_name?(name); end

  # source://rubocop//lib/rubocop/cop/style/numeric_predicate.rb#111
  def check(node); end

  # source://rubocop//lib/rubocop/cop/style/numeric_predicate.rb#152
  def invert; end

  # source://rubocop//lib/rubocop/cop/style/numeric_predicate.rb#132
  def parenthesized_source(node); end

  # source://rubocop//lib/rubocop/cop/style/numeric_predicate.rb#124
  def replacement(numeric, operation); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/numeric_predicate.rb#144
  def replacement_supported?(operator); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/numeric_predicate.rb#140
  def require_parentheses?(node); end
end

# source://rubocop//lib/rubocop/cop/style/numeric_predicate.rb#84
RuboCop::Cop::Style::NumericPredicate::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/numeric_predicate.rb#86
RuboCop::Cop::Style::NumericPredicate::REPLACEMENTS = T.let(T.unsafe(nil), Hash)

# source://rubocop//lib/rubocop/cop/style/numeric_predicate.rb#88
RuboCop::Cop::Style::NumericPredicate::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Enforces the use of consistent method names
# `Object#yield_self` or `Object#then`.
#
# @example EnforcedStyle: then (default)
#
#   # bad
#   obj.yield_self { |x| x.do_something }
#
#   # good
#   obj.then { |x| x.do_something }
# @example EnforcedStyle: yield_self
#
#   # bad
#   obj.then { |x| x.do_something }
#
#   # good
#   obj.yield_self { |x| x.do_something }
#
# source://rubocop//lib/rubocop/cop/style/object_then.rb#25
class RuboCop::Cop::Style::ObjectThen < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop//lib/rubocop/cop/style/object_then.rb#34
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/style/object_then.rb#34
  def on_numblock(node); end

  # source://rubocop//lib/rubocop/cop/style/object_then.rb#40
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/object_then.rb#48
  def check_method_node(node); end

  # source://rubocop//lib/rubocop/cop/style/object_then.rb#68
  def message(node); end

  # source://rubocop//lib/rubocop/cop/style/object_then.rb#57
  def preferred_method(node); end
end

# source://rubocop//lib/rubocop/cop/style/object_then.rb#32
RuboCop::Cop::Style::ObjectThen::MSG = T.let(T.unsafe(nil), String)

# Checks for uses of if/then/else/end constructs on a single line.
# AlwaysCorrectToMultiline config option can be set to true to auto-convert all offenses to
# multi-line constructs. When AlwaysCorrectToMultiline is false (default case) the
# autocorrect will first try converting them to ternary operators.
#
# @example
#   # bad
#   if foo then bar else baz end
#
#   # bad
#   unless foo then baz else bar end
#
#   # good
#   foo ? bar : baz
#
#   # good
#   bar if foo
#
#   # good
#   if foo then bar end
#
#   # good
#   if foo
#   bar
#   else
#   baz
#   end
#
# source://rubocop//lib/rubocop/cop/style/one_line_conditional.rb#33
class RuboCop::Cop::Style::OneLineConditional < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::OnNormalIfUnless
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/one_line_conditional.rb#42
  def on_normal_if_unless(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/one_line_conditional.rb#77
  def always_multiline?; end

  # source://rubocop//lib/rubocop/cop/style/one_line_conditional.rb#59
  def autocorrect(corrector, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/one_line_conditional.rb#81
  def cannot_replace_to_ternary?(node); end

  # source://rubocop//lib/rubocop/cop/style/one_line_conditional.rb#93
  def expr_replacement(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/one_line_conditional.rb#114
  def keyword_with_changed_precedence?(node); end

  # source://rubocop//lib/rubocop/cop/style/one_line_conditional.rb#55
  def message(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/one_line_conditional.rb#107
  def method_call_with_changed_precedence?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/one_line_conditional.rb#99
  def requires_parentheses?(node); end

  # source://rubocop//lib/rubocop/cop/style/one_line_conditional.rb#67
  def ternary_correction(node); end

  # source://rubocop//lib/rubocop/cop/style/one_line_conditional.rb#85
  def ternary_replacement(node); end
end

# source://rubocop//lib/rubocop/cop/style/one_line_conditional.rb#39
RuboCop::Cop::Style::OneLineConditional::MSG = T.let(T.unsafe(nil), String)

# Flags uses of OpenStruct, as it is now officially discouraged
# to be used for performance, version compatibility, and potential security issues.
#
# @example
#
#   # bad
#   point = OpenStruct.new(x: 0, y: 1)
#
#   # good
#   Point = Struct.new(:x, :y)
#   point = Point.new(0, 1)
#
#   # also good
#   point = { x: 0, y: 1 }
#
#   # bad
#   test_double = OpenStruct.new(a: 'b')
#
#   # good (assumes test using rspec-mocks)
#   test_double = double
#   allow(test_double).to receive(:a).and_return('b')
#
# source://rubocop//lib/rubocop/cop/style/open_struct_use.rb#44
class RuboCop::Cop::Style::OpenStructUse < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/style/open_struct_use.rb#52
  def on_const(node); end

  # source://rubocop//lib/rubocop/cop/style/open_struct_use.rb#48
  def uses_open_struct?(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/open_struct_use.rb#61
  def custom_class_or_module_definition?(node); end
end

# source://rubocop//lib/rubocop/cop/style/open_struct_use.rb#45
RuboCop::Cop::Style::OpenStructUse::MSG = T.let(T.unsafe(nil), String)

# Checks for redundant dot before operator method call.
# The target operator methods are `|`, `^`, `&`, `<=>`, `==`, `===`, `=~`, `>`, `>=`, `<`,
# `<=`, `<<`, `>>`, `+`, `-`, `*`, `/`, `%`, `**`, `~`, `!`, `!=`, and `!~`.
#
# @example
#
#   # bad
#   foo.+ bar
#   foo.& bar
#
#   # good
#   foo + bar
#   foo & bar
#
# source://rubocop//lib/rubocop/cop/style/operator_method_call.rb#20
class RuboCop::Cop::Style::OperatorMethodCall < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/operator_method_call.rb#26
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/operator_method_call.rb#48
  def anonymous_forwarding?(argument); end

  # Checks for an acceptable case of `foo.+(bar).baz`.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/operator_method_call.rb#42
  def method_call_with_parenthesized_arg?(argument); end

  # source://rubocop//lib/rubocop/cop/style/operator_method_call.rb#55
  def wrap_in_parentheses_if_chained(corrector, node); end
end

# source://rubocop//lib/rubocop/cop/style/operator_method_call.rb#23
RuboCop::Cop::Style::OperatorMethodCall::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/operator_method_call.rb#24
RuboCop::Cop::Style::OperatorMethodCall::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for options hashes and discourages them if the
# current Ruby version supports keyword arguments.
#
# @example
#
#   # bad
#   def fry(options = {})
#   temperature = options.fetch(:temperature, 300)
#   # ...
#   end
#
#   # good
#   def fry(temperature: 300)
#   # ...
#   end
#
# source://rubocop//lib/rubocop/cop/style/option_hash.rb#22
class RuboCop::Cop::Style::OptionHash < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/style/option_hash.rb#30
  def on_args(node); end

  # source://rubocop//lib/rubocop/cop/style/option_hash.rb#26
  def option_hash(param0 = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/style/option_hash.rb#39
  def allowlist; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/option_hash.rb#48
  def super_used?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/option_hash.rb#43
  def suspicious_name?(arg_name); end
end

# source://rubocop//lib/rubocop/cop/style/option_hash.rb#23
RuboCop::Cop::Style::OptionHash::MSG = T.let(T.unsafe(nil), String)

# Checks for optional arguments to methods
# that do not come at the end of the argument list.
#
# @example
#   # bad
#   def foo(a = 1, b, c)
#   end
#
#   # good
#   def baz(a, b, c = 1)
#   end
#
#   def foobar(a = 1, b = 2, c = 3)
#   end
#
# source://rubocop//lib/rubocop/cop/style/optional_arguments.rb#24
class RuboCop::Cop::Style::OptionalArguments < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/style/optional_arguments.rb#27
  def on_def(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/optional_arguments.rb#45
  def argument_positions(arguments); end

  # source://rubocop//lib/rubocop/cop/style/optional_arguments.rb#33
  def each_misplaced_optional_arg(arguments); end
end

# source://rubocop//lib/rubocop/cop/style/optional_arguments.rb#25
RuboCop::Cop::Style::OptionalArguments::MSG = T.let(T.unsafe(nil), String)

# Checks for places where keyword arguments can be used instead of
# boolean arguments when defining methods. `respond_to_missing?` method is allowed by default.
# These are customizable with `AllowedMethods` option.
#
# @example
#   # bad
#   def some_method(bar = false)
#   puts bar
#   end
#
#   # bad - common hack before keyword args were introduced
#   def some_method(options = {})
#   bar = options.fetch(:bar, false)
#   puts bar
#   end
#
#   # good
#   def some_method(bar: false)
#   puts bar
#   end
# @example AllowedMethods: ['some_method']
#   # good
#   def some_method(bar = false)
#   puts bar
#   end
#
# source://rubocop//lib/rubocop/cop/style/optional_boolean_parameter.rb#37
class RuboCop::Cop::Style::OptionalBooleanParameter < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::AllowedMethods

  # source://rubocop//lib/rubocop/cop/style/optional_boolean_parameter.rb#43
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/style/optional_boolean_parameter.rb#43
  def on_defs(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/optional_boolean_parameter.rb#56
  def format_message(argument); end
end

# source://rubocop//lib/rubocop/cop/style/optional_boolean_parameter.rb#40
RuboCop::Cop::Style::OptionalBooleanParameter::MSG = T.let(T.unsafe(nil), String)

# Checks for potential usage of the `||=` operator.
#
# @example
#   # bad
#   name = name ? name : 'Bozhidar'
#
#   # bad
#   name = if name
#   name
#   else
#   'Bozhidar'
#   end
#
#   # bad
#   unless name
#   name = 'Bozhidar'
#   end
#
#   # bad
#   name = 'Bozhidar' unless name
#
#   # good - set name to 'Bozhidar', only if it's nil or false
#   name ||= 'Bozhidar'
#
# source://rubocop//lib/rubocop/cop/style/or_assignment.rb#29
class RuboCop::Cop::Style::OrAssignment < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/or_assignment.rb#57
  def on_cvasgn(node); end

  # source://rubocop//lib/rubocop/cop/style/or_assignment.rb#57
  def on_gvasgn(node); end

  # source://rubocop//lib/rubocop/cop/style/or_assignment.rb#51
  def on_if(node); end

  # source://rubocop//lib/rubocop/cop/style/or_assignment.rb#57
  def on_ivasgn(node); end

  # source://rubocop//lib/rubocop/cop/style/or_assignment.rb#57
  def on_lvasgn(node); end

  # source://rubocop//lib/rubocop/cop/style/or_assignment.rb#35
  def ternary_assignment?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/or_assignment.rb#44
  def unless_assignment?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/style/or_assignment.rb#70
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/or_assignment.rb#80
  def take_variable_and_default_from_ternary(node); end

  # source://rubocop//lib/rubocop/cop/style/or_assignment.rb#85
  def take_variable_and_default_from_unless(node); end
end

# source://rubocop//lib/rubocop/cop/style/or_assignment.rb#32
RuboCop::Cop::Style::OrAssignment::MSG = T.let(T.unsafe(nil), String)

# Checks for simple usages of parallel assignment.
# This will only complain when the number of variables
# being assigned matched the number of assigning variables.
#
# @example
#   # bad
#   a, b, c = 1, 2, 3
#   a, b, c = [1, 2, 3]
#
#   # good
#   one, two = *foo
#   a, b = foo()
#   a, b = b, a
#
#   a = 1
#   b = 2
#   c = 3
#
# source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#25
class RuboCop::Cop::Style::ParallelAssignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RescueNode
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#115
  def implicit_self_getter?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#31
  def on_masgn(node); end

  private

  # Converts (send nil :something) nodes to (send (:self) :something).
  # This makes the sorting algorithm work for expressions such as
  # `self.a, self.b = b, a`.
  #
  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#108
  def add_self_to_getters(right_elements); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#60
  def allowed_lhs?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#54
  def allowed_masign?(lhs_elements, rhs_elements); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#68
  def allowed_rhs?(node); end

  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#80
  def assignment_corrector(node, order); end

  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#44
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#91
  def find_valid_order(left_elements, right_elements); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#174
  def modifier_statement?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#76
  def return_of_method_call?(node); end
end

# Helper class necessitated by silly design of TSort prior to Ruby 2.1
# Newer versions have a better API, but that doesn't help us
#
# source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#119
class RuboCop::Cop::Style::ParallelAssignment::AssignmentSorter
  include ::TSort
  extend ::RuboCop::AST::NodePattern::Macros

  # @return [AssignmentSorter] a new instance of AssignmentSorter
  #
  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#132
  def initialize(assignments); end

  # `lhs` is an assignment method call like `obj.attr=` or `ary[idx]=`.
  # Does `rhs` access the same value which is assigned by `lhs`?
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#161
  def accesses?(rhs, lhs); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#154
  def dependency?(lhs, rhs); end

  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#130
  def matching_calls(param0, param1, param2); end

  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#140
  def tsort_each_child(assignment); end

  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#136
  def tsort_each_node(&block); end

  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#127
  def uses_var?(param0, param1); end

  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#124
  def var_name(param0 = T.unsafe(nil)); end
end

# An internal class for correcting parallel assignment
#
# source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#181
class RuboCop::Cop::Style::ParallelAssignment::GenericCorrector
  include ::RuboCop::Cop::Alignment

  # @return [GenericCorrector] a new instance of GenericCorrector
  #
  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#186
  def initialize(node, config, new_elements); end

  # Returns the value of attribute config.
  #
  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#184
  def config; end

  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#192
  def correction; end

  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#196
  def correction_range; end

  # Returns the value of attribute node.
  #
  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#184
  def node; end

  protected

  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#202
  def assignment; end

  private

  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#222
  def cop_config; end

  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#218
  def extract_sources(node); end

  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#208
  def source(node); end
end

# source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#29
RuboCop::Cop::Style::ParallelAssignment::MSG = T.let(T.unsafe(nil), String)

# An internal class for correcting parallel assignment
# guarded by if, unless, while, or until
#
# source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#267
class RuboCop::Cop::Style::ParallelAssignment::ModifierCorrector < ::RuboCop::Cop::Style::ParallelAssignment::GenericCorrector
  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#268
  def correction; end

  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#277
  def correction_range; end

  private

  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#283
  def modifier_range(node); end
end

# An internal class for correcting parallel assignment
# protected by rescue
#
# source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#229
class RuboCop::Cop::Style::ParallelAssignment::RescueCorrector < ::RuboCop::Cop::Style::ParallelAssignment::GenericCorrector
  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#230
  def correction; end

  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#244
  def correction_range; end

  private

  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#255
  def begin_correction(rescue_result); end

  # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#250
  def def_correction(rescue_result); end
end

# Checks for the presence of superfluous parentheses around the
# condition of if/unless/while/until.
#
# `AllowSafeAssignment` option for safe assignment.
# By safe assignment we mean putting parentheses around
# an assignment to indicate "I know I'm using an assignment
# as a condition. It's not a mistake."
#
# @example
#   # bad
#   x += 1 while (x < 10)
#   foo unless (bar || baz)
#
#   if (x > 10)
#   elsif (x < 3)
#   end
#
#   # good
#   x += 1 while x < 10
#   foo unless bar || baz
#
#   if x > 10
#   elsif x < 3
#   end
# @example AllowSafeAssignment: true (default)
#   # good
#   foo unless (bar = baz)
# @example AllowSafeAssignment: false
#   # bad
#   foo unless (bar = baz)
# @example AllowInMultilineConditions: false (default)
#   # bad
#   if (x > 10 &&
#   y > 10)
#   end
#
#   # good
#   if x > 10 &&
#   y > 10
#   end
# @example AllowInMultilineConditions: true
#   # good
#   if (x > 10 &&
#   y > 10)
#   end
#
# source://rubocop//lib/rubocop/cop/style/parentheses_around_condition.rb#56
class RuboCop::Cop::Style::ParenthesesAroundCondition < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::SafeAssignment
  include ::RuboCop::Cop::Parentheses
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/parentheses_around_condition.rb#76
  def control_op_condition(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/parentheses_around_condition.rb#62
  def on_if(node); end

  # source://rubocop//lib/rubocop/cop/style/parentheses_around_condition.rb#68
  def on_until(node); end

  # source://rubocop//lib/rubocop/cop/style/parentheses_around_condition.rb#68
  def on_while(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/parentheses_around_condition.rb#122
  def allow_multiline_conditions?; end

  # source://rubocop//lib/rubocop/cop/style/parentheses_around_condition.rb#110
  def message(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/parentheses_around_condition.rb#103
  def modifier_op?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/parentheses_around_condition.rb#116
  def parens_allowed?(node); end

  # source://rubocop//lib/rubocop/cop/style/parentheses_around_condition.rb#80
  def process_control_op(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/parentheses_around_condition.rb#95
  def semicolon_separated_expressions?(first_exp, rest_exps); end
end

# Enforces the consistent usage of `%`-literal delimiters.
#
# Specify the 'default' key to set all preferred delimiters at once. You
# can continue to specify individual preferred delimiters to override the
# default.
#
# @example
#   # Style/PercentLiteralDelimiters:
#   #   PreferredDelimiters:
#   #     default: '[]'
#   #     '%i':    '()'
#
#   # good
#   %w[alpha beta] + %i(gamma delta)
#
#   # bad
#   %W(alpha #{beta})
#
#   # bad
#   %I(alpha beta)
#
# source://rubocop//lib/rubocop/cop/style/percent_literal_delimiters.rb#26
class RuboCop::Cop::Style::PercentLiteralDelimiters < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::PercentLiteral
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/percent_literal_delimiters.rb#30
  def on_array(node); end

  # source://rubocop//lib/rubocop/cop/style/percent_literal_delimiters.rb#38
  def on_dstr(node); end

  # source://rubocop//lib/rubocop/cop/style/percent_literal_delimiters.rb#34
  def on_regexp(node); end

  # source://rubocop//lib/rubocop/cop/style/percent_literal_delimiters.rb#38
  def on_str(node); end

  # source://rubocop//lib/rubocop/cop/style/percent_literal_delimiters.rb#43
  def on_sym(node); end

  # source://rubocop//lib/rubocop/cop/style/percent_literal_delimiters.rb#47
  def on_xstr(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/percent_literal_delimiters.rb#93
  def contains_delimiter?(node, delimiters); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/percent_literal_delimiters.rb#82
  def contains_preferred_delimiter?(node, type); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/percent_literal_delimiters.rb#86
  def include_same_character_as_used_for_delimiter?(node, type); end

  # source://rubocop//lib/rubocop/cop/style/percent_literal_delimiters.rb#107
  def matchpairs(begin_delimiter); end

  # source://rubocop//lib/rubocop/cop/style/percent_literal_delimiters.rb#67
  def message(type); end

  # source://rubocop//lib/rubocop/cop/style/percent_literal_delimiters.rb#53
  def on_percent_literal(node); end

  # source://rubocop//lib/rubocop/cop/style/percent_literal_delimiters.rb#74
  def preferred_delimiters_for(type); end

  # source://rubocop//lib/rubocop/cop/style/percent_literal_delimiters.rb#99
  def string_source(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/percent_literal_delimiters.rb#78
  def uses_preferred_delimiter?(node, type); end
end

# Checks for usage of the %Q() syntax when %q() would do.
#
# @example EnforcedStyle: lower_case_q (default)
#   # The `lower_case_q` style prefers `%q` unless
#   # interpolation is needed.
#   # bad
#   %Q[Mix the foo into the baz.]
#   %Q(They all said: 'Hooray!')
#
#   # good
#   %q[Mix the foo into the baz]
#   %q(They all said: 'Hooray!')
# @example EnforcedStyle: upper_case_q
#   # The `upper_case_q` style requires the sole use of `%Q`.
#   # bad
#   %q/Mix the foo into the baz./
#   %q{They all said: 'Hooray!'}
#
#   # good
#   %Q/Mix the foo into the baz./
#   %Q{They all said: 'Hooray!'}
#
# source://rubocop//lib/rubocop/cop/style/percent_q_literals.rb#28
class RuboCop::Cop::Style::PercentQLiterals < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/percent_q_literals.rb#36
  def on_str(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/percent_q_literals.rb#55
  def correct_literal_style?(node); end

  # source://rubocop//lib/rubocop/cop/style/percent_q_literals.rb#64
  def corrected(src); end

  # source://rubocop//lib/rubocop/cop/style/percent_q_literals.rb#60
  def message(_range); end

  # source://rubocop//lib/rubocop/cop/style/percent_q_literals.rb#42
  def on_percent_literal(node); end
end

# source://rubocop//lib/rubocop/cop/style/percent_q_literals.rb#33
RuboCop::Cop::Style::PercentQLiterals::LOWER_CASE_Q_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/percent_q_literals.rb#34
RuboCop::Cop::Style::PercentQLiterals::UPPER_CASE_Q_MSG = T.let(T.unsafe(nil), String)

# Looks for uses of Perl-style regexp match
# backreferences and their English versions like
# $1, $2, $&, &+, $MATCH, $PREMATCH, etc.
#
# @example
#   # bad
#   puts $1
#
#   # good
#   puts Regexp.last_match(1)
#
# source://rubocop//lib/rubocop/cop/style/perl_backrefs.rb#16
class RuboCop::Cop::Style::PerlBackrefs < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/perl_backrefs.rb#21
  def on_back_ref(node); end

  # source://rubocop//lib/rubocop/cop/style/perl_backrefs.rb#25
  def on_gvar(node); end

  # source://rubocop//lib/rubocop/cop/style/perl_backrefs.rb#29
  def on_nth_ref(node); end

  private

  # @param node [RuboCop::AST::Node]
  # @private
  # @return [String]
  #
  # source://rubocop//lib/rubocop/cop/style/perl_backrefs.rb#99
  def constant_prefix(node); end

  # @param node [RuboCop::AST::Node]
  # @private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/perl_backrefs.rb#38
  def derived_from_braceless_interpolation?(node); end

  # @param node [RuboCop::AST::Node]
  # @param preferred_expression [String]
  # @private
  # @return [String]
  #
  # source://rubocop//lib/rubocop/cop/style/perl_backrefs.rb#46
  def format_message(node:, preferred_expression:); end

  # @param node [RuboCop::AST::Node]
  # @private
  #
  # source://rubocop//lib/rubocop/cop/style/perl_backrefs.rb#109
  def on_back_ref_or_gvar_or_nth_ref(node); end

  # @param node [RuboCop::AST::Node]
  # @private
  # @return [String]
  #
  # source://rubocop//lib/rubocop/cop/style/perl_backrefs.rb#58
  def original_expression_of(node); end

  # @param node [RuboCop::AST::Node]
  # @private
  # @return [String, nil]
  #
  # source://rubocop//lib/rubocop/cop/style/perl_backrefs.rb#70
  def preferred_expression_to(node); end

  # @param node [RuboCop::AST::Node]
  # @private
  # @return [String, nil]
  #
  # source://rubocop//lib/rubocop/cop/style/perl_backrefs.rb#89
  def preferred_expression_to_node_with_constant_prefix(node); end
end

# source://rubocop//lib/rubocop/cop/style/perl_backrefs.rb#19
RuboCop::Cop::Style::PerlBackrefs::MESSAGE_FORMAT = T.let(T.unsafe(nil), String)

# Checks for uses of methods `Hash#has_key?` and
# `Hash#has_value?`, and suggests using `Hash#key?` and `Hash#value?` instead.
#
# It is configurable to enforce the verbose method names, by using the
# `EnforcedStyle: verbose` configuration.
#
# @example EnforcedStyle: short (default)
#   # bad
#   Hash#has_key?
#   Hash#has_value?
#
#   # good
#   Hash#key?
#   Hash#value?
# @example EnforcedStyle: verbose
#   # bad
#   Hash#key?
#   Hash#value?
#
#   # good
#   Hash#has_key?
#   Hash#has_value?
#
# source://rubocop//lib/rubocop/cop/style/preferred_hash_methods.rb#33
class RuboCop::Cop::Style::PreferredHashMethods < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/preferred_hash_methods.rb#43
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/style/preferred_hash_methods.rb#43
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/preferred_hash_methods.rb#56
  def message(method_name); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/preferred_hash_methods.rb#68
  def offending_selector?(method_name); end

  # source://rubocop//lib/rubocop/cop/style/preferred_hash_methods.rb#60
  def proper_method_name(method_name); end
end

# source://rubocop//lib/rubocop/cop/style/preferred_hash_methods.rb#37
RuboCop::Cop::Style::PreferredHashMethods::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/preferred_hash_methods.rb#39
RuboCop::Cop::Style::PreferredHashMethods::OFFENDING_SELECTORS = T.let(T.unsafe(nil), Hash)

# source://rubocop//lib/rubocop/cop/style/preferred_hash_methods.rb#41
RuboCop::Cop::Style::PreferredHashMethods::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for uses of Proc.new where Kernel#proc
# would be more appropriate.
#
# @example
#   # bad
#   p = Proc.new { |n| puts n }
#
#   # good
#   p = proc { |n| puts n }
#
# source://rubocop//lib/rubocop/cop/style/proc.rb#16
class RuboCop::Cop::Style::Proc < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/proc.rb#25
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/style/proc.rb#25
  def on_numblock(node); end

  # source://rubocop//lib/rubocop/cop/style/proc.rb#22
  def proc_new?(param0 = T.unsafe(nil)); end
end

# source://rubocop//lib/rubocop/cop/style/proc.rb#19
RuboCop::Cop::Style::Proc::MSG = T.let(T.unsafe(nil), String)

# Checks if the quotes used for quoted symbols match the configured defaults.
# By default uses the same configuration as `Style/StringLiterals`; if that
# cop is not enabled, the default `EnforcedStyle` is `single_quotes`.
#
# String interpolation is always kept in double quotes.
#
# Note: `Lint/SymbolConversion` can be used in parallel to ensure that symbols
# are not quoted that don't need to be. This cop is for configuring the quoting
# style to use for symbols that require quotes.
#
# @example EnforcedStyle: same_as_string_literals (default) / single_quotes
#   # bad
#   :"abc-def"
#
#   # good
#   :'abc-def'
#   :"#{str}"
#   :"a\'b"
# @example EnforcedStyle: double_quotes
#   # bad
#   :'abc-def'
#
#   # good
#   :"abc-def"
#   :"#{str}"
#   :"a\'b"
#
# source://rubocop//lib/rubocop/cop/style/quoted_symbols.rb#33
class RuboCop::Cop::Style::QuotedSymbols < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::SymbolHelp
  include ::RuboCop::Cop::StringLiteralsHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/quoted_symbols.rb#44
  def on_sym(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/quoted_symbols.rb#108
  def alternative_style; end

  # source://rubocop//lib/rubocop/cop/style/quoted_symbols.rb#71
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/quoted_symbols.rb#88
  def correct_quotes(str); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/quoted_symbols.rb#83
  def hash_colon_key?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/quoted_symbols.rb#61
  def invalid_double_quotes?(source); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/quoted_symbols.rb#112
  def quoted?(sym_node); end

  # source://rubocop//lib/rubocop/cop/style/quoted_symbols.rb#99
  def style; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/quoted_symbols.rb#116
  def wrong_quotes?(node); end
end

# source://rubocop//lib/rubocop/cop/style/quoted_symbols.rb#41
RuboCop::Cop::Style::QuotedSymbols::MSG_DOUBLE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/quoted_symbols.rb#39
RuboCop::Cop::Style::QuotedSymbols::MSG_SINGLE = T.let(T.unsafe(nil), String)

# Checks the args passed to `fail` and `raise`. For exploded
# style (default), it recommends passing the exception class and message
# to `raise`, rather than construct an instance of the error. It will
# still allow passing just a message, or the construction of an error
# with more than one argument.
#
# The exploded style works identically, but with the addition that it
# will also suggest constructing error objects when the exception is
# passed multiple arguments.
#
# The exploded style has an `AllowedCompactTypes` configuration
# option that takes an Array of exception name Strings.
#
# @example EnforcedStyle: exploded (default)
#   # bad
#   raise StandardError.new('message')
#
#   # good
#   raise StandardError, 'message'
#   fail 'message'
#   raise MyCustomError
#   raise MyCustomError.new(arg1, arg2, arg3)
#   raise MyKwArgError.new(key1: val1, key2: val2)
#
#   # With `AllowedCompactTypes` set to ['MyWrappedError']
#   raise MyWrappedError.new(obj)
#   raise MyWrappedError.new(obj), 'message'
# @example EnforcedStyle: compact
#   # bad
#   raise StandardError, 'message'
#   raise RuntimeError, arg1, arg2, arg3
#
#   # good
#   raise StandardError.new('message')
#   raise MyCustomError
#   raise MyCustomError.new(arg1, arg2, arg3)
#   fail 'message'
#
# source://rubocop//lib/rubocop/cop/style/raise_args.rb#44
class RuboCop::Cop::Style::RaiseArgs < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/raise_args.rb#53
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/raise_args.rb#129
  def acceptable_exploded_args?(args); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/raise_args.rb#143
  def allowed_non_exploded_type?(arg); end

  # source://rubocop//lib/rubocop/cop/style/raise_args.rb#92
  def check_compact(node); end

  # source://rubocop//lib/rubocop/cop/style/raise_args.rb#108
  def check_exploded(node); end

  # source://rubocop//lib/rubocop/cop/style/raise_args.rb#66
  def correction_compact_to_exploded(node); end

  # source://rubocop//lib/rubocop/cop/style/raise_args.rb#78
  def correction_exploded_to_compact(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/raise_args.rb#149
  def requires_parens?(parent); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/raise_args.rb#125
  def use_new_method?(first_arg); end
end

# source://rubocop//lib/rubocop/cop/style/raise_args.rb#49
RuboCop::Cop::Style::RaiseArgs::COMPACT_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/raise_args.rb#48
RuboCop::Cop::Style::RaiseArgs::EXPLODED_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/raise_args.rb#51
RuboCop::Cop::Style::RaiseArgs::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for the use of randomly generated numbers,
# added/subtracted with integer literals, as well as those with
# Integer#succ and Integer#pred methods. Prefer using ranges instead,
# as it clearly states the intentions.
#
# @example
#   # bad
#   rand(6) + 1
#   1 + rand(6)
#   rand(6) - 1
#   1 - rand(6)
#   rand(6).succ
#   rand(6).pred
#   Random.rand(6) + 1
#   Kernel.rand(6) + 1
#   rand(0..5) + 1
#
#   # good
#   rand(1..6)
#   rand(1...7)
#
# source://rubocop//lib/rubocop/cop/style/random_with_offset.rb#26
class RuboCop::Cop::Style::RandomWithOffset < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/random_with_offset.rb#33
  def integer_op_rand?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/random_with_offset.rb#63
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/style/random_with_offset.rb#54
  def rand_modified?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/random_with_offset.rb#43
  def rand_op_integer?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/random_with_offset.rb#73
  def random_call(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/random_with_offset.rb#147
  def to_int(param0 = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/style/random_with_offset.rb#78
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/random_with_offset.rb#135
  def boundaries_from_random_node(random_node); end

  # source://rubocop//lib/rubocop/cop/style/random_with_offset.rb#88
  def corrected_integer_op_rand(node); end

  # source://rubocop//lib/rubocop/cop/style/random_with_offset.rb#118
  def corrected_rand_modified(node); end

  # source://rubocop//lib/rubocop/cop/style/random_with_offset.rb#103
  def corrected_rand_op_integer(node); end

  # source://rubocop//lib/rubocop/cop/style/random_with_offset.rb#131
  def prefix_from_prefix_node(node); end
end

# source://rubocop//lib/rubocop/cop/style/random_with_offset.rb#29
RuboCop::Cop::Style::RandomWithOffset::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/random_with_offset.rb#30
RuboCop::Cop::Style::RandomWithOffset::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for a redundant argument passed to certain methods.
#
# NOTE: This cop is limited to methods with single parameter.
#
# Method names and their redundant arguments can be configured like this:
#
# [source,yaml]
# ----
# Methods:
#   join: ''
#   sum: 0
#   split: ' '
#   chomp: "\n"
#   chomp!: "\n"
#   foo: 2
# ----
#
# @example
#   # bad
#   array.join('')
#   [1, 2, 3].join("")
#   array.sum(0)
#   string.split(" ")
#   "first\nsecond".split(" ")
#   string.chomp("\n")
#   string.chomp!("\n")
#   A.foo(2)
#
#   # good
#   array.join
#   [1, 2, 3].join
#   array.sum
#   string.split
#   "first second".split
#   string.chomp
#   string.chomp!
#   A.foo
#
# source://rubocop//lib/rubocop/cop/style/redundant_argument.rb#53
class RuboCop::Cop::Style::RedundantArgument < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/redundant_argument.rb#59
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/redundant_argument.rb#88
  def argument_range(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_argument.rb#81
  def redundant_arg_for_method(method_name); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_argument.rb#74
  def redundant_argument?(node); end
end

# source://rubocop//lib/rubocop/cop/style/redundant_argument.rb#57
RuboCop::Cop::Style::RedundantArgument::MSG = T.let(T.unsafe(nil), String)

# Checks for redundant assignment before returning.
#
# @example
#   # bad
#   def test
#   x = foo
#   x
#   end
#
#   # bad
#   def test
#   if x
#   z = foo
#   z
#   elsif y
#   z = bar
#   z
#   end
#   end
#
#   # good
#   def test
#   foo
#   end
#
#   # good
#   def test
#   if x
#   foo
#   elsif y
#   bar
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/style/redundant_assignment.rb#40
class RuboCop::Cop::Style::RedundantAssignment < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/redundant_assignment.rb#50
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_assignment.rb#50
  def on_defs(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_assignment.rb#46
  def redundant_assignment?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/style/redundant_assignment.rb#91
  def check_begin_node(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_assignment.rb#57
  def check_branch(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_assignment.rb#71
  def check_case_node(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_assignment.rb#87
  def check_ensure_node(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_assignment.rb#76
  def check_if_node(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_assignment.rb#83
  def check_rescue_node(node); end
end

# source://rubocop//lib/rubocop/cop/style/redundant_assignment.rb#43
RuboCop::Cop::Style::RedundantAssignment::MSG = T.let(T.unsafe(nil), String)

# Checks for redundant `begin` blocks.
#
# Currently it checks for code like this:
#
# @example
#
#   # bad
#   def redundant
#   begin
#   ala
#   bala
#   rescue StandardError => e
#   something
#   end
#   end
#
#   # good
#   def preferred
#   ala
#   bala
#   rescue StandardError => e
#   something
#   end
#
#   # bad
#   begin
#   do_something
#   end
#
#   # good
#   do_something
#
#   # bad
#   # When using Ruby 2.5 or later.
#   do_something do
#   begin
#   something
#   rescue => ex
#   anything
#   end
#   end
#
#   # good
#   # In Ruby 2.5 or later, you can omit `begin` in `do-end` block.
#   do_something do
#   something
#   rescue => ex
#   anything
#   end
#
#   # good
#   # Stabby lambdas don't support implicit `begin` in `do-end` blocks.
#   -> do
#   begin
#   foo
#   rescue Bar
#   baz
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#65
class RuboCop::Cop::Style::RedundantBegin < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#72
  def offensive_kwbegins(param0); end

  # source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#84
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#76
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#76
  def on_defs(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#95
  def on_kwbegin(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#84
  def on_numblock(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#103
  def allowable_kwbegin?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#169
  def begin_block_has_multiline_statements?(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#161
  def condition_range(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#173
  def contain_rescue_or_ensure?(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#154
  def correct_modifier_form_after_multiline_begin_block(corrector, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#165
  def empty_begin?(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#110
  def register_offense(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#127
  def replace_begin_with_statement(corrector, offense_range, node); end

  # Restore comments that occur between "begin" and "first_child".
  # These comments will be moved to above the assignment line.
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#141
  def restore_removed_comments(corrector, offense_range, node, first_child); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#148
  def use_modifier_form_after_multiline_begin_block?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#186
  def valid_begin_assignment?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#179
  def valid_context_using_only_begin?(node); end
end

# source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#69
RuboCop::Cop::Style::RedundantBegin::MSG = T.let(T.unsafe(nil), String)

# Checks for usage of the %W() syntax when %w() would do.
#
# @example
#   # bad
#   %W(cat dog pig)
#   %W[door wall floor]
#
#   # good
#   %w/swim run bike/
#   %w[shirt pants shoes]
#   %W(apple #{fruit} grape)
#
# source://rubocop//lib/rubocop/cop/style/redundant_capital_w.rb#17
class RuboCop::Cop::Style::RedundantCapitalW < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::PercentLiteral
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/redundant_capital_w.rb#23
  def on_array(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/redundant_capital_w.rb#29
  def on_percent_literal(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_capital_w.rb#38
  def requires_interpolation?(node); end
end

# source://rubocop//lib/rubocop/cop/style/redundant_capital_w.rb#21
RuboCop::Cop::Style::RedundantCapitalW::MSG = T.let(T.unsafe(nil), String)

# Checks for unnecessary conditional expressions.
#
# @example
#   # bad
#   a = b ? b : c
#
#   # good
#   a = b || c
# @example
#   # bad
#   if b
#   b
#   else
#   c
#   end
#
#   # good
#   b || c
#
#   # good
#   if b
#   b
#   elsif cond
#   c
#   end
#
# source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#33
class RuboCop::Cop::Style::RedundantCondition < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#43
  def on_if(node); end

  private

  # If the argument is using an operator, it is an invalid syntax.
  # e.g. `foo || *bar`, `foo || **bar`, and `foo || &bar`.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#167
  def argument_with_operator?(argument); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#142
  def asgn_type?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#132
  def branches_have_assignment?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#146
  def branches_have_method?(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#240
  def correct_ternary(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#187
  def else_source(else_branch, arithmetic_operation); end

  # source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#213
  def else_source_if_has_assignment(else_branch); end

  # source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#203
  def else_source_if_has_method(else_branch); end

  # source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#175
  def if_source(if_branch, arithmetic_operation); end

  # source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#223
  def make_ternary_form(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#64
  def message(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#79
  def offense?(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#72
  def range_of_offense(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#88
  def redundant_condition?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#255
  def require_braces?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#248
  def require_parentheses?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#161
  def same_method?(if_branch, else_branch); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#155
  def single_argument_method?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#104
  def synonymous_condition_and_branch?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#259
  def use_arithmetic_operation?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#100
  def use_hash_key_access?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#96
  def use_hash_key_assignment?(else_branch); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#92
  def use_if_branch?(else_branch); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#263
  def without_argument_parentheses_method?(node); end
end

# source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#39
RuboCop::Cop::Style::RedundantCondition::ARGUMENT_WITH_OPERATOR_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#37
RuboCop::Cop::Style::RedundantCondition::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#38
RuboCop::Cop::Style::RedundantCondition::REDUNDANT_CONDITION = T.let(T.unsafe(nil), String)

# Checks for redundant returning of true/false in conditionals.
#
# @example
#   # bad
#   x == y ? true : false
#
#   # bad
#   if x == y
#   true
#   else
#   false
#   end
#
#   # good
#   x == y
#
#   # bad
#   x == y ? false : true
#
#   # good
#   x != y
#
# source://rubocop//lib/rubocop/cop/style/redundant_conditional.rb#27
class RuboCop::Cop::Style::RedundantConditional < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/redundant_conditional.rb#36
  def on_if(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_conditional.rb#56
  def redundant_condition?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/redundant_conditional.rb#61
  def redundant_condition_inverted?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/style/redundant_conditional.rb#86
  def indented_else_node(expression, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_conditional.rb#78
  def invert_expression?(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_conditional.rb#48
  def message(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_conditional.rb#65
  def offense?(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_conditional.rb#71
  def replacement_condition(node); end
end

# source://rubocop//lib/rubocop/cop/style/redundant_conditional.rb#32
RuboCop::Cop::Style::RedundantConditional::COMPARISON_OPERATOR_MATCHER = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/redundant_conditional.rb#34
RuboCop::Cop::Style::RedundantConditional::MSG = T.let(T.unsafe(nil), String)

# Avoid redundant `::` prefix on constant.
#
# How Ruby searches constant is a bit complicated, and it can often be difficult to
# understand from the code whether the `::` is intended or not. Where `Module.nesting`
# is empty, there is no need to prepend `::`, so it would be nice to consistently
# avoid such meaningless `::` prefix to avoid confusion.
#
# NOTE: This cop is disabled if `Lint/ConstantResolution` cop is enabled to prevent
# conflicting rules. Because it respects user configurations that want to enable
# `Lint/ConstantResolution` cop which is disabled by default.
#
# @example
#   # bad
#   ::Const
#
#   # good
#   Const
#
#   # bad
#   class << self
#   ::Const
#   end
#
#   # good
#   class << self
#   Const
#   end
#
#   # good
#   class A
#   ::Const
#   end
#
#   # good
#   module A
#   ::Const
#   end
#
# source://rubocop//lib/rubocop/cop/style/redundant_constant_base.rb#43
class RuboCop::Cop::Style::RedundantConstantBase < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/redundant_constant_base.rb#48
  def on_cbase(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_constant_base.rb#67
  def bad?(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_constant_base.rb#63
  def lint_constant_resolution_config; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_constant_base.rb#59
  def lint_constant_resolution_cop_enabled?; end

  # source://rubocop//lib/rubocop/cop/style/redundant_constant_base.rb#71
  def module_nesting_ancestors_of(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_constant_base.rb#77
  def used_in_super_class_part?(node, class_node:); end
end

# source://rubocop//lib/rubocop/cop/style/redundant_constant_base.rb#46
RuboCop::Cop::Style::RedundantConstantBase::MSG = T.let(T.unsafe(nil), String)

# Checks for redundant uses of double splat hash braces.
#
# @example
#
#   # bad
#   do_something(**{foo: bar, baz: qux})
#
#   # good
#   do_something(foo: bar, baz: qux)
#
# source://rubocop//lib/rubocop/cop/style/redundant_double_splat_hash_braces.rb#16
class RuboCop::Cop::Style::RedundantDoubleSplatHashBraces < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/redundant_double_splat_hash_braces.rb#21
  def on_hash(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/redundant_double_splat_hash_braces.rb#39
  def closing_brace(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_double_splat_hash_braces.rb#35
  def opening_brace(node); end
end

# source://rubocop//lib/rubocop/cop/style/redundant_double_splat_hash_braces.rb#19
RuboCop::Cop::Style::RedundantDoubleSplatHashBraces::MSG = T.let(T.unsafe(nil), String)

# Checks for redundant `each`.
#
# @example
#
#   # bad
#   array.each.each { |v| do_something(v) }
#
#   # good
#   array.each { |v| do_something(v) }
#
#   # bad
#   array.each.each_with_index { |v, i| do_something(v, i) }
#
#   # good
#   array.each.with_index { |v, i| do_something(v, i) }
#   array.each_with_index { |v, i| do_something(v, i) }
#
#   # bad
#   array.each.each_with_object { |v, o| do_something(v, o) }
#
#   # good
#   array.each.with_object { |v, o| do_something(v, o) }
#   array.each_with_object { |v, o| do_something(v, o) }
#
# source://rubocop//lib/rubocop/cop/style/redundant_each.rb#34
class RuboCop::Cop::Style::RedundantEach < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/redundant_each.rb#43
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/redundant_each.rb#93
  def message(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_each.rb#85
  def range(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_each.rb#63
  def redundant_each_method(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_each.rb#104
  def remove_redundant_each(corrector, range, redundant_node); end
end

# source://rubocop//lib/rubocop/cop/style/redundant_each.rb#37
RuboCop::Cop::Style::RedundantEach::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/redundant_each.rb#38
RuboCop::Cop::Style::RedundantEach::MSG_WITH_INDEX = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/redundant_each.rb#39
RuboCop::Cop::Style::RedundantEach::MSG_WITH_OBJECT = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/redundant_each.rb#41
RuboCop::Cop::Style::RedundantEach::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for RuntimeError as the argument of raise/fail.
#
# It checks for code like this:
#
# @example
#   # Bad
#   raise RuntimeError, 'message'
#
#   # Bad
#   raise RuntimeError.new('message')
#
#   # Good
#   raise 'message'
#
# source://rubocop//lib/rubocop/cop/style/redundant_exception.rb#19
class RuboCop::Cop::Style::RedundantException < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/redundant_exception.rb#59
  def compact?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/redundant_exception.rb#54
  def exploded?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/redundant_exception.rb#45
  def fix_compact(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_exception.rb#33
  def fix_exploded(node); end

  # Switch `raise RuntimeError, 'message'` to `raise 'message'`, and
  # `raise RuntimeError.new('message')` to `raise 'message'`.
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_exception.rb#29
  def on_send(node); end
end

# source://rubocop//lib/rubocop/cop/style/redundant_exception.rb#22
RuboCop::Cop::Style::RedundantException::MSG_1 = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/redundant_exception.rb#23
RuboCop::Cop::Style::RedundantException::MSG_2 = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/redundant_exception.rb#25
RuboCop::Cop::Style::RedundantException::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Identifies places where `fetch(key) { value }`
# can be replaced by `fetch(key, value)`.
#
# In such cases `fetch(key, value)` method is faster
# than `fetch(key) { value }`.
#
# @example SafeForConstants: false (default)
#   # bad
#   hash.fetch(:key) { 5 }
#   hash.fetch(:key) { true }
#   hash.fetch(:key) { nil }
#   array.fetch(5) { :value }
#   ENV.fetch(:key) { 'value' }
#
#   # good
#   hash.fetch(:key, 5)
#   hash.fetch(:key, true)
#   hash.fetch(:key, nil)
#   array.fetch(5, :value)
#   ENV.fetch(:key, 'value')
# @example SafeForConstants: true
#   # bad
#   ENV.fetch(:key) { VALUE }
#
#   # good
#   ENV.fetch(:key, VALUE)
#
# source://rubocop//lib/rubocop/cop/style/redundant_fetch_block.rb#38
class RuboCop::Cop::Style::RedundantFetchBlock < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/redundant_fetch_block.rb#53
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_fetch_block.rb#87
  def rails_cache?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/redundant_fetch_block.rb#46
  def redundant_fetch_block_candidate?(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_fetch_block.rb#72
  def basic_literal?(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_fetch_block.rb#102
  def build_bad_method(send, body); end

  # source://rubocop//lib/rubocop/cop/style/redundant_fetch_block.rb#95
  def build_good_method(send, body); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_fetch_block.rb#109
  def check_for_constant?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_fetch_block.rb#113
  def check_for_string?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_fetch_block.rb#76
  def const_type?(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_fetch_block.rb#91
  def fetch_range(send, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_fetch_block.rb#80
  def should_not_check?(send, body); end
end

# source://rubocop//lib/rubocop/cop/style/redundant_fetch_block.rb#43
RuboCop::Cop::Style::RedundantFetchBlock::MSG = T.let(T.unsafe(nil), String)

# Checks for the presence of superfluous `.rb` extension in
# the filename provided to `require` and `require_relative`.
#
# Note: If the extension is omitted, Ruby tries adding '.rb', '.so',
#       and so on to the name until found. If the file named cannot be found,
#       a `LoadError` will be raised.
#       There is an edge case where `foo.so` file is loaded instead of a `LoadError`
#       if `foo.so` file exists when `require 'foo.rb'` will be changed to `require 'foo'`,
#       but that seems harmless.
#
# @example
#   # bad
#   require 'foo.rb'
#   require_relative '../foo.rb'
#
#   # good
#   require 'foo'
#   require 'foo.so'
#   require_relative '../foo'
#   require_relative '../foo.so'
#
# source://rubocop//lib/rubocop/cop/style/redundant_file_extension_in_require.rb#27
class RuboCop::Cop::Style::RedundantFileExtensionInRequire < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/redundant_file_extension_in_require.rb#39
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_file_extension_in_require.rb#35
  def require_call?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/style/redundant_file_extension_in_require.rb#53
  def extension_range(name_node); end
end

# source://rubocop//lib/rubocop/cop/style/redundant_file_extension_in_require.rb#31
RuboCop::Cop::Style::RedundantFileExtensionInRequire::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/redundant_file_extension_in_require.rb#32
RuboCop::Cop::Style::RedundantFileExtensionInRequire::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Check for uses of `Object#freeze` on immutable objects.
#
# NOTE: Regexp and Range literals are frozen objects since Ruby 3.0.
#
# NOTE: From Ruby 3.0, this cop allows explicit freezing of interpolated
# string literals when `# frozen-string-literal: true` is used.
#
# @example
#   # bad
#   CONST = 1.freeze
#
#   # good
#   CONST = 1
#
# source://rubocop//lib/rubocop/cop/style/redundant_freeze.rb#19
class RuboCop::Cop::Style::RedundantFreeze < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::FrozenStringLiteral
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/redundant_freeze.rb#26
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_freeze.rb#57
  def operation_produces_immutable_object?(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_freeze.rb#39
  def immutable_literal?(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_freeze.rb#48
  def strip_parenthesis(node); end
end

# source://rubocop//lib/rubocop/cop/style/redundant_freeze.rb#23
RuboCop::Cop::Style::RedundantFreeze::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/redundant_freeze.rb#24
RuboCop::Cop::Style::RedundantFreeze::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for redundant heredoc delimiter quotes.
#
# @example
#
#   # bad
#   do_something(<<~'EOS')
#   no string interpolation style text
#   EOS
#
#   # good
#   do_something(<<~EOS)
#   no string interpolation style text
#   EOS
#
#   do_something(<<~'EOS')
#   #{string_interpolation_style_text_not_evaluated}
#   EOS
#
#   do_something(<<~'EOS')
#   Preserve \
#   newlines
#   EOS
#
# source://rubocop//lib/rubocop/cop/style/redundant_heredoc_delimiter_quotes.rb#29
class RuboCop::Cop::Style::RedundantHeredocDelimiterQuotes < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Heredoc
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/redundant_heredoc_delimiter_quotes.rb#36
  def on_heredoc(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_heredoc_delimiter_quotes.rb#48
  def need_heredoc_delimiter_quotes?(node); end
end

# source://rubocop//lib/rubocop/cop/style/redundant_heredoc_delimiter_quotes.rb#33
RuboCop::Cop::Style::RedundantHeredocDelimiterQuotes::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/redundant_heredoc_delimiter_quotes.rb#34
RuboCop::Cop::Style::RedundantHeredocDelimiterQuotes::STRING_INTERPOLATION_OR_ESCAPED_CHARACTER_PATTERN = T.let(T.unsafe(nil), Regexp)

# Checks for `initialize` methods that are redundant.
#
# An initializer is redundant if it does not do anything, or if it only
# calls `super` with the same arguments given to it. If the initializer takes
# an argument that accepts multiple values (`restarg`, `kwrestarg`, etc.) it
# will not register an offense, because it allows the initializer to take a different
# number of arguments as its superclass potentially does.
#
# NOTE: If an initializer argument has a default value, RuboCop assumes it
# to *not* be redundant.
#
# NOTE: Empty initializers are registered as offenses, but it is possible
# to purposely create an empty `initialize` method to override a superclass's
# initializer.
#
# @example
#   # bad
#   def initialize
#   end
#
#   # bad
#   def initialize
#   super
#   end
#
#   # bad
#   def initialize(a, b)
#   super
#   end
#
#   # bad
#   def initialize(a, b)
#   super(a, b)
#   end
#
#   # good
#   def initialize
#   do_something
#   end
#
#   # good
#   def initialize
#   do_something
#   super
#   end
#
#   # good (different number of parameters)
#   def initialize(a, b)
#   super(a)
#   end
#
#   # good (default value)
#   def initialize(a, b = 5)
#   super
#   end
#
#   # good (default value)
#   def initialize(a, b: 5)
#   super
#   end
#
#   # good (changes the parameter requirements)
#   def initialize(*)
#   end
#
#   # good (changes the parameter requirements)
#   def initialize(**)
#   end
#
#   # good (changes the parameter requirements)
#   def initialize(...)
#   end
# @example AllowComments: true (default)
#
#   # good
#   def initialize
#   # Overriding to negate superclass `initialize` method.
#   end
# @example AllowComments: false
#
#   # bad
#   def initialize
#   # Overriding to negate superclass `initialize` method.
#   end
#
# source://rubocop//lib/rubocop/cop/style/redundant_initialize.rb#97
class RuboCop::Cop::Style::RedundantInitialize < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::CommentsHelp
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/redundant_initialize.rb#106
  def initialize_forwards?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/redundant_initialize.rb#110
  def on_def(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_initialize.rb#134
  def acceptable?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_initialize.rb#142
  def allow_comments?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_initialize.rb#138
  def forwards?(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_initialize.rb#128
  def register_offense(node, message); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_initialize.rb#148
  def same_args?(super_node, args); end
end

# source://rubocop//lib/rubocop/cop/style/redundant_initialize.rb#102
RuboCop::Cop::Style::RedundantInitialize::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/redundant_initialize.rb#103
RuboCop::Cop::Style::RedundantInitialize::MSG_EMPTY = T.let(T.unsafe(nil), String)

# Checks for strings that are just an interpolated expression.
#
# @example
#
#   # bad
#   "#{@var}"
#
#   # good
#   @var.to_s
#
#   # good if @var is already a String
#   @var
#
# source://rubocop//lib/rubocop/cop/style/redundant_interpolation.rb#39
class RuboCop::Cop::Style::RedundantInterpolation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::PercentLiteral
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/redundant_interpolation.rb#49
  def on_dstr(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/redundant_interpolation.rb#122
  def autocorrect_other(corrector, embedded_node, node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_interpolation.rb#105
  def autocorrect_single_variable_interpolation(corrector, embedded_node, node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_interpolation.rb#99
  def autocorrect_variable_interpolation(corrector, embedded_node, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_interpolation.rb#95
  def embedded_in_percent_array?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_interpolation.rb#91
  def implicit_concatenation?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_interpolation.rb#83
  def interpolation?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_interpolation.rb#132
  def require_parentheses?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_interpolation.rb#67
  def single_interpolation?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_interpolation.rb#74
  def single_variable_interpolation?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_interpolation.rb#87
  def variable_interpolation?(node); end

  class << self
    # source://rubocop//lib/rubocop/cop/style/redundant_interpolation.rb#45
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop//lib/rubocop/cop/style/redundant_interpolation.rb#43
RuboCop::Cop::Style::RedundantInterpolation::MSG = T.let(T.unsafe(nil), String)

# Check for redundant line continuation.
#
# This cop marks a line continuation as redundant if removing the backslash
# does not result in a syntax error.
# However, a backslash at the end of a comment or
# for string concatenation is not redundant and is not considered an offense.
#
# @example
#   # bad
#   foo. \
#   bar
#   foo \
#   &.bar \
#   .baz
#
#   # good
#   foo.
#   bar
#   foo
#   &.bar
#   .baz
#
#   # bad
#   [foo, \
#   bar]
#   {foo: \
#   bar}
#
#   # good
#   [foo,
#   bar]
#   {foo:
#   bar}
#
#   # bad
#   foo(bar, \
#   baz)
#
#   # good
#   foo(bar,
#   baz)
#
#   # also good - backslash in string concatenation is not redundant
#   foo('bar' \
#   'baz')
#
#   # also good - backslash at the end of a comment is not redundant
#   foo(bar, # \
#   baz)
#
#   # also good - backslash at the line following the newline begins with a + or -,
#   # it is not redundant
#   1 \
#   + 2 \
#   - 3
#
#   # also good - backslash with newline between the method name and its arguments,
#   # it is not redundant.
#   some_method \
#   (argument)
#
# source://rubocop//lib/rubocop/cop/style/redundant_line_continuation.rb#67
class RuboCop::Cop::Style::RedundantLineContinuation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::MatchRange
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/redundant_line_continuation.rb#73
  def on_new_investigation; end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_line_continuation.rb#109
  def argument_newline?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_line_continuation.rb#94
  def ends_with_backslash_without_comment?(source_line); end

  # source://rubocop//lib/rubocop/cop/style/redundant_line_continuation.rb#116
  def find_node_for_line(line); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_line_continuation.rb#102
  def redundant_line_continuation?(range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_line_continuation.rb#88
  def require_line_continuation?(range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_line_continuation.rb#122
  def same_line?(node, line); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_line_continuation.rb#136
  def starts_with_plus_or_minus?(source_line); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_line_continuation.rb#98
  def string_concatenation?(source_line); end
end

# source://rubocop//lib/rubocop/cop/style/redundant_line_continuation.rb#71
RuboCop::Cop::Style::RedundantLineContinuation::MSG = T.let(T.unsafe(nil), String)

# Checks for redundant parentheses.
#
# @example
#
#   # bad
#   (x) if ((y.z).nil?)
#
#   # good
#   x if y.z.nil?
#
# source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#16
class RuboCop::Cop::Style::RedundantParentheses < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Parentheses
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#33
  def allowed_pin_operator?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#36
  def arg_in_call_with_block?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#220
  def first_send_argument?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#225
  def first_super_argument?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#230
  def first_yield_argument?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#138
  def interpolation?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#27
  def method_node_and_args(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#38
  def on_begin(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#24
  def range_end?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#30
  def rescue?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#21
  def square_brackets?(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#68
  def allowed_ancestor?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#61
  def allowed_expression?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#73
  def allowed_method_call?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#78
  def allowed_multiple_expression?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#87
  def allowed_ternary?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#234
  def call_chain_starts_with_int?(begin_node, send_node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#125
  def check(begin_node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#140
  def check_send(begin_node, node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#149
  def check_unary(begin_node, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#173
  def disallowed_literal?(begin_node, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#105
  def empty_parentheses?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#110
  def first_arg_begins_with_hash_literal?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#215
  def first_argument?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#54
  def ignore_syntax?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#169
  def keyword_ancestor?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#188
  def keyword_with_redundant_parentheses?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#100
  def like_method_argument_parentheses?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#201
  def method_call_with_redundant_parentheses?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#117
  def method_chain_begins_with_hash_literal?(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#159
  def offense(node, msg); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#211
  def only_begin_arg?(args); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#46
  def parens_allowed?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#177
  def raised_to_power_negative_numeric?(begin_node, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#165
  def suspect_unary?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#93
  def ternary_parentheses_required?; end
end

# Checks for usage of the %q/%Q syntax when '' or "" would do.
#
# @example
#
#   # bad
#   name = %q(Bruce Wayne)
#   time = %q(8 o'clock)
#   question = %q("What did you say?")
#
#   # good
#   name = 'Bruce Wayne'
#   time = "8 o'clock"
#   question = '"What did you say?"'
#
# source://rubocop//lib/rubocop/cop/style/redundant_percent_q.rb#20
class RuboCop::Cop::Style::RedundantPercentQ < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/redundant_percent_q.rb#34
  def on_dstr(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_percent_q.rb#40
  def on_str(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_percent_q.rb#99
  def acceptable_capital_q?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_percent_q.rb#91
  def acceptable_q?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_percent_q.rb#67
  def allowed_percent_q?(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_percent_q.rb#51
  def check(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_percent_q.rb#63
  def interpolated_quotes?(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_percent_q.rb#72
  def message(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_percent_q.rb#87
  def start_with_percent_q_variant?(string); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_percent_q.rb#82
  def string_literal?(node); end
end

# source://rubocop//lib/rubocop/cop/style/redundant_percent_q.rb#25
RuboCop::Cop::Style::RedundantPercentQ::DYNAMIC_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/redundant_percent_q.rb#28
RuboCop::Cop::Style::RedundantPercentQ::EMPTY = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/redundant_percent_q.rb#32
RuboCop::Cop::Style::RedundantPercentQ::ESCAPED_NON_BACKSLASH = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/style/redundant_percent_q.rb#23
RuboCop::Cop::Style::RedundantPercentQ::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/redundant_percent_q.rb#30
RuboCop::Cop::Style::RedundantPercentQ::PERCENT_CAPITAL_Q = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/redundant_percent_q.rb#29
RuboCop::Cop::Style::RedundantPercentQ::PERCENT_Q = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/redundant_percent_q.rb#27
RuboCop::Cop::Style::RedundantPercentQ::QUOTE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/redundant_percent_q.rb#26
RuboCop::Cop::Style::RedundantPercentQ::SINGLE_QUOTE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/redundant_percent_q.rb#31
RuboCop::Cop::Style::RedundantPercentQ::STRING_INTERPOLATION_REGEXP = T.let(T.unsafe(nil), Regexp)

# Checks for unnecessary single-element Regexp character classes.
#
# @example
#
#   # bad
#   r = /[x]/
#
#   # good
#   r = /x/
#
#   # bad
#   r = /[\s]/
#
#   # good
#   r = /\s/
#
#   # bad
#   r = %r{/[b]}
#
#   # good
#   r = %r{/b}
#
#   # good
#   r = /[ab]/
#
# source://rubocop//lib/rubocop/cop/style/redundant_regexp_character_class.rb#30
class RuboCop::Cop::Style::RedundantRegexpCharacterClass < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/redundant_regexp_character_class.rb#37
  def on_regexp(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_regexp_character_class.rb#101
  def backslash_b?(elem); end

  # source://rubocop//lib/rubocop/cop/style/redundant_regexp_character_class.rb#53
  def each_redundant_character_class(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_regexp_character_class.rb#61
  def each_single_element_character_class(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_regexp_character_class.rb#83
  def multiple_codepoints?(expression); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_regexp_character_class.rb#107
  def octal_requiring_char_class?(elem); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_regexp_character_class.rb#72
  def redundant_single_element_character_class?(node, char_class); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_regexp_character_class.rb#113
  def requires_escape_outside_char_class?(elem); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_regexp_character_class.rb#95
  def whitespace_in_free_space_mode?(node, elem); end

  # source://rubocop//lib/rubocop/cop/style/redundant_regexp_character_class.rb#87
  def without_character_class(loc); end
end

# source://rubocop//lib/rubocop/cop/style/redundant_regexp_character_class.rb#34
RuboCop::Cop::Style::RedundantRegexpCharacterClass::MSG_REDUNDANT_CHARACTER_CLASS = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/redundant_regexp_character_class.rb#33
RuboCop::Cop::Style::RedundantRegexpCharacterClass::REQUIRES_ESCAPE_OUTSIDE_CHAR_CLASS_CHARS = T.let(T.unsafe(nil), Array)

# Checks for redundant escapes inside Regexp literals.
#
# @example
#   # bad
#   %r{foo\/bar}
#
#   # good
#   %r{foo/bar}
#
#   # good
#   /foo\/bar/
#
#   # good
#   %r/foo\/bar/
#
#   # good
#   %r!foo\!bar!
#
#   # bad
#   /a\-b/
#
#   # good
#   /a-b/
#
#   # bad
#   /[\+\-]\d/
#
#   # good
#   /[+\-]\d/
#
# source://rubocop//lib/rubocop/cop/style/redundant_regexp_escape.rb#35
class RuboCop::Cop::Style::RedundantRegexpEscape < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/redundant_regexp_escape.rb#45
  def on_regexp(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_regexp_escape.rb#59
  def allowed_escape?(node, char, index, within_character_class); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_regexp_escape.rb#75
  def char_class_begins_or_ends_with_escaped_hyphen?(node, index); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_regexp_escape.rb#91
  def delimiter?(node, char); end

  # Please remove this `else` branch when support for regexp_parser 1.8 will be dropped.
  # It's for compatibility with regexp_parser 1.8 and will never be maintained.
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_regexp_escape.rb#98
  def each_escape(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_regexp_escape.rb#125
  def escape_range_at_index(node, index); end
end

# source://rubocop//lib/rubocop/cop/style/redundant_regexp_escape.rb#41
RuboCop::Cop::Style::RedundantRegexpEscape::ALLOWED_ALWAYS_ESCAPES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/redundant_regexp_escape.rb#43
RuboCop::Cop::Style::RedundantRegexpEscape::ALLOWED_OUTSIDE_CHAR_CLASS_METACHAR_ESCAPES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/redundant_regexp_escape.rb#42
RuboCop::Cop::Style::RedundantRegexpEscape::ALLOWED_WITHIN_CHAR_CLASS_METACHAR_ESCAPES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/redundant_regexp_escape.rb#39
RuboCop::Cop::Style::RedundantRegexpEscape::MSG_REDUNDANT_ESCAPE = T.let(T.unsafe(nil), String)

# Checks for redundant `return` expressions.
#
# @example
#   # These bad cases should be extended to handle methods whose body is
#   # if/else or a case expression with a default branch.
#
#   # bad
#   def test
#   return something
#   end
#
#   # bad
#   def test
#   one
#   two
#   three
#   return something
#   end
#
#   # good
#   def test
#   return something if something_else
#   end
#
#   # good
#   def test
#   if x
#   elsif y
#   else
#   end
#   end
# @example AllowMultipleReturnValues: false (default)
#   # bad
#   def test
#   return x, y
#   end
# @example AllowMultipleReturnValues: true
#   # good
#   def test
#   return x, y
#   end
#
# source://rubocop//lib/rubocop/cop/style/redundant_return.rb#50
class RuboCop::Cop::Style::RedundantReturn < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/redundant_return.rb#64
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_return.rb#64
  def on_defs(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_return.rb#58
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/redundant_return.rb#99
  def add_braces(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_return.rb#94
  def add_brackets(corrector, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_return.rb#164
  def allow_multiple_return_values?; end

  # source://rubocop//lib/rubocop/cop/style/redundant_return.rb#159
  def check_begin_node(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_return.rb#105
  def check_branch(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_return.rb#133
  def check_case_node(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_return.rb#154
  def check_ensure_node(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_return.rb#138
  def check_if_node(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_return.rb#150
  def check_resbody_node(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_return.rb#145
  def check_rescue_node(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_return.rb#121
  def check_return_node(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_return.rb#75
  def correct_with_arguments(return_node, corrector); end

  # source://rubocop//lib/rubocop/cop/style/redundant_return.rb#71
  def correct_without_arguments(return_node, corrector); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_return.rb#90
  def hash_without_braces?(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_return.rb#168
  def message(node); end
end

# source://rubocop//lib/rubocop/cop/style/redundant_return.rb#54
RuboCop::Cop::Style::RedundantReturn::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/redundant_return.rb#55
RuboCop::Cop::Style::RedundantReturn::MULTI_RETURN_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/redundant_return.rb#56
RuboCop::Cop::Style::RedundantReturn::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for redundant uses of `self`.
#
# The usage of `self` is only needed when:
#
# * Sending a message to same object with zero arguments in
#   presence of a method name clash with an argument or a local
#   variable.
#
# * Calling an attribute writer to prevent a local variable assignment.
#
# Note, with using explicit self you can only send messages with public or
# protected scope, you cannot send private messages this way.
#
# Note we allow uses of `self` with operators because it would be awkward
# otherwise.
#
# @example
#
#   # bad
#   def foo(bar)
#   self.baz
#   end
#
#   # good
#   def foo(bar)
#   self.bar  # Resolves name clash with the argument.
#   end
#
#   def foo
#   bar = 1
#   self.bar  # Resolves name clash with the local variable.
#   end
#
#   def foo
#   %w[x y z].select do |bar|
#   self.bar == bar  # Resolves name clash with argument of the block.
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/style/redundant_self.rb#44
class RuboCop::Cop::Style::RedundantSelf < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # @return [RedundantSelf] a new instance of RedundantSelf
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_self.rb#59
  def initialize(config = T.unsafe(nil), options = T.unsafe(nil)); end

  # Assignment of self.x
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_self.rb#67
  def on_and_asgn(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_self.rb#85
  def on_args(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_self.rb#119
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_self.rb#89
  def on_blockarg(node); end

  # Using self.x to distinguish from local variable x
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_self.rb#80
  def on_def(node); end

  # Using self.x to distinguish from local variable x
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_self.rb#80
  def on_defs(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_self.rb#125
  def on_if(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_self.rb#103
  def on_in_pattern(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_self.rb#98
  def on_lvasgn(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_self.rb#93
  def on_masgn(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_self.rb#119
  def on_numblock(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_self.rb#73
  def on_op_asgn(node); end

  # Assignment of self.x
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_self.rb#67
  def on_or_asgn(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_self.rb#107
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_self.rb#125
  def on_until(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_self.rb#125
  def on_while(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/redundant_self.rb#181
  def add_lhs_to_local_variables_scopes(rhs, lhs); end

  # source://rubocop//lib/rubocop/cop/style/redundant_self.rb#189
  def add_masgn_lhs_variables(rhs, lhs); end

  # source://rubocop//lib/rubocop/cop/style/redundant_self.rb#195
  def add_match_var_scopes(in_pattern_node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_self.rb#143
  def add_scope(node, local_variables = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/redundant_self.rb#175
  def allow_self(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_self.rb#149
  def allowed_send_node?(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_self.rb#166
  def on_argument(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_self.rb#158
  def regular_method_call?(node); end

  class << self
    # source://rubocop//lib/rubocop/cop/style/redundant_self.rb#55
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop//lib/rubocop/cop/style/redundant_self.rb#48
RuboCop::Cop::Style::RedundantSelf::KERNEL_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/redundant_self.rb#49
RuboCop::Cop::Style::RedundantSelf::KEYWORDS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/redundant_self.rb#47
RuboCop::Cop::Style::RedundantSelf::MSG = T.let(T.unsafe(nil), String)

# Checks for places where redundant assignments are made for in place
# modification methods.
#
# @example
#   # bad
#   args = args.concat(ary)
#   hash = hash.merge!(other)
#
#   # good
#   args.concat(foo)
#   args += foo
#   hash.merge!(other)
#
#   # bad
#   self.foo = foo.concat(ary)
#
#   # good
#   foo.concat(ary)
#   self.foo += ary
#
# source://rubocop//lib/rubocop/cop/style/redundant_self_assignment.rb#31
class RuboCop::Cop::Style::RedundantSelfAssignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/redundant_self_assignment.rb#52
  def on_cvasgn(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_self_assignment.rb#52
  def on_gvasgn(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_self_assignment.rb#52
  def on_ivasgn(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_self_assignment.rb#52
  def on_lvasgn(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_self_assignment.rb#69
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_self_assignment.rb#96
  def redundant_nonself_assignment?(param0 = T.unsafe(nil), param1, param2); end

  # source://rubocop//lib/rubocop/cop/style/redundant_self_assignment.rb#86
  def redundant_self_assignment?(param0 = T.unsafe(nil), param1); end

  private

  # source://rubocop//lib/rubocop/cop/style/redundant_self_assignment.rb#112
  def correction_range(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_self_assignment.rb#81
  def method_returning_self?(method_name); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_self_assignment.rb#105
  def redundant_assignment?(node); end
end

# source://rubocop//lib/rubocop/cop/style/redundant_self_assignment.rb#45
RuboCop::Cop::Style::RedundantSelfAssignment::ASSIGNMENT_TYPE_TO_RECEIVER_TYPE = T.let(T.unsafe(nil), Hash)

# source://rubocop//lib/rubocop/cop/style/redundant_self_assignment.rb#38
RuboCop::Cop::Style::RedundantSelfAssignment::METHODS_RETURNING_SELF = T.let(T.unsafe(nil), Set)

# source://rubocop//lib/rubocop/cop/style/redundant_self_assignment.rb#35
RuboCop::Cop::Style::RedundantSelfAssignment::MSG = T.let(T.unsafe(nil), String)

# Checks for places where conditional branch makes redundant self-assignment.
#
# It only detects local variable because it may replace state of instance variable,
# class variable, and global variable that have state across methods with `nil`.
#
# @example
#
#   # bad
#   foo = condition ? bar : foo
#
#   # good
#   foo = bar if condition
#
#   # bad
#   foo = condition ? foo : bar
#
#   # good
#   foo = bar unless condition
#
# source://rubocop//lib/rubocop/cop/style/redundant_self_assignment_branch.rb#25
class RuboCop::Cop::Style::RedundantSelfAssignmentBranch < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/redundant_self_assignment_branch.rb#32
  def bad_method?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/redundant_self_assignment_branch.rb#36
  def on_lvasgn(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_self_assignment_branch.rb#59
  def inconvertible_to_modifier?(if_branch, else_branch); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_self_assignment_branch.rb#64
  def multiple_statements?(branch); end

  # source://rubocop//lib/rubocop/cop/style/redundant_self_assignment_branch.rb#72
  def register_offense(if_node, offense_branch, opposite_branch, keyword); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_self_assignment_branch.rb#68
  def self_assign?(variable, branch); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_self_assignment_branch.rb#53
  def use_if_and_else_branch?(expression); end
end

# source://rubocop//lib/rubocop/cop/style/redundant_self_assignment_branch.rb#29
RuboCop::Cop::Style::RedundantSelfAssignmentBranch::MSG = T.let(T.unsafe(nil), String)

# Identifies instances of sorting and then
# taking only the first or last element. The same behavior can
# be accomplished without a relatively expensive sort by using
# `Enumerable#min` instead of sorting and taking the first
# element and `Enumerable#max` instead of sorting and taking the
# last element. Similarly, `Enumerable#min_by` and
# `Enumerable#max_by` can replace `Enumerable#sort_by` calls
# after which only the first or last element is used.
#
# @example
#   # bad
#   [2, 1, 3].sort.first
#   [2, 1, 3].sort[0]
#   [2, 1, 3].sort.at(0)
#   [2, 1, 3].sort.slice(0)
#
#   # good
#   [2, 1, 3].min
#
#   # bad
#   [2, 1, 3].sort.last
#   [2, 1, 3].sort[-1]
#   [2, 1, 3].sort.at(-1)
#   [2, 1, 3].sort.slice(-1)
#
#   # good
#   [2, 1, 3].max
#
#   # bad
#   arr.sort_by(&:foo).first
#   arr.sort_by(&:foo)[0]
#   arr.sort_by(&:foo).at(0)
#   arr.sort_by(&:foo).slice(0)
#
#   # good
#   arr.min_by(&:foo)
#
#   # bad
#   arr.sort_by(&:foo).last
#   arr.sort_by(&:foo)[-1]
#   arr.sort_by(&:foo).at(-1)
#   arr.sort_by(&:foo).slice(-1)
#
#   # good
#   arr.max_by(&:foo)
#
# source://rubocop//lib/rubocop/cop/style/redundant_sort.rb#79
class RuboCop::Cop::Style::RedundantSort < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/redundant_sort.rb#104
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_sort.rb#88
  def redundant_sort?(param0 = T.unsafe(nil)); end

  private

  # This gets the start of the accessor whether it has a dot
  # (e.g. `.first`) or doesn't (e.g. `[0]`)
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_sort.rb#192
  def accessor_start(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_sort.rb#182
  def arg_node(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_sort.rb#186
  def arg_value(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_sort.rb#147
  def autocorrect(corrector, node, sort_node, sorter, accessor); end

  # source://rubocop//lib/rubocop/cop/style/redundant_sort.rb#165
  def base(accessor, arg); end

  # source://rubocop//lib/rubocop/cop/style/redundant_sort.rb#114
  def find_redundant_sort(*nodes); end

  # source://rubocop//lib/rubocop/cop/style/redundant_sort.rb#135
  def message(node, sorter, accessor); end

  # source://rubocop//lib/rubocop/cop/style/redundant_sort.rb#131
  def offense_range(sort_node, node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_sort.rb#124
  def register_offense(node, sort_node, sorter, accessor); end

  # source://rubocop//lib/rubocop/cop/style/redundant_sort.rb#156
  def replace_with_logical_operator(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_sort.rb#173
  def suffix(sorter); end

  # source://rubocop//lib/rubocop/cop/style/redundant_sort.rb#161
  def suggestion(sorter, accessor, arg); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_sort.rb#200
  def with_logical_operator?(node); end
end

# source://rubocop//lib/rubocop/cop/style/redundant_sort.rb#83
RuboCop::Cop::Style::RedundantSort::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/redundant_sort.rb#85
RuboCop::Cop::Style::RedundantSort::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Identifies places where `sort_by { ... }` can be replaced by
# `sort`.
#
# @example
#   # bad
#   array.sort_by { |x| x }
#   array.sort_by do |var|
#   var
#   end
#
#   # good
#   array.sort
#
# source://rubocop//lib/rubocop/cop/style/redundant_sort_by.rb#18
class RuboCop::Cop::Style::RedundantSortBy < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/redundant_sort_by.rb#25
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_sort_by.rb#35
  def on_numblock(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_sort_by.rb#48
  def redundant_sort_by_block(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/redundant_sort_by.rb#53
  def redundant_sort_by_numblock(param0 = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/style/redundant_sort_by.rb#57
  def sort_by_range(send, node); end
end

# source://rubocop//lib/rubocop/cop/style/redundant_sort_by.rb#22
RuboCop::Cop::Style::RedundantSortBy::MSG_BLOCK = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/redundant_sort_by.rb#23
RuboCop::Cop::Style::RedundantSortBy::MSG_NUMBLOCK = T.let(T.unsafe(nil), String)

# Checks for redundant escapes in string literals.
#
# @example
#   # bad - no need to escape # without following {/$/@
#   "\#foo"
#
#   # bad - no need to escape single quotes inside double quoted string
#   "\'foo\'"
#
#   # bad - heredocs are also checked for unnecessary escapes
#   <<~STR
#   \#foo \"foo\"
#   STR
#
#   # good
#   "#foo"
#
#   # good
#   "\#{no_interpolation}"
#
#   # good
#   "'foo'"
#
#   # good
#   "foo\
#   bar"
#
#   # good
#   <<~STR
#   #foo "foo"
#   STR
#
# source://rubocop//lib/rubocop/cop/style/redundant_string_escape.rb#37
class RuboCop::Cop::Style::RedundantStringEscape < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::MatchRange
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/redundant_string_escape.rb#43
  def on_str(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_string_escape.rb#79
  def allowed_escape?(node, range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_string_escape.rb#119
  def array_literal?(node, prefix); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_string_escape.rb#73
  def begin_loc_present?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_string_escape.rb#153
  def delimiter?(node, char); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_string_escape.rb#169
  def disabling_interpolation?(range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_string_escape.rb#149
  def heredoc?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_string_escape.rb#139
  def heredoc_with_disabled_interpolation?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_string_escape.rb#100
  def interpolation_not_enabled?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_string_escape.rb#165
  def literal_in_interpolated_or_multiline_string?(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_string_escape.rb#59
  def message(range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_string_escape.rb#135
  def percent_array_literal?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_string_escape.rb#111
  def percent_q_literal?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_string_escape.rb#127
  def percent_w_literal?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_string_escape.rb#131
  def percent_w_upper_literal?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/redundant_string_escape.rb#107
  def single_quoted?(node); end

  # source://rubocop//lib/rubocop/cop/style/redundant_string_escape.rb#63
  def str_contents_range(node); end
end

# source://rubocop//lib/rubocop/cop/style/redundant_string_escape.rb#41
RuboCop::Cop::Style::RedundantStringEscape::MSG = T.let(T.unsafe(nil), String)

# Enforces using // or %r around regular expressions.
#
# @example EnforcedStyle: slashes (default)
#   # bad
#   snake_case = %r{^[\dA-Z_]+$}
#
#   # bad
#   regex = %r{
#   foo
#   (bar)
#   (baz)
#   }x
#
#   # good
#   snake_case = /^[\dA-Z_]+$/
#
#   # good
#   regex = /
#   foo
#   (bar)
#   (baz)
#   /x
# @example EnforcedStyle: percent_r
#   # bad
#   snake_case = /^[\dA-Z_]+$/
#
#   # bad
#   regex = /
#   foo
#   (bar)
#   (baz)
#   /x
#
#   # good
#   snake_case = %r{^[\dA-Z_]+$}
#
#   # good
#   regex = %r{
#   foo
#   (bar)
#   (baz)
#   }x
# @example EnforcedStyle: mixed
#   # bad
#   snake_case = %r{^[\dA-Z_]+$}
#
#   # bad
#   regex = /
#   foo
#   (bar)
#   (baz)
#   /x
#
#   # good
#   snake_case = /^[\dA-Z_]+$/
#
#   # good
#   regex = %r{
#   foo
#   (bar)
#   (baz)
#   }x
# @example AllowInnerSlashes: false (default)
#   # If `false`, the cop will always recommend using `%r` if one or more
#   # slashes are found in the regexp string.
#
#   # bad
#   x =~ /home\//
#
#   # good
#   x =~ %r{home/}
# @example AllowInnerSlashes: true
#   # good
#   x =~ /home\//
#
# source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#84
class RuboCop::Cop::Style::RegexpLiteral < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#92
  def on_regexp(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#135
  def allow_inner_slashes?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#123
  def allowed_mixed_percent_r?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#113
  def allowed_mixed_slash?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#152
  def allowed_omit_parentheses_with_percent_r_literal?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#117
  def allowed_percent_r_literal?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#109
  def allowed_slash_literal?(node); end

  # source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#212
  def calculate_replacement(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#127
  def contains_disallowed_slash?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#131
  def contains_slash?(node); end

  # source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#161
  def correct_delimiters(node, corrector); end

  # source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#167
  def correct_inner_slashes(node, corrector); end

  # source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#200
  def inner_slash_after_correction(node); end

  # source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#196
  def inner_slash_before_correction(node); end

  # source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#204
  def inner_slash_for(opening_delimiter); end

  # source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#183
  def inner_slash_indices(node); end

  # source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#139
  def node_body(node, include_begin_nodes: T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#148
  def preferred_delimiters; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#144
  def slash_literal?(node); end
end

# source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#90
RuboCop::Cop::Style::RegexpLiteral::MSG_USE_PERCENT_R = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#89
RuboCop::Cop::Style::RegexpLiteral::MSG_USE_SLASHES = T.let(T.unsafe(nil), String)

# Sort `require` and `require_relative` in alphabetical order.
#
# @example
#   # bad
#   require 'b'
#   require 'a'
#
#   # good
#   require 'a'
#   require 'b'
#
#   # bad
#   require_relative 'b'
#   require_relative 'a'
#
#   # good
#   require_relative 'a'
#   require_relative 'b'
#
#   # good (sorted within each section separated by a blank line)
#   require 'a'
#   require 'd'
#
#   require 'b'
#   require 'c'
#
#   # good
#   require 'b'
#   require_relative 'c'
#   require 'a'
#
#   # bad
#   require 'a'
#   require 'c' if foo
#   require 'b'
#
#   # good
#   require 'a'
#   require 'b'
#   require 'c' if foo
#
#   # bad
#   require 'c'
#   if foo
#   require 'd'
#   require 'b'
#   end
#   require 'a'
#
#   # good
#   require 'c'
#   if foo
#   require 'b'
#   require 'd'
#   end
#   require 'a'
#
# source://rubocop//lib/rubocop/cop/style/require_order.rb#66
class RuboCop::Cop::Style::RequireOrder < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/require_order.rb#76
  def if_inside_only_require(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/require_order.rb#83
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/require_order.rb#104
  def find_previous_older_sibling(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/require_order.rb#127
  def in_same_section?(node1, node2); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/require_order.rb#100
  def not_modifier_form?(node); end

  # source://rubocop//lib/rubocop/cop/style/require_order.rb#117
  def search_node(node); end

  # source://rubocop//lib/rubocop/cop/style/require_order.rb#121
  def sibling_node(node); end
end

# source://rubocop//lib/rubocop/cop/style/require_order.rb#73
RuboCop::Cop::Style::RequireOrder::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/require_order.rb#71
RuboCop::Cop::Style::RequireOrder::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for uses of rescue in its modifier form.
#
# The cop to check `rescue` in its modifier form is added for following
# reasons:
#
# * The syntax of modifier form `rescue` can be misleading because it
#   might lead us to believe that `rescue` handles the given exception
#   but it actually rescue all exceptions to return the given rescue
#   block. In this case, value returned by handle_error or
#   SomeException.
#
# * Modifier form `rescue` would rescue all the exceptions. It would
#   silently skip all exception or errors and handle the error.
#   Example: If `NoMethodError` is raised, modifier form rescue would
#   handle the exception.
#
# @example
#   # bad
#   some_method rescue handle_error
#
#   # bad
#   some_method rescue SomeException
#
#   # good
#   begin
#   some_method
#   rescue
#   handle_error
#   end
#
#   # good
#   begin
#   some_method
#   rescue SomeException
#   handle_error
#   end
#
# source://rubocop//lib/rubocop/cop/style/rescue_modifier.rb#42
class RuboCop::Cop::Style::RescueModifier < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::RescueNode
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/rescue_modifier.rb#54
  def on_resbody(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/rescue_modifier.rb#72
  def correct_rescue_block(corrector, node, parenthesized); end

  # source://rubocop//lib/rubocop/cop/style/rescue_modifier.rb#88
  def indentation_and_offset(node, parenthesized); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/rescue_modifier.rb#68
  def parenthesized?(node); end

  class << self
    # source://rubocop//lib/rubocop/cop/style/rescue_modifier.rb#50
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop//lib/rubocop/cop/style/rescue_modifier.rb#48
RuboCop::Cop::Style::RescueModifier::MSG = T.let(T.unsafe(nil), String)

# Checks for rescuing `StandardError`. There are two supported
# styles `implicit` and `explicit`. This cop will not register an offense
# if any error other than `StandardError` is specified.
#
# @example EnforcedStyle: explicit (default)
#   # `explicit` will enforce using `rescue StandardError`
#   # instead of `rescue`.
#
#   # bad
#   begin
#   foo
#   rescue
#   bar
#   end
#
#   # good
#   begin
#   foo
#   rescue StandardError
#   bar
#   end
#
#   # good
#   begin
#   foo
#   rescue OtherError
#   bar
#   end
#
#   # good
#   begin
#   foo
#   rescue StandardError, SecurityError
#   bar
#   end
# @example EnforcedStyle: implicit
#   # `implicit` will enforce using `rescue` instead of
#   # `rescue StandardError`.
#
#   # bad
#   begin
#   foo
#   rescue StandardError
#   bar
#   end
#
#   # good
#   begin
#   foo
#   rescue
#   bar
#   end
#
#   # good
#   begin
#   foo
#   rescue OtherError
#   bar
#   end
#
#   # good
#   begin
#   foo
#   rescue StandardError, SecurityError
#   bar
#   end
#
# source://rubocop//lib/rubocop/cop/style/rescue_standard_error.rb#73
class RuboCop::Cop::Style::RescueStandardError < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RescueNode
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/rescue_standard_error.rb#92
  def on_resbody(node); end

  # source://rubocop//lib/rubocop/cop/style/rescue_standard_error.rb#88
  def rescue_standard_error?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/rescue_standard_error.rb#83
  def rescue_without_error_class?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/style/rescue_standard_error.rb#118
  def offense_for_explicit_enforced_style(node); end

  # source://rubocop//lib/rubocop/cop/style/rescue_standard_error.rb#107
  def offense_for_implicit_enforced_style(node, error); end
end

# source://rubocop//lib/rubocop/cop/style/rescue_standard_error.rb#80
RuboCop::Cop::Style::RescueStandardError::MSG_EXPLICIT = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/rescue_standard_error.rb#79
RuboCop::Cop::Style::RescueStandardError::MSG_IMPLICIT = T.let(T.unsafe(nil), String)

# Enforces consistency between 'return nil' and 'return'.
#
# Supported styles are: return, return_nil.
#
# @example EnforcedStyle: return (default)
#   # bad
#   def foo(arg)
#   return nil if arg
#   end
#
#   # good
#   def foo(arg)
#   return if arg
#   end
# @example EnforcedStyle: return_nil
#   # bad
#   def foo(arg)
#   return if arg
#   end
#
#   # good
#   def foo(arg)
#   return nil if arg
#   end
#
# source://rubocop//lib/rubocop/cop/style/return_nil.rb#31
class RuboCop::Cop::Style::ReturnNil < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/return_nil.rb#86
  def chained_send?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/return_nil.rb#89
  def define_method?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/return_nil.rb#44
  def on_return(node); end

  # source://rubocop//lib/rubocop/cop/style/return_nil.rb#42
  def return_nil_node?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/return_nil.rb#39
  def return_node?(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/return_nil.rb#76
  def correct_style?(node); end

  # source://rubocop//lib/rubocop/cop/style/return_nil.rb#72
  def message(_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/return_nil.rb#81
  def scoped_node?(node); end
end

# source://rubocop//lib/rubocop/cop/style/return_nil.rb#35
RuboCop::Cop::Style::ReturnNil::RETURN_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/return_nil.rb#36
RuboCop::Cop::Style::ReturnNil::RETURN_NIL_MSG = T.let(T.unsafe(nil), String)

# Transforms usages of a method call safeguarded by a non `nil`
# check for the variable whose method is being called to
# safe navigation (`&.`). If there is a method chain, all of the methods
# in the chain need to be checked for safety, and all of the methods will
# need to be changed to use safe navigation.
#
# The default for `ConvertCodeThatCanStartToReturnNil` is `false`.
# When configured to `true`, this will
# check for code in the format `!foo.nil? && foo.bar`. As it is written,
# the return of this code is limited to `false` and whatever the return
# of the method is. If this is converted to safe navigation,
# `foo&.bar` can start returning `nil` as well as what the method
# returns.
#
# The default for `MaxChainLength` is `2`
# We have limited the cop to not register an offense for method chains
# that exceed this option is set.
#
# @example
#   # bad
#   foo.bar if foo
#   foo.bar.baz if foo
#   foo.bar(param1, param2) if foo
#   foo.bar { |e| e.something } if foo
#   foo.bar(param) { |e| e.something } if foo
#
#   foo.bar if !foo.nil?
#   foo.bar unless !foo
#   foo.bar unless foo.nil?
#
#   foo && foo.bar
#   foo && foo.bar.baz
#   foo && foo.bar(param1, param2)
#   foo && foo.bar { |e| e.something }
#   foo && foo.bar(param) { |e| e.something }
#
#   foo ? foo.bar : nil
#   foo.nil? ? nil : foo.bar
#   !foo.nil? ? foo.bar : nil
#   !foo ? nil : foo.bar
#
#   # good
#   foo&.bar
#   foo&.bar&.baz
#   foo&.bar(param1, param2)
#   foo&.bar { |e| e.something }
#   foo&.bar(param) { |e| e.something }
#   foo && foo.bar.baz.qux # method chain with more than 2 methods
#   foo && foo.nil? # method that `nil` responds to
#
#   # Method calls that do not use `.`
#   foo && foo < bar
#   foo < bar if foo
#
#   # When checking `foo&.empty?` in a conditional, `foo` being `nil` will actually
#   # do the opposite of what the author intends.
#   foo && foo.empty?
#
#   # This could start returning `nil` as well as the return of the method
#   foo.nil? || foo.bar
#   !foo || foo.bar
#
#   # Methods that are used on assignment, arithmetic operation or
#   # comparison should not be converted to use safe navigation
#   foo.baz = bar if foo
#   foo.baz + bar if foo
#   foo.bar > 2 if foo
#
# source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#84
class RuboCop::Cop::Style::SafeNavigation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::NilMethods
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  # if format: (if checked_variable body nil)
  # unless format: (if checked_variable nil body)
  #
  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#99
  def modifier_if_safe_navigation_candidate(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#125
  def not_nil_check?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#133
  def on_and(node); end

  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#127
  def on_if(node); end

  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#114
  def ternary_safe_navigation_candidate(param0 = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#307
  def add_safe_nav_to_all_methods_in_chain(corrector, start_method, method_chain); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#200
  def allowed_if_condition?(node); end

  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#154
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#299
  def begin_range(node, method_call); end

  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#261
  def chain_length(method_chain, method); end

  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#139
  def check_node(node); end

  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#181
  def comments(node); end

  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#303
  def end_range(node, method_call); end

  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#166
  def extract_body(node); end

  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#243
  def extract_common_parts(method_chain, checked_variable); end

  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#209
  def extract_parts(node); end

  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#233
  def extract_parts_from_and(node); end

  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#218
  def extract_parts_from_if(node); end

  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#251
  def find_matching_receiver_invocation(method_chain, checked_variable); end

  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#174
  def handle_comments(corrector, node, method_call); end

  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#320
  def max_chain_length; end

  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#204
  def method_call(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#295
  def method_called?(send_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#287
  def negated?(send_node); end

  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#187
  def relevant_comment_ranges(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#281
  def unsafe_method?(send_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#269
  def unsafe_method_used?(method_chain, method); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#150
  def use_var_only_in_unless_modifier?(node, variable); end
end

# source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#92
RuboCop::Cop::Style::SafeNavigation::LOGIC_JUMP_KEYWORDS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#90
RuboCop::Cop::Style::SafeNavigation::MSG = T.let(T.unsafe(nil), String)

# Identifies usages of `shuffle.first`,
# `shuffle.last`, and `shuffle[]` and change them to use
# `sample` instead.
#
# @example
#   # bad
#   [1, 2, 3].shuffle.first
#   [1, 2, 3].shuffle.first(2)
#   [1, 2, 3].shuffle.last
#   [2, 1, 3].shuffle.at(0)
#   [2, 1, 3].shuffle.slice(0)
#   [1, 2, 3].shuffle[2]
#   [1, 2, 3].shuffle[0, 2]    # sample(2) will do the same
#   [1, 2, 3].shuffle[0..2]    # sample(3) will do the same
#   [1, 2, 3].shuffle(random: Random.new).first
#
#   # good
#   [1, 2, 3].shuffle
#   [1, 2, 3].sample
#   [1, 2, 3].sample(3)
#   [1, 2, 3].shuffle[1, 3]    # sample(3) might return a longer Array
#   [1, 2, 3].shuffle[1..3]    # sample(3) might return a longer Array
#   [1, 2, 3].shuffle[foo, bar]
#   [1, 2, 3].shuffle(random: Random.new)
#
# source://rubocop//lib/rubocop/cop/style/sample.rb#30
class RuboCop::Cop::Style::Sample < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/sample.rb#41
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/style/sample.rb#37
  def sample_candidate?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/style/sample.rb#123
  def correction(shuffle_arg, method, method_args); end

  # source://rubocop//lib/rubocop/cop/style/sample.rb#139
  def extract_source(args); end

  # source://rubocop//lib/rubocop/cop/style/sample.rb#117
  def message(shuffle_arg, method, method_args, range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/sample.rb#58
  def offensive?(method, method_args); end

  # source://rubocop//lib/rubocop/cop/style/sample.rb#95
  def range_size(range_node); end

  # source://rubocop//lib/rubocop/cop/style/sample.rb#130
  def sample_arg(method, method_args); end

  # source://rubocop//lib/rubocop/cop/style/sample.rb#69
  def sample_size(method_args); end

  # source://rubocop//lib/rubocop/cop/style/sample.rb#78
  def sample_size_for_one_arg(arg); end

  # source://rubocop//lib/rubocop/cop/style/sample.rb#88
  def sample_size_for_two_args(first, second); end

  # source://rubocop//lib/rubocop/cop/style/sample.rb#111
  def source_range(shuffle_node, node); end
end

# source://rubocop//lib/rubocop/cop/style/sample.rb#33
RuboCop::Cop::Style::Sample::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/sample.rb#34
RuboCop::Cop::Style::Sample::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Looks for places where an subset of an Enumerable (array,
# range, set, etc.; see note below) is calculated based on a `Regexp`
# match, and suggests `grep` or `grep_v` instead.
#
# NOTE: Hashes do not behave as you may expect with `grep`, which
# means that `hash.grep` is not equivalent to `hash.select`. Although
# RuboCop is limited by static analysis, this cop attempts to avoid
# registering an offense when the receiver is a hash (hash literal,
# `Hash.new`, `Hash#[]`, or `to_h`/`to_hash`).
#
# NOTE: `grep` and `grep_v` were optimized when used without a block
# in Ruby 3.0, but may be slower in previous versions.
# See https://bugs.ruby-lang.org/issues/17030
#
# @example
#   # bad (select or find_all)
#   array.select { |x| x.match? /regexp/ }
#   array.select { |x| /regexp/.match?(x) }
#   array.select { |x| x =~ /regexp/ }
#   array.select { |x| /regexp/ =~ x }
#
#   # bad (reject)
#   array.reject { |x| x.match? /regexp/ }
#   array.reject { |x| /regexp/.match?(x) }
#   array.reject { |x| x =~ /regexp/ }
#   array.reject { |x| /regexp/ =~ x }
#
#   # good
#   array.grep(regexp)
#   array.grep_v(regexp)
#
# source://rubocop//lib/rubocop/cop/style/select_by_regexp.rb#45
class RuboCop::Cop::Style::SelectByRegexp < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/select_by_regexp.rb#79
  def calls_lvar?(param0 = T.unsafe(nil), param1); end

  # Returns true if a node appears to return a hash
  #
  # source://rubocop//lib/rubocop/cop/style/select_by_regexp.rb#65
  def creates_hash?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/select_by_regexp.rb#74
  def env_const?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/select_by_regexp.rb#87
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/style/select_by_regexp.rb#56
  def regexp_match?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/style/select_by_regexp.rb#122
  def extract_send_node(block_node); end

  # source://rubocop//lib/rubocop/cop/style/select_by_regexp.rb#135
  def find_regexp(node, block); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/select_by_regexp.rb#146
  def match_predicate_without_receiver?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/select_by_regexp.rb#131
  def opposite?(regexp_method_send_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/select_by_regexp.rb#102
  def receiver_allowed?(node); end

  # source://rubocop//lib/rubocop/cop/style/select_by_regexp.rb#108
  def register_offense(node, block_node, regexp, opposite); end
end

# source://rubocop//lib/rubocop/cop/style/select_by_regexp.rb#49
RuboCop::Cop::Style::SelectByRegexp::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/select_by_regexp.rb#52
RuboCop::Cop::Style::SelectByRegexp::OPPOSITE_REPLACEMENTS = T.let(T.unsafe(nil), Hash)

# source://rubocop//lib/rubocop/cop/style/select_by_regexp.rb#53
RuboCop::Cop::Style::SelectByRegexp::REGEXP_METHODS = T.let(T.unsafe(nil), Set)

# source://rubocop//lib/rubocop/cop/style/select_by_regexp.rb#51
RuboCop::Cop::Style::SelectByRegexp::REPLACEMENTS = T.let(T.unsafe(nil), Hash)

# source://rubocop//lib/rubocop/cop/style/select_by_regexp.rb#50
RuboCop::Cop::Style::SelectByRegexp::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Enforces the use the shorthand for self-assignment.
#
# @example
#
#   # bad
#   x = x + 1
#
#   # good
#   x += 1
#
# source://rubocop//lib/rubocop/cop/style/self_assignment.rb#15
class RuboCop::Cop::Style::SelfAssignment < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/self_assignment.rb#33
  def on_cvasgn(node); end

  # source://rubocop//lib/rubocop/cop/style/self_assignment.rb#29
  def on_ivasgn(node); end

  # source://rubocop//lib/rubocop/cop/style/self_assignment.rb#25
  def on_lvasgn(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/self_assignment.rb#94
  def apply_autocorrect(corrector, node, rhs, operator, new_rhs); end

  # source://rubocop//lib/rubocop/cop/style/self_assignment.rb#74
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/self_assignment.rb#89
  def autocorrect_boolean_node(corrector, node, rhs); end

  # source://rubocop//lib/rubocop/cop/style/self_assignment.rb#84
  def autocorrect_send_node(corrector, node, rhs); end

  # source://rubocop//lib/rubocop/cop/style/self_assignment.rb#39
  def check(node, var_type); end

  # source://rubocop//lib/rubocop/cop/style/self_assignment.rb#62
  def check_boolean_node(node, rhs, var_name, var_type); end

  # source://rubocop//lib/rubocop/cop/style/self_assignment.rb#50
  def check_send_node(node, rhs, var_name, var_type); end

  class << self
    # source://rubocop//lib/rubocop/cop/style/self_assignment.rb#21
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop//lib/rubocop/cop/style/self_assignment.rb#18
RuboCop::Cop::Style::SelfAssignment::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/self_assignment.rb#19
RuboCop::Cop::Style::SelfAssignment::OPS = T.let(T.unsafe(nil), Array)

# Checks for multiple expressions placed on the same line.
# It also checks for lines terminated with a semicolon.
#
# This cop has `AllowAsExpressionSeparator` configuration option.
# It allows `;` to separate several expressions on the same line.
#
# @example
#   # bad
#   foo = 1; bar = 2;
#   baz = 3;
#
#   # good
#   foo = 1
#   bar = 2
#   baz = 3
# @example AllowAsExpressionSeparator: false (default)
#   # bad
#   foo = 1; bar = 2
# @example AllowAsExpressionSeparator: true
#   # good
#   foo = 1; bar = 2
#
# source://rubocop//lib/rubocop/cop/style/semicolon.rb#29
class RuboCop::Cop::Style::Semicolon < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/semicolon.rb#45
  def on_begin(node); end

  # source://rubocop//lib/rubocop/cop/style/semicolon.rb#39
  def on_new_investigation; end

  private

  # source://rubocop//lib/rubocop/cop/style/semicolon.rb#64
  def check_for_line_terminator_or_opener; end

  # source://rubocop//lib/rubocop/cop/style/semicolon.rb#73
  def each_semicolon; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/semicolon.rb#102
  def exist_semicolon_after_left_curly_brace?(tokens); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/semicolon.rb#98
  def exist_semicolon_before_right_curly_brace?(tokens); end

  # source://rubocop//lib/rubocop/cop/style/semicolon.rb#126
  def expressions_per_line(exprs); end

  # source://rubocop//lib/rubocop/cop/style/semicolon.rb#140
  def find_range_node(token_before_semicolon); end

  # source://rubocop//lib/rubocop/cop/style/semicolon.rb#132
  def find_semicolon_positions(line); end

  # source://rubocop//lib/rubocop/cop/style/semicolon.rb#146
  def range_nodes; end

  # source://rubocop//lib/rubocop/cop/style/semicolon.rb#106
  def register_semicolon(line, column, after_expression, token_before_semicolon = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/semicolon.rb#86
  def semicolon_position(tokens); end

  # source://rubocop//lib/rubocop/cop/style/semicolon.rb#82
  def tokens_for_lines; end

  class << self
    # source://rubocop//lib/rubocop/cop/style/semicolon.rb#35
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop//lib/rubocop/cop/style/semicolon.rb#33
RuboCop::Cop::Style::Semicolon::MSG = T.let(T.unsafe(nil), String)

# Checks for the use of the send method.
#
# @example
#   # bad
#   Foo.send(:bar)
#   quuz.send(:fred)
#
#   # good
#   Foo.__send__(:bar)
#   quuz.public_send(:fred)
#
# source://rubocop//lib/rubocop/cop/style/send.rb#16
class RuboCop::Cop::Style::Send < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/style/send.rb#20
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/style/send.rb#20
  def on_send(node); end
end

# source://rubocop//lib/rubocop/cop/style/send.rb#17
RuboCop::Cop::Style::Send::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/send.rb#18
RuboCop::Cop::Style::Send::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for uses of `fail` and `raise`.
#
# @example EnforcedStyle: only_raise (default)
#   # The `only_raise` style enforces the sole use of `raise`.
#   # bad
#   begin
#   fail
#   rescue Exception
#   # handle it
#   end
#
#   def watch_out
#   fail
#   rescue Exception
#   # handle it
#   end
#
#   Kernel.fail
#
#   # good
#   begin
#   raise
#   rescue Exception
#   # handle it
#   end
#
#   def watch_out
#   raise
#   rescue Exception
#   # handle it
#   end
#
#   Kernel.raise
# @example EnforcedStyle: only_fail
#   # The `only_fail` style enforces the sole use of `fail`.
#   # bad
#   begin
#   raise
#   rescue Exception
#   # handle it
#   end
#
#   def watch_out
#   raise
#   rescue Exception
#   # handle it
#   end
#
#   Kernel.raise
#
#   # good
#   begin
#   fail
#   rescue Exception
#   # handle it
#   end
#
#   def watch_out
#   fail
#   rescue Exception
#   # handle it
#   end
#
#   Kernel.fail
# @example EnforcedStyle: semantic
#   # The `semantic` style enforces the use of `fail` to signal an
#   # exception, then will use `raise` to trigger an offense after
#   # it has been rescued.
#   # bad
#   begin
#   raise
#   rescue Exception
#   # handle it
#   end
#
#   def watch_out
#   # Error thrown
#   rescue Exception
#   fail
#   end
#
#   Kernel.fail
#   Kernel.raise
#
#   # good
#   begin
#   fail
#   rescue Exception
#   # handle it
#   end
#
#   def watch_out
#   fail
#   rescue Exception
#   raise 'Preferably with descriptive message'
#   end
#
#   explicit_receiver.fail
#   explicit_receiver.raise
#
# source://rubocop//lib/rubocop/cop/style/signal_exception.rb#107
class RuboCop::Cop::Style::SignalException < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/signal_exception.rb#120
  def custom_fail_methods(param0); end

  # source://rubocop//lib/rubocop/cop/style/signal_exception.rb#117
  def kernel_call?(param0 = T.unsafe(nil), param1); end

  # source://rubocop//lib/rubocop/cop/style/signal_exception.rb#122
  def on_rescue(node); end

  # source://rubocop//lib/rubocop/cop/style/signal_exception.rb#134
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/signal_exception.rb#206
  def allow(method_name, node); end

  # source://rubocop//lib/rubocop/cop/style/signal_exception.rb#188
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/signal_exception.rb#167
  def check_scope(method_name, node); end

  # source://rubocop//lib/rubocop/cop/style/signal_exception.rb#180
  def check_send(method_name, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/signal_exception.rb#200
  def command_or_kernel_call?(name, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/signal_exception.rb#149
  def custom_fail_defined?; end

  # source://rubocop//lib/rubocop/cop/style/signal_exception.rb#210
  def each_command_or_kernel_call(method_name, node); end

  # source://rubocop//lib/rubocop/cop/style/signal_exception.rb#156
  def message(method_name); end
end

# source://rubocop//lib/rubocop/cop/style/signal_exception.rb#111
RuboCop::Cop::Style::SignalException::FAIL_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/signal_exception.rb#112
RuboCop::Cop::Style::SignalException::RAISE_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/signal_exception.rb#114
RuboCop::Cop::Style::SignalException::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Sometimes using dig method ends up with just a single
# argument. In such cases, dig should be replaced with [].
#
# @example
#   # bad
#   { key: 'value' }.dig(:key)
#   [1, 2, 3].dig(0)
#
#   # good
#   { key: 'value' }[:key]
#   [1, 2, 3][0]
#
#   # good
#   { key1: { key2: 'value' } }.dig(:key1, :key2)
#   [1, [2, [3]]].dig(1, 1)
#
#   # good
#   keys = %i[key1 key2]
#   { key1: { key2: 'value' } }.dig(*keys)
#
# source://rubocop//lib/rubocop/cop/style/single_argument_dig.rb#31
class RuboCop::Cop::Style::SingleArgumentDig < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/single_argument_dig.rb#42
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/style/single_argument_dig.rb#38
  def single_argument_dig?(param0 = T.unsafe(nil)); end
end

# source://rubocop//lib/rubocop/cop/style/single_argument_dig.rb#34
RuboCop::Cop::Style::SingleArgumentDig::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/single_argument_dig.rb#35
RuboCop::Cop::Style::SingleArgumentDig::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks whether the block parameters of a single-line
# method accepting a block match the names specified via configuration.
#
# For instance one can configure `reduce`(`inject`) to use |a, e| as
# parameters.
#
# Configuration option: Methods
# Should be set to use this cop. Array of hashes, where each key is the
# method name and value - array of argument names.
#
# @example Methods: [{reduce: %w[a b]}]
#   # bad
#   foo.reduce { |c, d| c + d }
#   foo.reduce { |_, _d| 1 }
#
#   # good
#   foo.reduce { |a, b| a + b }
#   foo.reduce { |a, _b| a }
#   foo.reduce { |a, (id, _)| a + id }
#   foo.reduce { true }
#
#   # good
#   foo.reduce do |c, d|
#   c + d
#   end
#
# source://rubocop//lib/rubocop/cop/style/single_line_block_params.rb#31
class RuboCop::Cop::Style::SingleLineBlockParams < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/single_line_block_params.rb#36
  def on_block(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/single_line_block_params.rb#105
  def args_match?(method_name, args); end

  # source://rubocop//lib/rubocop/cop/style/single_line_block_params.rb#69
  def autocorrect(corrector, node, preferred_block_arguments, joined_block_arguments); end

  # source://rubocop//lib/rubocop/cop/style/single_line_block_params.rb#57
  def build_preferred_arguments_map(node, preferred_arguments); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/single_line_block_params.rb#79
  def eligible_arguments?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/single_line_block_params.rb#83
  def eligible_method?(node); end

  # source://rubocop//lib/rubocop/cop/style/single_line_block_params.rb#95
  def method_name(method); end

  # source://rubocop//lib/rubocop/cop/style/single_line_block_params.rb#91
  def method_names; end

  # source://rubocop//lib/rubocop/cop/style/single_line_block_params.rb#87
  def methods; end

  # source://rubocop//lib/rubocop/cop/style/single_line_block_params.rb#99
  def target_args(method_name); end
end

# source://rubocop//lib/rubocop/cop/style/single_line_block_params.rb#34
RuboCop::Cop::Style::SingleLineBlockParams::MSG = T.let(T.unsafe(nil), String)

# Checks for single-line method definitions that contain a body.
# It will accept single-line methods with no body.
#
# Endless methods added in Ruby 3.0 are also accepted by this cop.
#
# If `Style/EndlessMethod` is enabled with `EnforcedStyle: allow_single_line` or
# `allow_always`, single-line methods will be autocorrected to endless
# methods if there is only one statement in the body.
#
# @example
#   # bad
#   def some_method; body end
#   def link_to(url); {:name => url}; end
#   def @table.columns; super; end
#
#   # good
#   def self.resource_class=(klass); end
#   def @table.columns; end
#   def some_method() = body
# @example AllowIfMethodIsEmpty: true (default)
#   # good
#   def no_op; end
# @example AllowIfMethodIsEmpty: false
#   # bad
#   def no_op; end
#
# source://rubocop//lib/rubocop/cop/style/single_line_methods.rb#34
class RuboCop::Cop::Style::SingleLineMethods < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/single_line_methods.rb#41
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/style/single_line_methods.rb#41
  def on_defs(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/single_line_methods.rb#60
  def allow_empty?; end

  # source://rubocop//lib/rubocop/cop/style/single_line_methods.rb#52
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/single_line_methods.rb#97
  def break_line_before(corrector, node, range, indent_steps: T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/single_line_methods.rb#88
  def correct_to_endless(corrector, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/single_line_methods.rb#64
  def correct_to_endless?(body_node); end

  # source://rubocop//lib/rubocop/cop/style/single_line_methods.rb#74
  def correct_to_multiline(corrector, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/single_line_methods.rb#136
  def disallow_endless_method_style?; end

  # source://rubocop//lib/rubocop/cop/style/single_line_methods.rb#104
  def each_part(body); end

  # source://rubocop//lib/rubocop/cop/style/single_line_methods.rb#121
  def method_body_source(method_body); end

  # source://rubocop//lib/rubocop/cop/style/single_line_methods.rb#114
  def move_comment(node, corrector); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/single_line_methods.rb#132
  def require_parentheses?(method_body); end
end

# source://rubocop//lib/rubocop/cop/style/single_line_methods.rb#38
RuboCop::Cop::Style::SingleLineMethods::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/single_line_methods.rb#39
RuboCop::Cop::Style::SingleLineMethods::NOT_SUPPORTED_ENDLESS_METHOD_BODY_TYPES = T.let(T.unsafe(nil), Array)

# Checks that arrays are sliced with endless ranges instead of
# `ary[start..-1]` on Ruby 2.6+.
#
# @example
#   # bad
#   items[1..-1]
#
#   # good
#   items[1..]
#
# source://rubocop//lib/rubocop/cop/style/slicing_with_range.rb#28
class RuboCop::Cop::Style::SlicingWithRange < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop//lib/rubocop/cop/style/slicing_with_range.rb#40
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/style/slicing_with_range.rb#38
  def range_till_minus_one?(param0 = T.unsafe(nil)); end
end

# source://rubocop//lib/rubocop/cop/style/slicing_with_range.rb#34
RuboCop::Cop::Style::SlicingWithRange::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/slicing_with_range.rb#35
RuboCop::Cop::Style::SlicingWithRange::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# If the branch of a conditional consists solely of a conditional node,
# its conditions can be combined with the conditions of the outer branch.
# This helps to keep the nesting level from getting too deep.
#
# @example
#   # bad
#   if condition_a
#   if condition_b
#   do_something
#   end
#   end
#
#   # bad
#   if condition_b
#   do_something
#   end if condition_a
#
#   # good
#   if condition_a && condition_b
#   do_something
#   end
# @example AllowModifier: false (default)
#   # bad
#   if condition_a
#   do_something if condition_b
#   end
#
#   # bad
#   if condition_b
#   do_something
#   end if condition_a
# @example AllowModifier: true
#   # good
#   if condition_a
#   do_something if condition_b
#   end
#
#   # good
#   if condition_b
#   do_something
#   end if condition_a
#
# source://rubocop//lib/rubocop/cop/style/sole_nested_conditional.rb#49
class RuboCop::Cop::Style::SoleNestedConditional < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/sole_nested_conditional.rb#59
  def on_if(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/sole_nested_conditional.rb#238
  def allow_modifier?; end

  # source://rubocop//lib/rubocop/cop/style/sole_nested_conditional.rb#223
  def arguments_range(node); end

  # source://rubocop//lib/rubocop/cop/style/sole_nested_conditional.rb#81
  def assigned_variables(condition); end

  # source://rubocop//lib/rubocop/cop/style/sole_nested_conditional.rb#98
  def autocorrect(corrector, node, if_branch); end

  # source://rubocop//lib/rubocop/cop/style/sole_nested_conditional.rb#110
  def autocorrect_outer_condition_basic(corrector, node, if_branch); end

  # source://rubocop//lib/rubocop/cop/style/sole_nested_conditional.rb#125
  def autocorrect_outer_condition_modify_form(corrector, node, if_branch); end

  # source://rubocop//lib/rubocop/cop/style/sole_nested_conditional.rb#145
  def correct_for_basic_condition_style(corrector, node, if_branch, and_operator); end

  # source://rubocop//lib/rubocop/cop/style/sole_nested_conditional.rb#175
  def correct_for_comment(corrector, node, if_branch); end

  # source://rubocop//lib/rubocop/cop/style/sole_nested_conditional.rb#136
  def correct_for_guard_condition_style(corrector, outer_condition, if_branch, and_operator); end

  # source://rubocop//lib/rubocop/cop/style/sole_nested_conditional.rb#165
  def correct_for_outer_condition_modify_form_style(corrector, node, if_branch); end

  # source://rubocop//lib/rubocop/cop/style/sole_nested_conditional.rb#130
  def correct_from_unless_to_if(corrector, node, is_modify_form: T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/sole_nested_conditional.rb#182
  def correct_outer_condition(corrector, condition); end

  # source://rubocop//lib/rubocop/cop/style/sole_nested_conditional.rb#193
  def insert_bang(corrector, node, is_modify_form); end

  # source://rubocop//lib/rubocop/cop/style/sole_nested_conditional.rb#206
  def insert_bang_for_and(corrector, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/sole_nested_conditional.rb#89
  def offending_branch?(node, branch); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/sole_nested_conditional.rb#242
  def outer_condition_modify_form?(node, if_branch); end

  # source://rubocop//lib/rubocop/cop/style/sole_nested_conditional.rb#234
  def replace_condition(condition); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/sole_nested_conditional.rb#218
  def require_parentheses?(condition); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/sole_nested_conditional.rb#74
  def use_variable_assignment_in_condition?(condition, if_branch); end

  # source://rubocop//lib/rubocop/cop/style/sole_nested_conditional.rb#155
  def wrap_condition(corrector, condition); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/sole_nested_conditional.rb#229
  def wrap_condition?(node); end

  class << self
    # source://rubocop//lib/rubocop/cop/style/sole_nested_conditional.rb#55
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop//lib/rubocop/cop/style/sole_nested_conditional.rb#53
RuboCop::Cop::Style::SoleNestedConditional::MSG = T.let(T.unsafe(nil), String)

# This cop looks for uses of Perl-style global variables.
# Correcting to global variables in the 'English' library
# will add a require statement to the top of the file if
# enabled by RequireEnglish config.
#
# Like `use_perl_names` but allows builtin global vars.
#
#   # good
#   puts $LOAD_PATH
#   puts $LOADED_FEATURES
#   puts $PROGRAM_NAME
#   puts ARGV
#   puts $:
#   puts $"
#   puts $0
#   puts $!
#   puts $@
#   puts $;
#   puts $,
#   puts $/
#   puts $\
#   puts $.
#   puts $_
#   puts $>
#   puts $<
#   puts $$
#   puts $?
#   puts $~
#   puts $=
#   puts $*
#
# @example EnforcedStyle: use_english_names (default)
#   # good
#   require 'English' # or this could be in another file.
#
#   puts $LOAD_PATH
#   puts $LOADED_FEATURES
#   puts $PROGRAM_NAME
#   puts $ERROR_INFO
#   puts $ERROR_POSITION
#   puts $FIELD_SEPARATOR # or $FS
#   puts $OUTPUT_FIELD_SEPARATOR # or $OFS
#   puts $INPUT_RECORD_SEPARATOR # or $RS
#   puts $OUTPUT_RECORD_SEPARATOR # or $ORS
#   puts $INPUT_LINE_NUMBER # or $NR
#   puts $LAST_READ_LINE
#   puts $DEFAULT_OUTPUT
#   puts $DEFAULT_INPUT
#   puts $PROCESS_ID # or $PID
#   puts $CHILD_STATUS
#   puts $LAST_MATCH_INFO
#   puts $IGNORECASE
#   puts $ARGV # or ARGV
# @example EnforcedStyle: use_perl_names
#   # good
#   puts $:
#   puts $"
#   puts $0
#   puts $!
#   puts $@
#   puts $;
#   puts $,
#   puts $/
#   puts $\
#   puts $.
#   puts $_
#   puts $>
#   puts $<
#   puts $$
#   puts $?
#   puts $~
#   puts $=
#   puts $*
# @example EnforcedStyle: use_builtin_english_names
#
# source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#88
class RuboCop::Cop::Style::SpecialGlobalVars < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::RequireLibrary
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#177
  def autocorrect(corrector, node, global_var); end

  # source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#169
  def message(global_var); end

  # source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#153
  def on_gvar(node); end

  # source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#148
  def on_new_investigation; end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#248
  def add_require_english?; end

  # source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#242
  def english_name_replacement(preferred_name, node); end

  # source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#191
  def format_english_message(global_var); end

  # For now, we assume that lists are 2 items or less. Easy grammar!
  #
  # source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#213
  def format_list(items); end

  # source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#199
  def format_message(english, regular, global); end

  # source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#236
  def matching_styles(global); end

  # source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#228
  def preferred_names(global); end

  # source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#217
  def replacement(node, global_var); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#252
  def should_require_english?(global_var); end
end

# source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#129
RuboCop::Cop::Style::SpecialGlobalVars::BUILTIN_VARS = T.let(T.unsafe(nil), Hash)

# source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#101
RuboCop::Cop::Style::SpecialGlobalVars::ENGLISH_VARS = T.let(T.unsafe(nil), Hash)

# source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#146
RuboCop::Cop::Style::SpecialGlobalVars::LIBRARY_NAME = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#94
RuboCop::Cop::Style::SpecialGlobalVars::MSG_BOTH = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#97
RuboCop::Cop::Style::SpecialGlobalVars::MSG_ENGLISH = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#99
RuboCop::Cop::Style::SpecialGlobalVars::MSG_REGULAR = T.let(T.unsafe(nil), String)

# Anything *not* in this set is provided by the English library.
#
# source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#123
RuboCop::Cop::Style::SpecialGlobalVars::NON_ENGLISH_VARS = T.let(T.unsafe(nil), Set)

# source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#125
RuboCop::Cop::Style::SpecialGlobalVars::PERL_VARS = T.let(T.unsafe(nil), Hash)

# source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#140
RuboCop::Cop::Style::SpecialGlobalVars::STYLE_VARS_MAP = T.let(T.unsafe(nil), Hash)

# Check for parentheses around stabby lambda arguments.
# There are two different styles. Defaults to `require_parentheses`.
#
# @example EnforcedStyle: require_parentheses (default)
#   # bad
#   ->a,b,c { a + b + c }
#
#   # good
#   ->(a,b,c) { a + b + c}
# @example EnforcedStyle: require_no_parentheses
#   # bad
#   ->(a,b,c) { a + b + c }
#
#   # good
#   ->a,b,c { a + b + c}
#
# source://rubocop//lib/rubocop/cop/style/stabby_lambda_parentheses.rb#22
class RuboCop::Cop::Style::StabbyLambdaParentheses < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/stabby_lambda_parentheses.rb#28
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/stabby_lambda_parentheses.rb#54
  def message(_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/stabby_lambda_parentheses.rb#46
  def missing_parentheses?(node); end

  # source://rubocop//lib/rubocop/cop/style/stabby_lambda_parentheses.rb#58
  def missing_parentheses_corrector(corrector, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/stabby_lambda_parentheses.rb#73
  def parentheses?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/stabby_lambda_parentheses.rb#50
  def redundant_parentheses?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/stabby_lambda_parentheses.rb#69
  def stabby_lambda_with_args?(node); end

  # source://rubocop//lib/rubocop/cop/style/stabby_lambda_parentheses.rb#62
  def unwanted_parentheses_corrector(corrector, node); end
end

# source://rubocop//lib/rubocop/cop/style/stabby_lambda_parentheses.rb#27
RuboCop::Cop::Style::StabbyLambdaParentheses::MSG_NO_REQUIRE = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/stabby_lambda_parentheses.rb#26
RuboCop::Cop::Style::StabbyLambdaParentheses::MSG_REQUIRE = T.let(T.unsafe(nil), String)

# Checks for places where classes with only class methods can be
# replaced with a module. Classes should be used only when it makes sense to create
# instances out of them.
#
# @example
#   # bad
#   class SomeClass
#   def self.some_method
#   # body omitted
#   end
#
#   def self.some_other_method
#   # body omitted
#   end
#   end
#
#   # good
#   module SomeModule
#   module_function
#
#   def some_method
#   # body omitted
#   end
#
#   def some_other_method
#   # body omitted
#   end
#   end
#
#   # good - has instance method
#   class SomeClass
#   def instance_method; end
#   def self.class_method; end
#   end
#
# source://rubocop//lib/rubocop/cop/style/static_class.rb#46
class RuboCop::Cop::Style::StaticClass < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::VisibilityHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/static_class.rb#53
  def on_class(class_node); end

  private

  # source://rubocop//lib/rubocop/cop/style/static_class.rb#64
  def autocorrect(corrector, class_node); end

  # source://rubocop//lib/rubocop/cop/style/static_class.rb#77
  def autocorrect_def(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/static_class.rb#83
  def autocorrect_sclass(corrector, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/static_class.rb#90
  def class_convertible_to_module?(class_node); end

  # source://rubocop//lib/rubocop/cop/style/static_class.rb#114
  def class_elements(class_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/static_class.rb#102
  def extend_call?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/static_class.rb#106
  def sclass_convertible_to_module?(node); end
end

# source://rubocop//lib/rubocop/cop/style/static_class.rb#51
RuboCop::Cop::Style::StaticClass::MSG = T.let(T.unsafe(nil), String)

# Identifies places where `$stderr.puts` can be replaced by
# `warn`. The latter has the advantage of easily being disabled by,
# the `-W0` interpreter flag or setting `$VERBOSE` to `nil`.
#
# @example
#   # bad
#   $stderr.puts('hello')
#
#   # good
#   warn('hello')
#
# source://rubocop//lib/rubocop/cop/style/stderr_puts.rb#17
class RuboCop::Cop::Style::StderrPuts < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/stderr_puts.rb#32
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/style/stderr_puts.rb#25
  def stderr_puts?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/style/stderr_puts.rb#43
  def message(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/stderr_puts.rb#47
  def stderr_gvar?(sym); end

  # source://rubocop//lib/rubocop/cop/style/stderr_puts.rb#51
  def stderr_puts_range(send); end
end

# source://rubocop//lib/rubocop/cop/style/stderr_puts.rb#21
RuboCop::Cop::Style::StderrPuts::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/stderr_puts.rb#22
RuboCop::Cop::Style::StderrPuts::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for uses of `String#split` with empty string or regexp literal argument.
#
# @example
#   # bad
#   string.split(//)
#   string.split('')
#
#   # good
#   string.chars
#
# source://rubocop//lib/rubocop/cop/style/string_chars.rb#21
class RuboCop::Cop::Style::StringChars < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/string_chars.rb#29
  def on_send(node); end
end

# source://rubocop//lib/rubocop/cop/style/string_chars.rb#27
RuboCop::Cop::Style::StringChars::BAD_ARGUMENTS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/string_chars.rb#25
RuboCop::Cop::Style::StringChars::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/string_chars.rb#26
RuboCop::Cop::Style::StringChars::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for places where string concatenation
# can be replaced with string interpolation.
#
# The cop can autocorrect simple cases but will skip autocorrecting
# more complex cases where the resulting code would be harder to read.
# In those cases, it might be useful to extract statements to local
# variables or methods which you can then interpolate in a string.
#
# NOTE: When concatenation between two strings is broken over multiple
# lines, this cop does not register an offense; instead,
# `Style/LineEndConcatenation` will pick up the offense if enabled.
#
# Two modes are supported:
# 1. `aggressive` style checks and corrects all occurrences of `+` where
# either the left or right side of `+` is a string literal.
# 2. `conservative` style on the other hand, checks and corrects only if
# left side (receiver of `+` method call) is a string literal.
# This is useful when the receiver is some expression that returns string like `Pathname`
# instead of a string literal.
#
# @example Mode: aggressive (default)
#   # bad
#   email_with_name = user.name + ' <' + user.email + '>'
#   Pathname.new('/') + 'test'
#
#   # good
#   email_with_name = "#{user.name} <#{user.email}>"
#   email_with_name = format('%s <%s>', user.name, user.email)
#   "#{Pathname.new('/')}test"
#
#   # accepted, line-end concatenation
#   name = 'First' +
#   'Last'
# @example Mode: conservative
#   # bad
#   'Hello' + user.name
#
#   # good
#   "Hello #{user.name}"
#   user.name + '!!'
#   Pathname.new('/') + 'test'
#
# source://rubocop//lib/rubocop/cop/style/string_concatenation.rb#53
class RuboCop::Cop::Style::StringConcatenation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/string_concatenation.rb#69
  def on_new_investigation; end

  # source://rubocop//lib/rubocop/cop/style/string_concatenation.rb#73
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/style/string_concatenation.rb#62
  def string_concatenation?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/style/string_concatenation.rb#116
  def collect_parts(node, parts = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/string_concatenation.rb#141
  def corrected_ancestor?(node); end

  # source://rubocop//lib/rubocop/cop/style/string_concatenation.rb#108
  def find_topmost_plus_node(node); end

  # source://rubocop//lib/rubocop/cop/style/string_concatenation.rb#162
  def handle_quotes(parts); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/string_concatenation.rb#135
  def heredoc?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/string_concatenation.rb#98
  def line_end_concatenation?(node); end

  # source://rubocop//lib/rubocop/cop/style/string_concatenation.rb#172
  def mode; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/string_concatenation.rb#127
  def plus_node?(node); end

  # source://rubocop//lib/rubocop/cop/style/string_concatenation.rb#86
  def register_offense(topmost_plus_node, parts); end

  # source://rubocop//lib/rubocop/cop/style/string_concatenation.rb#145
  def replacement(parts); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/string_concatenation.rb#168
  def single_quoted?(str_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/string_concatenation.rb#131
  def uncorrectable?(part); end
end

# source://rubocop//lib/rubocop/cop/style/string_concatenation.rb#58
RuboCop::Cop::Style::StringConcatenation::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/string_concatenation.rb#59
RuboCop::Cop::Style::StringConcatenation::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for the use of strings as keys in hashes. The use of
# symbols is preferred instead.
#
# @example
#   # bad
#   { 'one' => 1, 'two' => 2, 'three' => 3 }
#
#   # good
#   { one: 1, two: 2, three: 3 }
#
# source://rubocop//lib/rubocop/cop/style/string_hash_keys.rb#19
class RuboCop::Cop::Style::StringHashKeys < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/string_hash_keys.rb#42
  def on_pair(node); end

  # source://rubocop//lib/rubocop/cop/style/string_hash_keys.rb#30
  def receive_environments_method?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/string_hash_keys.rb#25
  def string_hash_key?(param0 = T.unsafe(nil)); end
end

# source://rubocop//lib/rubocop/cop/style/string_hash_keys.rb#22
RuboCop::Cop::Style::StringHashKeys::MSG = T.let(T.unsafe(nil), String)

# Checks if uses of quotes match the configured preference.
#
# @example EnforcedStyle: single_quotes (default)
#   # bad
#   "No special symbols"
#   "No string interpolation"
#   "Just text"
#
#   # good
#   'No special symbols'
#   'No string interpolation'
#   'Just text'
#   "Wait! What's #{this}!"
# @example EnforcedStyle: double_quotes
#   # bad
#   'Just some text'
#   'No special chars or interpolation'
#
#   # good
#   "Just some text"
#   "No special chars or interpolation"
#   "Every string in #{project} uses double_quotes"
#
# source://rubocop//lib/rubocop/cop/style/string_literals.rb#29
class RuboCop::Cop::Style::StringLiterals < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::StringLiteralsHelp
  include ::RuboCop::Cop::StringHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/string_literals.rb#37
  def on_dstr(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/string_literals.rb#123
  def accept_child_double_quotes?(nodes); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/string_literals.rb#71
  def all_string_literals?(nodes); end

  # source://rubocop//lib/rubocop/cop/style/string_literals.rb#61
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/string_literals.rb#105
  def check_multiline_quote_style(node, quote); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/string_literals.rb#101
  def consistent_multiline?; end

  # source://rubocop//lib/rubocop/cop/style/string_literals.rb#75
  def detect_quote_styles(node); end

  # source://rubocop//lib/rubocop/cop/style/string_literals.rb#87
  def message(_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/string_literals.rb#97
  def offense?(node); end

  # source://rubocop//lib/rubocop/cop/style/string_literals.rb#65
  def register_offense(node, message: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/string_literals.rb#119
  def unexpected_double_quotes?(quote); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/string_literals.rb#115
  def unexpected_single_quotes?(quote); end
end

# source://rubocop//lib/rubocop/cop/style/string_literals.rb#35
RuboCop::Cop::Style::StringLiterals::MSG_INCONSISTENT = T.let(T.unsafe(nil), String)

# Checks that quotes inside the string interpolation
# match the configured preference.
#
# @example EnforcedStyle: single_quotes (default)
#   # bad
#   result = "Tests #{success ? "PASS" : "FAIL"}"
#
#   # good
#   result = "Tests #{success ? 'PASS' : 'FAIL'}"
# @example EnforcedStyle: double_quotes
#   # bad
#   result = "Tests #{success ? 'PASS' : 'FAIL'}"
#
#   # good
#   result = "Tests #{success ? "PASS" : "FAIL"}"
#
# source://rubocop//lib/rubocop/cop/style/string_literals_in_interpolation.rb#22
class RuboCop::Cop::Style::StringLiteralsInInterpolation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::StringLiteralsHelp
  include ::RuboCop::Cop::StringHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/string_literals_in_interpolation.rb#28
  def autocorrect(corrector, node); end

  private

  # source://rubocop//lib/rubocop/cop/style/string_literals_in_interpolation.rb#34
  def message(_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/string_literals_in_interpolation.rb#41
  def offense?(node); end
end

# Enforces the use of consistent method names
# from the String class.
#
# @example
#   # bad
#   'name'.intern
#   'var'.unfavored_method
#
#   # good
#   'name'.to_sym
#   'var'.preferred_method
#
# source://rubocop//lib/rubocop/cop/style/string_methods.rb#17
class RuboCop::Cop::Style::StringMethods < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::MethodPreference
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/string_methods.rb#23
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/style/string_methods.rb#23
  def on_send(node); end
end

# source://rubocop//lib/rubocop/cop/style/string_methods.rb#21
RuboCop::Cop::Style::StringMethods::MSG = T.let(T.unsafe(nil), String)

# Identifies places where `lstrip.rstrip` can be replaced by
# `strip`.
#
# @example
#   # bad
#   'abc'.lstrip.rstrip
#   'abc'.rstrip.lstrip
#
#   # good
#   'abc'.strip
#
# source://rubocop//lib/rubocop/cop/style/strip.rb#16
class RuboCop::Cop::Style::Strip < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/strip.rb#24
  def lstrip_rstrip(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/strip.rb#29
  def on_send(node); end
end

# source://rubocop//lib/rubocop/cop/style/strip.rb#20
RuboCop::Cop::Style::Strip::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/strip.rb#21
RuboCop::Cop::Style::Strip::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for inheritance from Struct.new.
#
# @example
#   # bad
#   class Person < Struct.new(:first_name, :last_name)
#   def age
#   42
#   end
#   end
#
#   # good
#   Person = Struct.new(:first_name, :last_name) do
#   def age
#   42
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/style/struct_inheritance.rb#26
class RuboCop::Cop::Style::StructInheritance < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/struct_inheritance.rb#33
  def on_class(node); end

  # source://rubocop//lib/rubocop/cop/style/struct_inheritance.rb#45
  def struct_constructor?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/style/struct_inheritance.rb#52
  def correct_parent(parent, corrector); end

  # source://rubocop//lib/rubocop/cop/style/struct_inheritance.rb#62
  def range_for_empty_class_body(class_node, struct_new); end
end

# source://rubocop//lib/rubocop/cop/style/struct_inheritance.rb#30
RuboCop::Cop::Style::StructInheritance::MSG = T.let(T.unsafe(nil), String)

# Enforces the use of shorthand-style swapping of 2 variables.
#
# @example
#   # bad
#   tmp = x
#   x = y
#   y = tmp
#
#   # good
#   x, y = y, x
#
# source://rubocop//lib/rubocop/cop/style/swap_values.rb#21
class RuboCop::Cop::Style::SwapValues < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/swap_values.rb#30
  def on_asgn(node); end

  # source://rubocop//lib/rubocop/cop/style/swap_values.rb#30
  def on_casgn(node); end

  # source://rubocop//lib/rubocop/cop/style/swap_values.rb#30
  def on_cvasgn(node); end

  # source://rubocop//lib/rubocop/cop/style/swap_values.rb#30
  def on_gvasgn(node); end

  # source://rubocop//lib/rubocop/cop/style/swap_values.rb#30
  def on_ivasgn(node); end

  # source://rubocop//lib/rubocop/cop/style/swap_values.rb#30
  def on_lvasgn(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/swap_values.rb#47
  def allowed_assignment?(node); end

  # source://rubocop//lib/rubocop/cop/style/swap_values.rb#104
  def correction_range(tmp_assign, y_assign); end

  # source://rubocop//lib/rubocop/cop/style/swap_values.rb#81
  def lhs(node); end

  # source://rubocop//lib/rubocop/cop/style/swap_values.rb#66
  def message(x_assign, y_assign); end

  # source://rubocop//lib/rubocop/cop/style/swap_values.rb#75
  def replacement(x_assign); end

  # source://rubocop//lib/rubocop/cop/style/swap_values.rb#95
  def rhs(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/swap_values.rb#60
  def simple_assignment?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/swap_values.rb#51
  def swapping_values?(tmp_assign, x_assign, y_assign); end
end

# source://rubocop//lib/rubocop/cop/style/swap_values.rb#25
RuboCop::Cop::Style::SwapValues::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/swap_values.rb#28
RuboCop::Cop::Style::SwapValues::SIMPLE_ASSIGNMENT_TYPES = T.let(T.unsafe(nil), Set)

# Checks for array literals made up of symbols that are not
# using the %i() syntax.
#
# Alternatively, it checks for symbol arrays using the %i() syntax on
# projects which do not want to use that syntax, perhaps because they
# support a version of Ruby lower than 2.0.
#
# Configuration option: MinSize
# If set, arrays with fewer elements than this value will not trigger the
# cop. For example, a `MinSize` of `3` will not enforce a style on an
# array of 2 or fewer elements.
#
# @example EnforcedStyle: percent (default)
#   # good
#   %i[foo bar baz]
#
#   # bad
#   [:foo, :bar, :baz]
# @example EnforcedStyle: brackets
#   # good
#   [:foo, :bar, :baz]
#
#   # bad
#   %i[foo bar baz]
#
# source://rubocop//lib/rubocop/cop/style/symbol_array.rb#31
class RuboCop::Cop::Style::SymbolArray < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ArrayMinSize
  include ::RuboCop::Cop::ArraySyntax
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::PercentArray
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop//lib/rubocop/cop/style/symbol_array.rb#48
  def on_array(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/symbol_array.rb#67
  def build_bracketed_array(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/symbol_array.rb#90
  def symbol_without_quote?(string); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/symbol_array.rb#60
  def symbols_contain_spaces?(node); end

  # source://rubocop//lib/rubocop/cop/style/symbol_array.rb#82
  def to_symbol_literal(string); end

  class << self
    # Returns the value of attribute largest_brackets.
    #
    # source://rubocop//lib/rubocop/cop/style/symbol_array.rb#45
    def largest_brackets; end

    # Sets the attribute largest_brackets
    #
    # @param value the value to set the attribute largest_brackets to.
    #
    # source://rubocop//lib/rubocop/cop/style/symbol_array.rb#45
    def largest_brackets=(_arg0); end
  end
end

# source://rubocop//lib/rubocop/cop/style/symbol_array.rb#42
RuboCop::Cop::Style::SymbolArray::ARRAY_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/symbol_array.rb#41
RuboCop::Cop::Style::SymbolArray::PERCENT_MSG = T.let(T.unsafe(nil), String)

# Checks symbol literal syntax.
#
# @example
#
#   # bad
#   :"symbol"
#
#   # good
#   :symbol
#
# source://rubocop//lib/rubocop/cop/style/symbol_literal.rb#15
class RuboCop::Cop::Style::SymbolLiteral < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/symbol_literal.rb#20
  def on_sym(node); end
end

# source://rubocop//lib/rubocop/cop/style/symbol_literal.rb#18
RuboCop::Cop::Style::SymbolLiteral::MSG = T.let(T.unsafe(nil), String)

# Use symbols as procs when possible.
#
# If you prefer a style that allows block for method with arguments,
# please set `true` to `AllowMethodsWithArguments`.
# `define_method?` methods are allowed by default.
# These are customizable with `AllowedMethods` option.
#
# @example AllowedPatterns: ['map'] (default)
#   # good
#   something.map { |s| s.upcase }
# @example AllowMethodsWithArguments: false (default)
#   # bad
#   something.do_something(foo) { |o| o.bar }
#
#   # good
#   something.do_something(foo, &:bar)
# @example AllowMethodsWithArguments: true
#   # good
#   something.do_something(foo) { |o| o.bar }
# @example AllowComments: false (default)
#   # bad
#   something.do_something do |s| # some comment
#   # some comment
#   s.upcase # some comment
#   # some comment
#   end
# @example AllowComments: true
#   # good  - if there are comment in either position
#   something.do_something do |s| # some comment
#   # some comment
#   s.upcase # some comment
#   # some comment
#   end
# @example AllowedMethods: [define_method] (default)
#   # good
#   define_method(:foo) { |foo| foo.bar }
# @example AllowedPatterns: [] (default)
#   # bad
#   something.map { |s| s.upcase }
# @example
#   # bad
#   something.map { |s| s.upcase }
#   something.map { _1.upcase }
#
#   # good
#   something.map(&:upcase)
#
# source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#87
class RuboCop::Cop::Style::SymbolProc < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::CommentsHelp
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::AllowedPattern
  extend ::RuboCop::Cop::AutoCorrector

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#136
  def destructuring_block_argument?(argument_node); end

  # source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#116
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#116
  def on_numblock(node); end

  # source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#98
  def proc_node?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#104
  def symbol_proc?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#101
  def symbol_proc_receiver?(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#204
  def allow_comments?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#200
  def allow_if_method_has_argument?(send_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#151
  def allowed_method_name?(name); end

  # source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#164
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#176
  def autocorrect_with_args(corrector, node, args, method_name); end

  # source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#172
  def autocorrect_without_args(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#190
  def begin_pos_for_replacement(node); end

  # source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#185
  def block_range_with_space(node); end

  # source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#155
  def register_offense(node, method_name, block_method_name); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#147
  def unsafe_array_usage?(node); end

  # See: https://github.com/rubocop/rubocop/issues/10864
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#143
  def unsafe_hash_usage?(node); end

  class << self
    # source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#111
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#94
RuboCop::Cop::Style::SymbolProc::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#95
RuboCop::Cop::Style::SymbolProc::SUPER_TYPES = T.let(T.unsafe(nil), Array)

# Corrector to correct conditional assignment in ternary conditions.
#
# source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#498
class RuboCop::Cop::Style::TernaryCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper

  class << self
    # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#503
    def correct(corrector, node); end

    # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#507
    def move_assignment_inside_condition(corrector, node); end

    private

    # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#521
    def correction(node); end

    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#534
    def element_assignment?(node); end

    # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#538
    def extract_branches(node); end

    # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#551
    def move_branch_inside_condition(corrector, branch, assignment); end

    # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#546
    def remove_parentheses(corrector, node); end

    # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#525
    def ternary(node); end
  end
end

# Checks for the presence of parentheses around ternary
# conditions. It is configurable to enforce inclusion or omission of
# parentheses using `EnforcedStyle`. Omission is only enforced when
# removing the parentheses won't cause a different behavior.
#
# `AllowSafeAssignment` option for safe assignment.
# By safe assignment we mean putting parentheses around
# an assignment to indicate "I know I'm using an assignment
# as a condition. It's not a mistake."
#
# @example EnforcedStyle: require_no_parentheses (default)
#   # bad
#   foo = (bar?) ? a : b
#   foo = (bar.baz?) ? a : b
#   foo = (bar && baz) ? a : b
#
#   # good
#   foo = bar? ? a : b
#   foo = bar.baz? ? a : b
#   foo = bar && baz ? a : b
# @example EnforcedStyle: require_parentheses
#   # bad
#   foo = bar? ? a : b
#   foo = bar.baz? ? a : b
#   foo = bar && baz ? a : b
#
#   # good
#   foo = (bar?) ? a : b
#   foo = (bar.baz?) ? a : b
#   foo = (bar && baz) ? a : b
# @example EnforcedStyle: require_parentheses_when_complex
#   # bad
#   foo = (bar?) ? a : b
#   foo = (bar.baz?) ? a : b
#   foo = bar && baz ? a : b
#
#   # good
#   foo = bar? ? a : b
#   foo = bar.baz? ? a : b
#   foo = (bar && baz) ? a : b
# @example AllowSafeAssignment: true (default)
#   # good
#   foo = (bar = baz) ? a : b
# @example AllowSafeAssignment: false
#   # bad
#   foo = (bar = baz) ? a : b
#
# source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#57
class RuboCop::Cop::Style::TernaryParentheses < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::SafeAssignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SurroundingSpace
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#193
  def method_name(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#69
  def on_if(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#100
  def autocorrect(corrector, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#183
  def below_ternary_precedence?(child); end

  # If the condition is parenthesized we recurse and check for any
  # complex expressions within it.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#131
  def complex_condition?(condition); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#89
  def condition_as_parenthesized_one_line_pattern_matching?(condition); end

  # source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#198
  def correct_parenthesized(corrector, condition); end

  # source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#208
  def correct_unparenthesized(corrector, condition); end

  # source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#151
  def message(node); end

  # Anything that is not a variable, constant, or method/.method call
  # will be counted as a complex expression.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#141
  def non_complex_expression?(condition); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#145
  def non_complex_send?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#113
  def offense?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#85
  def only_closing_parenthesis_is_last_line?(condition); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#169
  def parenthesized?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#161
  def require_parentheses?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#165
  def require_parentheses_when_complex?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#179
  def unparenthesized_method_call?(child); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#173
  def unsafe_autocorrect?(condition); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#212
  def whitespace_after?(node); end
end

# source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#66
RuboCop::Cop::Style::TernaryParentheses::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#67
RuboCop::Cop::Style::TernaryParentheses::MSG_COMPLEX = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#64
RuboCop::Cop::Style::TernaryParentheses::NON_COMPLEX_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#63
RuboCop::Cop::Style::TernaryParentheses::VARIABLE_TYPES = T.let(T.unsafe(nil), Set)

# Newcomers to ruby applications may write top-level methods,
# when ideally they should be organized in appropriate classes or modules.
# This cop looks for definitions of top-level methods and warns about them.
#
# However for ruby scripts it is perfectly fine to use top-level methods.
# Hence this cop is disabled by default.
#
# @example
#   # bad
#   def some_method
#   end
#
#   # bad
#   def self.some_method
#   end
#
#   # bad
#   define_method(:foo) { puts 1 }
#
#   # good
#   module Foo
#   def some_method
#   end
#   end
#
#   # good
#   class Foo
#   def self.some_method
#   end
#   end
#
#   # good
#   Struct.new do
#   def some_method
#   end
#   end
#
#   # good
#   class Foo
#   define_method(:foo) { puts 1 }
#   end
#
# source://rubocop//lib/rubocop/cop/style/top_level_method_definition.rb#47
class RuboCop::Cop::Style::TopLevelMethodDefinition < ::RuboCop::Cop::Base
  # source://rubocop//lib/rubocop/cop/style/top_level_method_definition.rb#79
  def define_method_block?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/top_level_method_definition.rb#60
  def on_block(node); end

  # source://rubocop//lib/rubocop/cop/style/top_level_method_definition.rb#52
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/style/top_level_method_definition.rb#52
  def on_defs(node); end

  # source://rubocop//lib/rubocop/cop/style/top_level_method_definition.rb#60
  def on_numblock(node); end

  # source://rubocop//lib/rubocop/cop/style/top_level_method_definition.rb#52
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/top_level_method_definition.rb#70
  def top_level_method_definition?(node); end
end

# source://rubocop//lib/rubocop/cop/style/top_level_method_definition.rb#48
RuboCop::Cop::Style::TopLevelMethodDefinition::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/top_level_method_definition.rb#50
RuboCop::Cop::Style::TopLevelMethodDefinition::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for trailing code after the class definition.
#
# @example
#   # bad
#   class Foo; def foo; end
#   end
#
#   # good
#   class Foo
#   def foo; end
#   end
#
# source://rubocop//lib/rubocop/cop/style/trailing_body_on_class.rb#18
class RuboCop::Cop::Style::TrailingBodyOnClass < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::TrailingBody
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/trailing_body_on_class.rb#25
  def on_class(node); end
end

# source://rubocop//lib/rubocop/cop/style/trailing_body_on_class.rb#23
RuboCop::Cop::Style::TrailingBodyOnClass::MSG = T.let(T.unsafe(nil), String)

# Checks for trailing code after the method definition.
#
# NOTE: It always accepts endless method definitions that are basically on the same line.
#
# @example
#   # bad
#   def some_method; do_stuff
#   end
#
#   def f(x); b = foo
#   b[c: x]
#   end
#
#   # good
#   def some_method
#   do_stuff
#   end
#
#   def f(x)
#   b = foo
#   b[c: x]
#   end
#
#   def endless_method = do_stuff
#
# source://rubocop//lib/rubocop/cop/style/trailing_body_on_method_definition.rb#31
class RuboCop::Cop::Style::TrailingBodyOnMethodDefinition < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::TrailingBody
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/trailing_body_on_method_definition.rb#38
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/style/trailing_body_on_method_definition.rb#38
  def on_defs(node); end
end

# source://rubocop//lib/rubocop/cop/style/trailing_body_on_method_definition.rb#36
RuboCop::Cop::Style::TrailingBodyOnMethodDefinition::MSG = T.let(T.unsafe(nil), String)

# Checks for trailing code after the module definition.
#
# @example
#   # bad
#   module Foo extend self
#   end
#
#   # good
#   module Foo
#   extend self
#   end
#
# source://rubocop//lib/rubocop/cop/style/trailing_body_on_module.rb#18
class RuboCop::Cop::Style::TrailingBodyOnModule < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::TrailingBody
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/trailing_body_on_module.rb#25
  def on_module(node); end
end

# source://rubocop//lib/rubocop/cop/style/trailing_body_on_module.rb#23
RuboCop::Cop::Style::TrailingBodyOnModule::MSG = T.let(T.unsafe(nil), String)

# Checks for trailing comma in argument lists.
# The supported styles are:
#
# * `consistent_comma`: Requires a comma after the last argument,
# for all parenthesized method calls with arguments.
# * `comma`: Requires a comma after the last argument, but only for
# parenthesized method calls where each argument is on its own line.
# * `no_comma`: Requires that there is no comma after the last
# argument.
#
# @example EnforcedStyleForMultiline: consistent_comma
#   # bad
#   method(1, 2,)
#
#   # good
#   method(1, 2)
#
#   # good
#   method(
#   1, 2,
#   3,
#   )
#
#   # good
#   method(
#   1, 2, 3,
#   )
#
#   # good
#   method(
#   1,
#   2,
#   )
# @example EnforcedStyleForMultiline: comma
#   # bad
#   method(1, 2,)
#
#   # good
#   method(1, 2)
#
#   # bad
#   method(
#   1, 2,
#   3,
#   )
#
#   # good
#   method(
#   1, 2,
#   3
#   )
#
#   # bad
#   method(
#   1, 2, 3,
#   )
#
#   # good
#   method(
#   1, 2, 3
#   )
#
#   # good
#   method(
#   1,
#   2,
#   )
# @example EnforcedStyleForMultiline: no_comma (default)
#   # bad
#   method(1, 2,)
#
#   # good
#   method(1, 2)
#
#   # good
#   method(
#   1,
#   2
#   )
#
# source://rubocop//lib/rubocop/cop/style/trailing_comma_in_arguments.rb#87
class RuboCop::Cop::Style::TrailingCommaInArguments < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::TrailingComma
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/trailing_comma_in_arguments.rb#95
  def on_csend(node); end

  # source://rubocop//lib/rubocop/cop/style/trailing_comma_in_arguments.rb#95
  def on_send(node); end

  class << self
    # source://rubocop//lib/rubocop/cop/style/trailing_comma_in_arguments.rb#91
    def autocorrect_incompatible_with; end
  end
end

# Checks for trailing comma in array literals.
# The configuration options are:
#
# * `consistent_comma`: Requires a comma after the
# last item of all non-empty, multiline array literals.
# * `comma`: Requires a comma after last item in an array,
# but only when each item is on its own line.
# * `no_comma`: Does not require a comma after the
# last item in an array
#
# @example EnforcedStyleForMultiline: consistent_comma
#   # bad
#   a = [1, 2,]
#
#   # good
#   a = [1, 2]
#
#   # good
#   a = [
#   1, 2,
#   3,
#   ]
#
#   # good
#   a = [
#   1, 2, 3,
#   ]
#
#   # good
#   a = [
#   1,
#   2,
#   ]
# @example EnforcedStyleForMultiline: comma
#   # bad
#   a = [1, 2,]
#
#   # good
#   a = [1, 2]
#
#   # bad
#   a = [
#   1, 2,
#   3,
#   ]
#
#   # good
#   a = [
#   1, 2,
#   3
#   ]
#
#   # bad
#   a = [
#   1, 2, 3,
#   ]
#
#   # good
#   a = [
#   1, 2, 3
#   ]
#
#   # good
#   a = [
#   1,
#   2,
#   ]
# @example EnforcedStyleForMultiline: no_comma (default)
#   # bad
#   a = [1, 2,]
#
#   # good
#   a = [
#   1,
#   2
#   ]
#
# source://rubocop//lib/rubocop/cop/style/trailing_comma_in_array_literal.rb#84
class RuboCop::Cop::Style::TrailingCommaInArrayLiteral < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::TrailingComma
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/trailing_comma_in_array_literal.rb#88
  def on_array(node); end
end

# Checks whether trailing commas in block arguments are
# required. Blocks with only one argument and a trailing comma require
# that comma to be present. Blocks with more than one argument never
# require a trailing comma.
#
# @example
#   # bad
#   add { |foo, bar,| foo + bar }
#
#   # good
#   add { |foo, bar| foo + bar }
#
#   # good
#   add { |foo,| foo }
#
#   # good
#   add { foo }
#
#   # bad
#   add do |foo, bar,|
#   foo + bar
#   end
#
#   # good
#   add do |foo, bar|
#   foo + bar
#   end
#
#   # good
#   add do |foo,|
#   foo
#   end
#
#   # good
#   add do
#   foo + bar
#   end
#
# source://rubocop//lib/rubocop/cop/style/trailing_comma_in_block_args.rb#62
class RuboCop::Cop::Style::TrailingCommaInBlockArgs < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/trailing_comma_in_block_args.rb#67
  def on_block(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/trailing_comma_in_block_args.rb#83
  def arg_count(node); end

  # source://rubocop//lib/rubocop/cop/style/trailing_comma_in_block_args.rb#95
  def argument_tokens(node); end

  # source://rubocop//lib/rubocop/cop/style/trailing_comma_in_block_args.rb#91
  def last_comma(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/trailing_comma_in_block_args.rb#87
  def trailing_comma?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/trailing_comma_in_block_args.rb#79
  def useless_trailing_comma?(node); end
end

# source://rubocop//lib/rubocop/cop/style/trailing_comma_in_block_args.rb#65
RuboCop::Cop::Style::TrailingCommaInBlockArgs::MSG = T.let(T.unsafe(nil), String)

# Checks for trailing comma in hash literals.
# The configuration options are:
#
# * `consistent_comma`: Requires a comma after the
# last item of all non-empty, multiline hash literals.
# * `comma`: Requires a comma after the last item in a hash,
# but only when each item is on its own line.
# * `no_comma`: Does not require a comma after the
# last item in a hash
#
# @example EnforcedStyleForMultiline: consistent_comma
#
#   # bad
#   a = { foo: 1, bar: 2, }
#
#   # good
#   a = { foo: 1, bar: 2 }
#
#   # good
#   a = {
#   foo: 1, bar: 2,
#   qux: 3,
#   }
#
#   # good
#   a = {
#   foo: 1, bar: 2, qux: 3,
#   }
#
#   # good
#   a = {
#   foo: 1,
#   bar: 2,
#   }
# @example EnforcedStyleForMultiline: comma
#
#   # bad
#   a = { foo: 1, bar: 2, }
#
#   # good
#   a = { foo: 1, bar: 2 }
#
#   # bad
#   a = {
#   foo: 1, bar: 2,
#   qux: 3,
#   }
#
#   # good
#   a = {
#   foo: 1, bar: 2,
#   qux: 3
#   }
#
#   # bad
#   a = {
#   foo: 1, bar: 2, qux: 3,
#   }
#
#   # good
#   a = {
#   foo: 1, bar: 2, qux: 3
#   }
#
#   # good
#   a = {
#   foo: 1,
#   bar: 2,
#   }
# @example EnforcedStyleForMultiline: no_comma (default)
#
#   # bad
#   a = { foo: 1, bar: 2, }
#
#   # good
#   a = {
#   foo: 1,
#   bar: 2
#   }
#
# source://rubocop//lib/rubocop/cop/style/trailing_comma_in_hash_literal.rb#87
class RuboCop::Cop::Style::TrailingCommaInHashLiteral < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::TrailingComma
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/trailing_comma_in_hash_literal.rb#91
  def on_hash(node); end
end

# Checks for trailing code after the method definition.
#
# @example
#   # bad
#   def some_method
#   do_stuff; end
#
#   def do_this(x)
#   baz.map { |b| b.this(x) } end
#
#   def foo
#   block do
#   bar
#   end end
#
#   # good
#   def some_method
#   do_stuff
#   end
#
#   def do_this(x)
#   baz.map { |b| b.this(x) }
#   end
#
#   def foo
#   block do
#   bar
#   end
#   end
#
# source://rubocop//lib/rubocop/cop/style/trailing_method_end_statement.rb#36
class RuboCop::Cop::Style::TrailingMethodEndStatement < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/trailing_method_end_statement.rb#41
  def on_def(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/trailing_method_end_statement.rb#55
  def body_and_end_on_same_line?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/trailing_method_end_statement.rb#51
  def trailing_end?(node); end
end

# source://rubocop//lib/rubocop/cop/style/trailing_method_end_statement.rb#39
RuboCop::Cop::Style::TrailingMethodEndStatement::MSG = T.let(T.unsafe(nil), String)

# Checks for extra underscores in variable assignment.
#
# @example
#   # bad
#   a, b, _ = foo()
#   a, b, _, = foo()
#   a, _, _ = foo()
#   a, _, _, = foo()
#
#   # good
#   a, b, = foo()
#   a, = foo()
#   *a, b, _ = foo()
#   # => We need to know to not include 2 variables in a
#   a, *b, _ = foo()
#   # => The correction `a, *b, = foo()` is a syntax error
# @example AllowNamedUnderscoreVariables: true (default)
#   # good
#   a, b, _something = foo()
# @example AllowNamedUnderscoreVariables: false
#   # bad
#   a, b, _something = foo()
#
# source://rubocop//lib/rubocop/cop/style/trailing_underscore_variable.rb#31
class RuboCop::Cop::Style::TrailingUnderscoreVariable < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SurroundingSpace
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/trailing_underscore_variable.rb#41
  def on_masgn(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/trailing_underscore_variable.rb#92
  def allow_named_underscore_variables; end

  # source://rubocop//lib/rubocop/cop/style/trailing_underscore_variable.rb#125
  def children_offenses(variables); end

  # source://rubocop//lib/rubocop/cop/style/trailing_underscore_variable.rb#57
  def find_first_offense(variables); end

  # source://rubocop//lib/rubocop/cop/style/trailing_underscore_variable.rb#66
  def find_first_possible_offense(variables); end

  # source://rubocop//lib/rubocop/cop/style/trailing_underscore_variable.rb#108
  def main_node_offense(node); end

  # source://rubocop//lib/rubocop/cop/style/trailing_underscore_variable.rb#146
  def range_for_parentheses(offense, left); end

  # source://rubocop//lib/rubocop/cop/style/trailing_underscore_variable.rb#88
  def reverse_index(collection, item); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/trailing_underscore_variable.rb#80
  def splat_variable_before?(first_offense, variables); end

  # source://rubocop//lib/rubocop/cop/style/trailing_underscore_variable.rb#96
  def unneeded_ranges(node); end

  # source://rubocop//lib/rubocop/cop/style/trailing_underscore_variable.rb#133
  def unused_range(node_type, mlhs_node, right); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/trailing_underscore_variable.rb#129
  def unused_variables_only?(offense, variables); end
end

# source://rubocop//lib/rubocop/cop/style/trailing_underscore_variable.rb#38
RuboCop::Cop::Style::TrailingUnderscoreVariable::DISALLOW = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/trailing_underscore_variable.rb#36
RuboCop::Cop::Style::TrailingUnderscoreVariable::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/trailing_underscore_variable.rb#37
RuboCop::Cop::Style::TrailingUnderscoreVariable::UNDERSCORE = T.let(T.unsafe(nil), String)

# Looks for trivial reader/writer methods, that could
# have been created with the attr_* family of functions automatically.
# `to_ary`, `to_a`, `to_c`, `to_enum`, `to_h`, `to_hash`, `to_i`, `to_int`, `to_io`,
# `to_open`, `to_path`, `to_proc`, `to_r`, `to_regexp`, `to_str`, `to_s`, and `to_sym` methods
# are allowed by default. These are customizable with `AllowedMethods` option.
#
# @example AllowedMethods: ['allowed_method']
#   # good
#   def allowed_method
#   @foo
#   end
# @example ExactNameMatch: true (default)
#   # good
#   def name
#   @other_name
#   end
# @example ExactNameMatch: false
#   # bad
#   def name
#   @other_name
#   end
# @example AllowPredicates: true (default)
#   # good
#   def foo?
#   @foo
#   end
# @example AllowPredicates: false
#   # bad
#   def foo?
#   @foo
#   end
#
#   # good
#   attr_reader :foo
# @example AllowDSLWriters: true (default)
#   # good
#   def on_exception(action)
#   @on_exception=action
#   end
# @example AllowDSLWriters: false
#   # bad
#   def on_exception(action)
#   @on_exception=action
#   end
#
#   # good
#   attr_writer :on_exception
# @example IgnoreClassMethods: false (default)
#   # bad
#   def self.foo
#   @foo
#   end
#
#   # good
#   class << self
#   attr_reader :foo
#   end
# @example IgnoreClassMethods: true
#   # good
#   def self.foo
#   @foo
#   end
# @example
#   # bad
#   def foo
#   @foo
#   end
#
#   def bar=(val)
#   @bar = val
#   end
#
#   def self.baz
#   @baz
#   end
#
#   # good
#   attr_reader :foo
#   attr_writer :bar
#
#   class << self
#   attr_reader :baz
#   end
#
# source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#98
class RuboCop::Cop::Style::TrivialAccessors < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::AllowedMethods
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#190
  def looks_like_trivial_writer?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#104
  def on_def(node); end

  # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#104
  def on_defs(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#222
  def accessor(kind, method_name); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#161
  def allow_dsl_writers?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#157
  def allow_predicates?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#195
  def allowed_method_name?(node); end

  # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#169
  def allowed_method_names; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#204
  def allowed_reader?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#200
  def allowed_writer?(node); end

  # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#142
  def autocorrect(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#234
  def autocorrect_class(corrector, node); end

  # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#226
  def autocorrect_instance(corrector, node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#173
  def dsl_writer?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#153
  def exact_name_match?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#165
  def ignore_class_methods?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#115
  def in_module_or_instance_eval?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#181
  def looks_like_trivial_reader?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#208
  def names_match?(node); end

  # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#129
  def on_method_def(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#248
  def top_level_node?(node); end

  # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#214
  def trivial_accessor_kind(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#177
  def trivial_reader?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#185
  def trivial_writer?(node); end
end

# source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#102
RuboCop::Cop::Style::TrivialAccessors::MSG = T.let(T.unsafe(nil), String)

# Looks for `unless` expressions with `else` clauses.
#
# @example
#   # bad
#   unless foo_bar.nil?
#   # do something...
#   else
#   # do a different thing...
#   end
#
#   # good
#   if foo_bar.present?
#   # do something...
#   else
#   # do a different thing...
#   end
#
# source://rubocop//lib/rubocop/cop/style/unless_else.rb#22
class RuboCop::Cop::Style::UnlessElse < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/unless_else.rb#28
  def on_if(node); end

  # source://rubocop//lib/rubocop/cop/style/unless_else.rb#45
  def range_between_condition_and_else(node, condition); end

  # source://rubocop//lib/rubocop/cop/style/unless_else.rb#49
  def range_between_else_and_end(node); end
end

# source://rubocop//lib/rubocop/cop/style/unless_else.rb#26
RuboCop::Cop::Style::UnlessElse::MSG = T.let(T.unsafe(nil), String)

# Checks for the use of logical operators in an `unless` condition.
# It discourages such code, as the condition becomes more difficult
# to read and understand.
#
# This cop supports two styles:
#
# - `forbid_mixed_logical_operators` (default)
# - `forbid_logical_operators`
#
# `forbid_mixed_logical_operators` style forbids the use of more than one type
# of logical operators. This makes the `unless` condition easier to read
# because either all conditions need to be met or any condition need to be met
# in order for the expression to be truthy or falsey.
#
# `forbid_logical_operators` style forbids any use of logical operator.
# This makes it even more easy to read the `unless` condition as
# there is only one condition in the expression.
#
# @example EnforcedStyle: forbid_mixed_logical_operators (default)
#   # bad
#   return unless a || b && c
#   return unless a && b || c
#   return unless a && b and c
#   return unless a || b or c
#   return unless a && b or c
#   return unless a || b and c
#
#   # good
#   return unless a && b && c
#   return unless a || b || c
#   return unless a and b and c
#   return unless a or b or c
#   return unless a?
# @example EnforcedStyle: forbid_logical_operators
#   # bad
#   return unless a || b
#   return unless a && b
#   return unless a or b
#   return unless a and b
#
#   # good
#   return unless a
#   return unless a?
#
# source://rubocop//lib/rubocop/cop/style/unless_logical_operators.rb#50
class RuboCop::Cop::Style::UnlessLogicalOperators < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop//lib/rubocop/cop/style/unless_logical_operators.rb#62
  def and_with_or?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/unless_logical_operators.rb#67
  def logical_operator?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/unless_logical_operators.rb#71
  def on_if(node); end

  # source://rubocop//lib/rubocop/cop/style/unless_logical_operators.rb#57
  def or_with_and?(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/unless_logical_operators.rb#83
  def mixed_logical_operator?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/unless_logical_operators.rb#90
  def mixed_precedence_and?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/unless_logical_operators.rb#97
  def mixed_precedence_or?(node); end
end

# source://rubocop//lib/rubocop/cop/style/unless_logical_operators.rb#54
RuboCop::Cop::Style::UnlessLogicalOperators::FORBID_LOGICAL_OPERATORS = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/unless_logical_operators.rb#53
RuboCop::Cop::Style::UnlessLogicalOperators::FORBID_MIXED_LOGICAL_OPERATORS = T.let(T.unsafe(nil), String)

# Checks for accessing the first element of `String#unpack`
# which can be replaced with the shorter method `unpack1`.
#
# @example
#
#   # bad
#   'foo'.unpack('h*').first
#   'foo'.unpack('h*')[0]
#   'foo'.unpack('h*').slice(0)
#   'foo'.unpack('h*').at(0)
#
#   # good
#   'foo'.unpack1('h*')
#
# source://rubocop//lib/rubocop/cop/style/unpack_first.rb#20
class RuboCop::Cop::Style::UnpackFirst < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop//lib/rubocop/cop/style/unpack_first.rb#38
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/style/unpack_first.rb#31
  def unpack_and_first_element?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/style/unpack_first.rb#54
  def first_element_range(node, unpack_call); end
end

# source://rubocop//lib/rubocop/cop/style/unpack_first.rb#26
RuboCop::Cop::Style::UnpackFirst::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/unpack_first.rb#28
RuboCop::Cop::Style::UnpackFirst::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for variable interpolation (like "#@ivar").
#
# @example
#   # bad
#   "His name is #$name"
#   /check #$pattern/
#   "Let's go to the #@store"
#
#   # good
#   "His name is #{$name}"
#   /check #{$pattern}/
#   "Let's go to the #{@store}"
#
# source://rubocop//lib/rubocop/cop/style/variable_interpolation.rb#18
class RuboCop::Cop::Style::VariableInterpolation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Interpolation
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/variable_interpolation.rb#25
  def on_node_with_interpolations(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/variable_interpolation.rb#35
  def message(range); end

  # source://rubocop//lib/rubocop/cop/style/variable_interpolation.rb#39
  def var_nodes(nodes); end
end

# source://rubocop//lib/rubocop/cop/style/variable_interpolation.rb#22
RuboCop::Cop::Style::VariableInterpolation::MSG = T.let(T.unsafe(nil), String)

# Checks for `when;` uses in `case` expressions.
#
# @example
#   # bad
#   case foo
#   when 1; 'baz'
#   when 2; 'bar'
#   end
#
#   # good
#   case foo
#   when 1 then 'baz'
#   when 2 then 'bar'
#   end
#
# source://rubocop//lib/rubocop/cop/style/when_then.rb#20
class RuboCop::Cop::Style::WhenThen < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/when_then.rb#25
  def on_when(node); end
end

# source://rubocop//lib/rubocop/cop/style/when_then.rb#23
RuboCop::Cop::Style::WhenThen::MSG = T.let(T.unsafe(nil), String)

# Checks for uses of `do` in multi-line `while/until` statements.
#
# @example
#
#   # bad
#   while x.any? do
#   do_something(x.pop)
#   end
#
#   # good
#   while x.any?
#   do_something(x.pop)
#   end
# @example
#
#   # bad
#   until x.empty? do
#   do_something(x.pop)
#   end
#
#   # good
#   until x.empty?
#   do_something(x.pop)
#   end
#
# source://rubocop//lib/rubocop/cop/style/while_until_do.rb#31
class RuboCop::Cop::Style::WhileUntilDo < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/while_until_do.rb#36
  def on_until(node); end

  # source://rubocop//lib/rubocop/cop/style/while_until_do.rb#36
  def on_while(node); end
end

# source://rubocop//lib/rubocop/cop/style/while_until_do.rb#34
RuboCop::Cop::Style::WhileUntilDo::MSG = T.let(T.unsafe(nil), String)

# Checks for while and until statements that would fit on one line
# if written as a modifier while/until. The maximum line length is
# configured in the `Layout/LineLength` cop.
#
# @example
#   # bad
#   while x < 10
#   x += 1
#   end
#
#   # good
#   x += 1 while x < 10
# @example
#   # bad
#   until x > 10
#   x += 1
#   end
#
#   # good
#   x += 1 until x > 10
# @example
#   # bad
#   x += 100 while x < 500 # a long comment that makes code too long if it were a single line
#
#   # good
#   while x < 500 # a long comment that makes code too long if it were a single line
#   x += 100
#   end
#
# source://rubocop//lib/rubocop/cop/style/while_until_modifier.rb#36
class RuboCop::Cop::Style::WhileUntilModifier < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::LineLengthHelp
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::StatementModifier
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/while_until_modifier.rb#42
  def on_until(node); end

  # source://rubocop//lib/rubocop/cop/style/while_until_modifier.rb#42
  def on_while(node); end
end

# source://rubocop//lib/rubocop/cop/style/while_until_modifier.rb#40
RuboCop::Cop::Style::WhileUntilModifier::MSG = T.let(T.unsafe(nil), String)

# Checks for array literals made up of word-like
# strings, that are not using the %w() syntax.
#
# Alternatively, it can check for uses of the %w() syntax, in projects
# which do not want to include that syntax.
#
# NOTE: When using the `percent` style, %w() arrays containing a space
# will be registered as offenses.
#
# Configuration option: MinSize
# If set, arrays with fewer elements than this value will not trigger the
# cop. For example, a `MinSize` of `3` will not enforce a style on an
# array of 2 or fewer elements.
#
# @example EnforcedStyle: percent (default)
#   # good
#   %w[foo bar baz]
#
#   # bad
#   ['foo', 'bar', 'baz']
#
#   # bad (contains spaces)
#   %w[foo\ bar baz\ quux]
#
#   # bad
#   [
#   ['one', 'One'],
#   ['two', 'Two']
#   ]
#
#   # good
#   [
#   %w[one One],
#   %w[two Two]
#   ]
#
#   # good (2d array containing spaces)
#   [
#   ['one', 'One'],
#   ['two', 'Two'],
#   ['forty two', 'Forty Two']
#   ]
# @example EnforcedStyle: brackets
#   # good
#   ['foo', 'bar', 'baz']
#
#   # bad
#   %w[foo bar baz]
#
#   # good (contains spaces)
#   ['foo bar', 'baz quux']
#
#   # good
#   [
#   ['one', 'One'],
#   ['two', 'Two']
#   ]
#
#   # bad
#   [
#   %w[one One],
#   %w[two Two]
#   ]
#
# source://rubocop//lib/rubocop/cop/style/word_array.rb#71
class RuboCop::Cop::Style::WordArray < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ArrayMinSize
  include ::RuboCop::Cop::ArraySyntax
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::PercentArray
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/word_array.rb#94
  def on_array(node); end

  # source://rubocop//lib/rubocop/cop/style/word_array.rb#85
  def on_new_investigation; end

  private

  # source://rubocop//lib/rubocop/cop/style/word_array.rb#138
  def build_bracketed_array(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/word_array.rb#118
  def complex_content?(strings, complex_regex: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/word_array.rb#129
  def invalid_percent_array_contents?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/word_array.rb#113
  def matrix_of_complex_content?(array); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/word_array.rb#107
  def within_matrix_of_complex_content?(node); end

  # source://rubocop//lib/rubocop/cop/style/word_array.rb#134
  def word_regex; end

  class << self
    # Returns the value of attribute largest_brackets.
    #
    # source://rubocop//lib/rubocop/cop/style/word_array.rb#82
    def largest_brackets; end

    # Sets the attribute largest_brackets
    #
    # @param value the value to set the attribute largest_brackets to.
    #
    # source://rubocop//lib/rubocop/cop/style/word_array.rb#82
    def largest_brackets=(_arg0); end
  end
end

# source://rubocop//lib/rubocop/cop/style/word_array.rb#79
RuboCop::Cop::Style::WordArray::ARRAY_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/word_array.rb#78
RuboCop::Cop::Style::WordArray::PERCENT_MSG = T.let(T.unsafe(nil), String)

# Enforces or forbids Yoda conditions,
# i.e. comparison operations where the order of expression is reversed.
# eg. `5 == x`
#
# @example EnforcedStyle: forbid_for_all_comparison_operators (default)
#   # bad
#   99 == foo
#   "bar" != foo
#   42 >= foo
#   10 < bar
#   99 == CONST
#
#   # good
#   foo == 99
#   foo == "bar"
#   foo <= 42
#   bar > 10
#   CONST == 99
#   "#{interpolation}" == foo
#   /#{interpolation}/ == foo
# @example EnforcedStyle: forbid_for_equality_operators_only
#   # bad
#   99 == foo
#   "bar" != foo
#
#   # good
#   99 >= foo
#   3 < a && a < 5
# @example EnforcedStyle: require_for_all_comparison_operators
#   # bad
#   foo == 99
#   foo == "bar"
#   foo <= 42
#   bar > 10
#
#   # good
#   99 == foo
#   "bar" != foo
#   42 >= foo
#   10 < bar
# @example EnforcedStyle: require_for_equality_operators_only
#   # bad
#   99 >= foo
#   3 < a && a < 5
#
#   # good
#   99 == foo
#   "bar" != foo
#
# source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#77
class RuboCop::Cop::Style::YodaCondition < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#90
  def file_constant_equal_program_name?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#94
  def on_send(node); end

  private

  # source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#147
  def actual_code_range(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#143
  def constant_portion?(node); end

  # source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#136
  def corrected_code(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#107
  def enforce_yoda?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#112
  def equality_only?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#171
  def interpolation?(node); end

  # source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#132
  def message(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#155
  def non_equality_operator?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#159
  def noncommutative_operator?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#167
  def program_name?(name); end

  # source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#151
  def reverse_comparison(operator); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#163
  def source_file_path_constant?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#121
  def valid_yoda?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#117
  def yoda_compatible_condition?(node); end
end

# source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#84
RuboCop::Cop::Style::YodaCondition::EQUALITY_OPERATORS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#82
RuboCop::Cop::Style::YodaCondition::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#85
RuboCop::Cop::Style::YodaCondition::NONCOMMUTATIVE_OPERATORS = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#86
RuboCop::Cop::Style::YodaCondition::PROGRAM_NAMES = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#87
RuboCop::Cop::Style::YodaCondition::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Set)

# source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#83
RuboCop::Cop::Style::YodaCondition::REVERSE_COMPARISON = T.let(T.unsafe(nil), Hash)

# Forbids Yoda expressions, i.e. binary operations (using `*`, `+`, `&`, `|`,
# and `^` operators) where the order of expression is reversed, eg. `1 + x`.
# This cop complements `Style/YodaCondition` cop, which has a similar purpose.
#
# This cop is disabled by default to respect user intentions such as:
#
# [source,ruby]
# ----
# config.server_port = 9000 + ENV["TEST_ENV_NUMBER"].to_i
# ----
#
# @example SupportedOperators: ['*', '+', '&'']
#   # bad
#   1 + x
#   10 * y
#   1 & z
#   1 + CONST
#
#   # good
#   60 * 24
#   x + 1
#   y * 10
#   z & 1
#   CONST + 1
#
#   # good
#   1 | x
#
# source://rubocop//lib/rubocop/cop/style/yoda_expression.rb#39
class RuboCop::Cop::Style::YodaExpression < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop//lib/rubocop/cop/style/yoda_expression.rb#46
  def on_new_investigation; end

  # source://rubocop//lib/rubocop/cop/style/yoda_expression.rb#50
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/yoda_expression.rb#72
  def constant_portion?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/yoda_expression.rb#80
  def offended_ancestor?(node); end

  # source://rubocop//lib/rubocop/cop/style/yoda_expression.rb#84
  def offended_nodes; end

  # source://rubocop//lib/rubocop/cop/style/yoda_expression.rb#76
  def supported_operators; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/style/yoda_expression.rb#68
  def yoda_expression_constant?(lhs, rhs); end
end

# source://rubocop//lib/rubocop/cop/style/yoda_expression.rb#42
RuboCop::Cop::Style::YodaExpression::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/yoda_expression.rb#44
RuboCop::Cop::Style::YodaExpression::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for numeric comparisons that can be replaced
# by a predicate method, such as `receiver.length == 0`,
# `receiver.length > 0`, and `receiver.length != 0`,
# `receiver.length < 1` and `receiver.size == 0` that can be
# replaced by `receiver.empty?` and `!receiver.empty?`.
#
# NOTE: `File`, `Tempfile`, and `StringIO` do not have `empty?`
# so allow `size == 0` and `size.zero?`.
#
# @example
#   # bad
#   [1, 2, 3].length == 0
#   0 == "foobar".length
#   array.length < 1
#   {a: 1, b: 2}.length != 0
#   string.length > 0
#   hash.size > 0
#
#   # good
#   [1, 2, 3].empty?
#   "foobar".empty?
#   array.empty?
#   !{a: 1, b: 2}.empty?
#   !string.empty?
#   !hash.empty?
#
# source://rubocop//lib/rubocop/cop/style/zero_length_predicate.rb#37
class RuboCop::Cop::Style::ZeroLengthPredicate < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # Some collection like objects in the Ruby standard library
  # implement `#size`, but not `#empty`. We ignore those to
  # reduce false positives.
  #
  # source://rubocop//lib/rubocop/cop/style/zero_length_predicate.rb#139
  def non_polymorphic_collection?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/zero_length_predicate.rb#109
  def nonzero_length_comparison(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/zero_length_predicate.rb#45
  def on_send(node); end

  # source://rubocop//lib/rubocop/cop/style/zero_length_predicate.rb#130
  def other_receiver(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/zero_length_predicate.rb#101
  def zero_length_comparison(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/zero_length_predicate.rb#96
  def zero_length_predicate(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/style/zero_length_predicate.rb#122
  def zero_length_receiver(param0 = T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/style/zero_length_predicate.rb#80
  def check_nonzero_length_comparison(node); end

  # source://rubocop//lib/rubocop/cop/style/zero_length_predicate.rb#65
  def check_zero_length_comparison(node); end

  # source://rubocop//lib/rubocop/cop/style/zero_length_predicate.rb#53
  def check_zero_length_predicate(node); end

  # source://rubocop//lib/rubocop/cop/style/zero_length_predicate.rb#114
  def replacement(node); end
end

# source://rubocop//lib/rubocop/cop/style/zero_length_predicate.rb#41
RuboCop::Cop::Style::ZeroLengthPredicate::NONZERO_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/style/zero_length_predicate.rb#43
RuboCop::Cop::Style::ZeroLengthPredicate::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# source://rubocop//lib/rubocop/cop/style/zero_length_predicate.rb#40
RuboCop::Cop::Style::ZeroLengthPredicate::ZERO_MSG = T.let(T.unsafe(nil), String)

# Common functionality for checking and correcting surrounding whitespace.
#
# source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#6
module RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#110
  def empty_brackets?(left_bracket_token, right_bracket_token, tokens: T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#104
  def empty_offense(node, range, message, command); end

  # source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#94
  def empty_offenses(node, left, right, message); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#68
  def extra_space?(token, side); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#129
  def no_character_between?(left_bracket_token, right_bracket_token); end

  # source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#38
  def no_space_offenses(node, left_token, right_token, message, start_ok: T.unsafe(nil), end_ok: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#120
  def offending_empty_no_space?(config, left_token, right_token); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#116
  def offending_empty_space?(config, left_token, right_token); end

  # source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#33
  def on_new_investigation; end

  # source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#78
  def reposition(src, pos, step, include_newlines: T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#16
  def side_space_range(range:, side:, include_newlines: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#124
  def space_between?(left_bracket_token, right_bracket_token); end

  # source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#85
  def space_offense(node, token, side, message, command); end

  # source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#53
  def space_offenses(node, left_token, right_token, message, start_ok: T.unsafe(nil), end_ok: T.unsafe(nil)); end
end

# source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#9
RuboCop::Cop::SurroundingSpace::NO_SPACE_COMMAND = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#12
RuboCop::Cop::SurroundingSpace::SINGLE_SPACE_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#10
RuboCop::Cop::SurroundingSpace::SPACE_COMMAND = T.let(T.unsafe(nil), String)

# Classes that include this module just implement functions for working
# with symbol nodes.
#
# source://rubocop//lib/rubocop/cop/mixin/symbol_help.rb#7
module RuboCop::Cop::SymbolHelp
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/symbol_help.rb#8
  def hash_key?(node); end
end

# Common functionality for checking target ruby version.
#
# source://rubocop//lib/rubocop/cop/mixin/target_ruby_version.rb#6
module RuboCop::Cop::TargetRubyVersion
  # source://rubocop//lib/rubocop/cop/mixin/target_ruby_version.rb#11
  def minimum_target_ruby_version(version); end

  # source://rubocop//lib/rubocop/cop/mixin/target_ruby_version.rb#7
  def required_minimum_ruby_version; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/target_ruby_version.rb#15
  def support_target_ruby_version?(version); end
end

# A group of cops, ready to be called on duty to inspect files.
# Team is responsible for selecting only relevant cops to be sent on duty,
# as well as insuring that the needed forces are sent along with them.
#
# For performance reasons, Team will first dispatch cops & forces in two groups,
# first the ones needed for autocorrection (if any), then the rest
# (unless autocorrections happened).
#
# source://rubocop//lib/rubocop/cop/team.rb#12
class RuboCop::Cop::Team
  # @return [Team] a new instance of Team
  #
  # source://rubocop//lib/rubocop/cop/team.rb#55
  def initialize(cops, config = T.unsafe(nil), options = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/team.rb#66
  def autocorrect?; end

  # Returns the value of attribute cops.
  #
  # source://rubocop//lib/rubocop/cop/team.rb#51
  def cops; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/team.rb#70
  def debug?; end

  # Returns the value of attribute errors.
  #
  # source://rubocop//lib/rubocop/cop/team.rb#51
  def errors; end

  # source://rubocop//lib/rubocop/cop/team.rb#114
  def external_dependency_checksum; end

  # @deprecated
  #
  # source://rubocop//lib/rubocop/cop/team.rb#110
  def forces; end

  # source://rubocop//lib/rubocop/cop/team.rb#76
  def inspect_file(processed_source); end

  # @return [Commissioner::InvestigationReport]
  #
  # source://rubocop//lib/rubocop/cop/team.rb#81
  def investigate(processed_source, offset: T.unsafe(nil), original: T.unsafe(nil)); end

  # Returns the value of attribute updated_source_file.
  #
  # source://rubocop//lib/rubocop/cop/team.rb#51
  def updated_source_file; end

  # Returns the value of attribute updated_source_file.
  #
  # source://rubocop//lib/rubocop/cop/team.rb#51
  def updated_source_file?; end

  # Returns the value of attribute warnings.
  #
  # source://rubocop//lib/rubocop/cop/team.rb#51
  def warnings; end

  private

  # source://rubocop//lib/rubocop/cop/team.rb#121
  def autocorrect(processed_source, report, original:, offset:); end

  # source://rubocop//lib/rubocop/cop/team.rb#182
  def autocorrect_report(report, offset:, original:); end

  # source://rubocop//lib/rubocop/cop/team.rb#140
  def be_ready; end

  # source://rubocop//lib/rubocop/cop/team.rb#188
  def collate_corrections(report, offset:, original:); end

  # source://rubocop//lib/rubocop/cop/team.rb#204
  def each_corrector(report); end

  # source://rubocop//lib/rubocop/cop/team.rb#254
  def handle_error(error, location, cop); end

  # source://rubocop//lib/rubocop/cop/team.rb#246
  def handle_warning(error, location); end

  # @return [Commissioner::InvestigationReport]
  #
  # source://rubocop//lib/rubocop/cop/team.rb#154
  def investigate_partial(cops, processed_source, offset:, original:); end

  # source://rubocop//lib/rubocop/cop/team.rb#231
  def process_errors(file, errors); end

  # source://rubocop//lib/rubocop/cop/team.rb#148
  def reset; end

  # @return [Array<cop>]
  #
  # source://rubocop//lib/rubocop/cop/team.rb#160
  def roundup_relevant_cops(processed_source); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/team.rb#176
  def support_target_rails_version?(cop); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/team.rb#170
  def support_target_ruby_version?(cop); end

  # source://rubocop//lib/rubocop/cop/team.rb#219
  def suppress_clobbering; end

  # source://rubocop//lib/rubocop/cop/team.rb#225
  def validate_config; end

  class << self
    # @return [Array<Force>] needed for the given cops
    #
    # source://rubocop//lib/rubocop/cop/team.rb#37
    def forces_for(cops); end

    # @return [Team] with cops assembled from the given `cop_classes`
    #
    # source://rubocop//lib/rubocop/cop/team.rb#22
    def mobilize(cop_classes, config, options = T.unsafe(nil)); end

    # @return [Array<Cop::Base>]
    #
    # source://rubocop//lib/rubocop/cop/team.rb#28
    def mobilize_cops(cop_classes, config, options = T.unsafe(nil)); end

    # @return [Team]
    #
    # source://rubocop//lib/rubocop/cop/team.rb#14
    def new(cop_or_classes, config, options = T.unsafe(nil)); end
  end
end

# Common methods shared by TrailingBody cops
#
# source://rubocop//lib/rubocop/cop/mixin/trailing_body.rb#6
module RuboCop::Cop::TrailingBody
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/trailing_body.rb#12
  def body_on_first_line?(node, body); end

  # source://rubocop//lib/rubocop/cop/mixin/trailing_body.rb#16
  def first_part_of(body); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/trailing_body.rb#7
  def trailing_body?(node); end
end

# Common methods shared by Style/TrailingCommaInArguments and
# Style/TrailingCommaInLiteral
#
# source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#7
module RuboCop::Cop::TrailingComma
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp

  private

  # A single argument with the closing bracket on the same line as the end
  # of the argument is not considered multiline, even if the argument
  # itself might span multiple lines.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#104
  def allowed_multiline_argument?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#167
  def any_heredoc?(items); end

  # source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#159
  def autocorrect_range(item); end

  # source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#133
  def avoid_comma(kind, comma_begin_pos, extra_info); end

  # Returns true if the node has round/square/curly brackets.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#82
  def brackets?(node); end

  # source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#19
  def check(node, items, kind, begin_pos, end_pos); end

  # source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#37
  def check_comma(node, kind, comma_pos); end

  # source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#43
  def check_literal(node, kind); end

  # source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#30
  def comma_offset(items, range); end

  # source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#108
  def elements(node); end

  # source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#54
  def extra_avoid_comma_info; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#171
  def heredoc?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#189
  def heredoc_send?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#76
  def inside_comment?(range, comma_offset); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#93
  def method_name_and_arguments_on_same_line?(node); end

  # Returns true if the round/square/curly brackets of the given node are
  # on different lines, each item within is on its own line, and the
  # closing bracket is on its own line.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#89
  def multiline?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#123
  def no_elements_on_same_line?(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#129
  def on_same_line?(range1, range2); end

  # source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#147
  def put_comma(items, kind); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#65
  def should_have_comma?(style, node); end

  # source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#15
  def style_parameter_name; end
end

# source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#11
RuboCop::Cop::TrailingComma::MSG = T.let(T.unsafe(nil), String)

# Common functionality shared by Uncommunicative cops
#
# source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#6
module RuboCop::Cop::UncommunicativeName
  # source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#12
  def check(node, args); end

  private

  # source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#95
  def allow_nums; end

  # source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#87
  def allowed_names; end

  # source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#78
  def arg_range(arg, length); end

  # source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#45
  def case_offense(node, range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#64
  def ends_with_num?(name); end

  # source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#91
  def forbidden_names; end

  # source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#83
  def forbidden_offense(node, range, name); end

  # source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#36
  def issue_offenses(node, range, name); end

  # source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#68
  def length_offense(node, range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#74
  def long_enough?(name); end

  # source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#99
  def min_length; end

  # source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#53
  def name_type(node); end

  # source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#60
  def num_offense(node, range); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#49
  def uppercase?(name); end
end

# source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#7
RuboCop::Cop::UncommunicativeName::CASE_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#10
RuboCop::Cop::UncommunicativeName::FORBIDDEN_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#9
RuboCop::Cop::UncommunicativeName::LENGTH_MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#8
RuboCop::Cop::UncommunicativeName::NUM_MSG = T.let(T.unsafe(nil), String)

# This autocorrects unused arguments.
#
# source://rubocop//lib/rubocop/cop/correctors/unused_arg_corrector.rb#6
class RuboCop::Cop::UnusedArgCorrector
  extend ::RuboCop::Cop::RangeHelp

  class << self
    # source://rubocop//lib/rubocop/cop/correctors/unused_arg_corrector.rb#12
    def correct(corrector, processed_source, node); end

    # source://rubocop//lib/rubocop/cop/correctors/unused_arg_corrector.rb#31
    def correct_for_blockarg_type(corrector, node); end

    # Returns the value of attribute processed_source.
    #
    # source://rubocop//lib/rubocop/cop/correctors/unused_arg_corrector.rb#10
    def processed_source; end
  end
end

# This module contains a collection of useful utility methods.
#
# source://rubocop//lib/rubocop/cop/util.rb#7
module RuboCop::Cop::Util
  include ::RuboCop::PathUtil

  private

  # source://rubocop//lib/rubocop/cop/util.rb#35
  def add_parentheses(node, corrector); end

  # source://rubocop//lib/rubocop/cop/util.rb#56
  def any_descendant?(node, *types); end

  # source://rubocop//lib/rubocop/cop/util.rb#71
  def args_begin(node); end

  # source://rubocop//lib/rubocop/cop/util.rb#83
  def args_end(node); end

  # source://rubocop//lib/rubocop/cop/util.rb#104
  def begins_its_line?(range); end

  # This is a bad API
  #
  # source://rubocop//lib/rubocop/cop/util.rb#17
  def comment_line?(line_source); end

  # @deprecated Use `ProcessedSource#line_with_comment?`, `contains_comment?` or similar
  #
  # source://rubocop//lib/rubocop/cop/util.rb#22
  def comment_lines?(node); end

  # source://rubocop//lib/rubocop/cop/util.rb#192
  def compatible_external_encoding_for?(src); end

  # If converting a string to Ruby string literal source code, must
  # double quotes be used?
  #
  # source://rubocop//lib/rubocop/cop/util.rb#130
  def double_quotes_required?(string); end

  # source://rubocop//lib/rubocop/cop/util.rb#144
  def escape_string(string); end

  # Returns, for example, a bare `if` node if the given node is an `if`
  # with calls chained to the end of it.
  #
  # source://rubocop//lib/rubocop/cop/util.rb#114
  def first_part_of_call_chain(node); end

  # source://rubocop//lib/rubocop/cop/util.rb#197
  def include_or_equal?(source, target); end

  # source://rubocop//lib/rubocop/cop/util.rb#179
  def indent(node, offset: T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/util.rb#161
  def interpret_string_escapes(string); end

  # source://rubocop//lib/rubocop/cop/util.rb#165
  def line(node_or_range); end

  # source://rubocop//lib/rubocop/cop/util.rb#26
  def line_range(node); end

  # source://rubocop//lib/rubocop/cop/util.rb#140
  def needs_escaping?(string); end

  # source://rubocop//lib/rubocop/cop/util.rb#87
  def on_node(syms, sexp, excludes = T.unsafe(nil), &block); end

  # source://rubocop//lib/rubocop/cop/util.rb#30
  def parentheses?(node); end

  # source://rubocop//lib/rubocop/cop/util.rb#173
  def same_line?(node1, node2); end

  # source://rubocop//lib/rubocop/cop/util.rb#148
  def to_string_literal(string); end

  # source://rubocop//lib/rubocop/cop/util.rb#185
  def to_supported_styles(enforced_style); end

  # source://rubocop//lib/rubocop/cop/util.rb#157
  def trim_string_interpolation_escape_character(str); end

  class << self
    # source://rubocop//lib/rubocop/cop/util.rb#35
    def add_parentheses(node, corrector); end

    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/cop/util.rb#56
    def any_descendant?(node, *types); end

    # source://rubocop//lib/rubocop/cop/util.rb#71
    def args_begin(node); end

    # source://rubocop//lib/rubocop/cop/util.rb#83
    def args_end(node); end

    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/cop/util.rb#104
    def begins_its_line?(range); end

    # This is a bad API
    #
    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/cop/util.rb#17
    def comment_line?(line_source); end

    # @deprecated Use `ProcessedSource#line_with_comment?`, `contains_comment?` or similar
    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/cop/util.rb#22
    def comment_lines?(node); end

    # If converting a string to Ruby string literal source code, must
    # double quotes be used?
    #
    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/cop/util.rb#130
    def double_quotes_required?(string); end

    # source://rubocop//lib/rubocop/cop/util.rb#144
    def escape_string(string); end

    # Returns, for example, a bare `if` node if the given node is an `if`
    # with calls chained to the end of it.
    #
    # source://rubocop//lib/rubocop/cop/util.rb#114
    def first_part_of_call_chain(node); end

    # source://rubocop//lib/rubocop/cop/util.rb#179
    def indent(node, offset: T.unsafe(nil)); end

    # source://rubocop//lib/rubocop/cop/util.rb#161
    def interpret_string_escapes(string); end

    # source://rubocop//lib/rubocop/cop/util.rb#165
    def line(node_or_range); end

    # source://rubocop//lib/rubocop/cop/util.rb#26
    def line_range(node); end

    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/cop/util.rb#140
    def needs_escaping?(string); end

    # @yield [sexp]
    #
    # source://rubocop//lib/rubocop/cop/util.rb#87
    def on_node(syms, sexp, excludes = T.unsafe(nil), &block); end

    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/cop/util.rb#30
    def parentheses?(node); end

    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/cop/util.rb#173
    def same_line?(node1, node2); end

    # source://rubocop//lib/rubocop/cop/util.rb#148
    def to_string_literal(string); end

    # source://rubocop//lib/rubocop/cop/util.rb#185
    def to_supported_styles(enforced_style); end

    # source://rubocop//lib/rubocop/cop/util.rb#157
    def trim_string_interpolation_escape_character(str); end
  end
end

# source://rubocop//lib/rubocop/cop/util.rb#99
RuboCop::Cop::Util::LINE_BEGINS_REGEX_CACHE = T.let(T.unsafe(nil), Hash)

# Match literal regex characters, not including anchors, character
# classes, alternatives, groups, repetitions, references, etc
#
# source://rubocop//lib/rubocop/cop/util.rb#12
RuboCop::Cop::Util::LITERAL_REGEX = T.let(T.unsafe(nil), Regexp)

# Arbitrarily chosen value, should be enough to cover
# the most nested source code in real world projects.
#
# source://rubocop//lib/rubocop/cop/util.rb#98
RuboCop::Cop::Util::MAX_LINE_BEGINS_REGEX_INDEX = T.let(T.unsafe(nil), Integer)

# source://rubocop//lib/rubocop/cop/utils/format_string.rb#5
module RuboCop::Cop::Utils; end

# Parses {Kernel#sprintf} format strings.
#
# source://rubocop//lib/rubocop/cop/utils/format_string.rb#7
class RuboCop::Cop::Utils::FormatString
  # @return [FormatString] a new instance of FormatString
  #
  # source://rubocop//lib/rubocop/cop/utils/format_string.rb#89
  def initialize(string); end

  # source://rubocop//lib/rubocop/cop/utils/format_string.rb#93
  def format_sequences; end

  # source://rubocop//lib/rubocop/cop/utils/format_string.rb#105
  def max_digit_dollar_num; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/utils/format_string.rb#101
  def named_interpolation?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/utils/format_string.rb#97
  def valid?; end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/utils/format_string.rb#117
  def mixed_formats?; end

  # source://rubocop//lib/rubocop/cop/utils/format_string.rb#111
  def parse; end
end

# source://rubocop//lib/rubocop/cop/utils/format_string.rb#8
RuboCop::Cop::Utils::FormatString::DIGIT_DOLLAR = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/utils/format_string.rb#9
RuboCop::Cop::Utils::FormatString::FLAG = T.let(T.unsafe(nil), Regexp)

# The syntax of a format sequence is as follows.
#
# ```
# %[flags][width][.precision]type
# ```
#
# A format sequence consists of a percent sign, followed by optional
# flags, width, and precision indicators, then terminated with a field
# type character.
#
# For more complex formatting, Ruby supports a reference by name.
#
# @see https://ruby-doc.org/core-2.6.3/Kernel.html#method-i-format
#
# source://rubocop//lib/rubocop/cop/utils/format_string.rb#43
class RuboCop::Cop::Utils::FormatString::FormatSequence
  # @return [FormatSequence] a new instance of FormatSequence
  #
  # source://rubocop//lib/rubocop/cop/utils/format_string.rb#46
  def initialize(match); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/utils/format_string.rb#61
  def annotated?; end

  # Number of arguments required for the format sequence
  #
  # source://rubocop//lib/rubocop/cop/utils/format_string.rb#70
  def arity; end

  # Returns the value of attribute begin_pos.
  #
  # source://rubocop//lib/rubocop/cop/utils/format_string.rb#44
  def begin_pos; end

  # Returns the value of attribute end_pos.
  #
  # source://rubocop//lib/rubocop/cop/utils/format_string.rb#44
  def end_pos; end

  # Returns the value of attribute flags.
  #
  # source://rubocop//lib/rubocop/cop/utils/format_string.rb#44
  def flags; end

  # source://rubocop//lib/rubocop/cop/utils/format_string.rb#74
  def max_digit_dollar_num; end

  # Returns the value of attribute name.
  #
  # source://rubocop//lib/rubocop/cop/utils/format_string.rb#44
  def name; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/utils/format_string.rb#57
  def percent?; end

  # Returns the value of attribute precision.
  #
  # source://rubocop//lib/rubocop/cop/utils/format_string.rb#44
  def precision; end

  # source://rubocop//lib/rubocop/cop/utils/format_string.rb#78
  def style; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/utils/format_string.rb#65
  def template?; end

  # Returns the value of attribute type.
  #
  # source://rubocop//lib/rubocop/cop/utils/format_string.rb#44
  def type; end

  # Returns the value of attribute width.
  #
  # source://rubocop//lib/rubocop/cop/utils/format_string.rb#44
  def width; end
end

# source://rubocop//lib/rubocop/cop/utils/format_string.rb#15
RuboCop::Cop::Utils::FormatString::NAME = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/utils/format_string.rb#11
RuboCop::Cop::Utils::FormatString::NUMBER = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/utils/format_string.rb#10
RuboCop::Cop::Utils::FormatString::NUMBER_ARG = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/utils/format_string.rb#13
RuboCop::Cop::Utils::FormatString::PRECISION = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/utils/format_string.rb#18
RuboCop::Cop::Utils::FormatString::SEQUENCE = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/utils/format_string.rb#16
RuboCop::Cop::Utils::FormatString::TEMPLATE_NAME = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/utils/format_string.rb#14
RuboCop::Cop::Utils::FormatString::TYPE = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/cop/utils/format_string.rb#12
RuboCop::Cop::Utils::FormatString::WIDTH = T.let(T.unsafe(nil), Regexp)

# This force provides a way to track local variables and scopes of Ruby.
# Cops interact with this force need to override some of the hook methods.
#
#     def before_entering_scope(scope, variable_table)
#     end
#
#     def after_entering_scope(scope, variable_table)
#     end
#
#     def before_leaving_scope(scope, variable_table)
#     end
#
#     def after_leaving_scope(scope, variable_table)
#     end
#
#     def before_declaring_variable(variable, variable_table)
#     end
#
#     def after_declaring_variable(variable, variable_table)
#     end
#
# @api private
#
# source://rubocop//lib/rubocop/cop/variable_force.rb#27
class RuboCop::Cop::VariableForce < ::RuboCop::Cop::Force
  # Starting point.
  #
  # @api private
  #
  # source://rubocop//lib/rubocop/cop/variable_force.rb#75
  def investigate(processed_source); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/variable_force.rb#84
  def process_node(node); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/variable_force.rb#70
  def variable_table; end

  private

  # source://rubocop//lib/rubocop/cop/variable_force.rb#367
  def after_declaring_variable(arg); end

  # source://rubocop//lib/rubocop/cop/variable_force.rb#367
  def after_entering_scope(arg); end

  # source://rubocop//lib/rubocop/cop/variable_force.rb#367
  def after_leaving_scope(arg); end

  # source://rubocop//lib/rubocop/cop/variable_force.rb#367
  def before_declaring_variable(arg); end

  # source://rubocop//lib/rubocop/cop/variable_force.rb#367
  def before_entering_scope(arg); end

  # source://rubocop//lib/rubocop/cop/variable_force.rb#367
  def before_leaving_scope(arg); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/variable_force.rb#338
  def descendant_reference(node); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/variable_force.rb#328
  def each_descendant_reference(loop_node); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/variable_force.rb#313
  def find_variables_in_loop(loop_node); end

  # This is called for each scope recursively.
  #
  # @api private
  #
  # source://rubocop//lib/rubocop/cop/variable_force.rb#93
  def inspect_variables_in_scope(scope_node); end

  # Mark all assignments which are referenced in the same loop
  # as referenced by ignoring AST order since they would be referenced
  # in next iteration.
  #
  # @api private
  #
  # source://rubocop//lib/rubocop/cop/variable_force.rb#294
  def mark_assignments_as_referenced_in_loop(node); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/variable_force.rb#125
  def node_handler_method_name(node); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/variable_force.rb#99
  def process_children(origin_node); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/variable_force.rb#230
  def process_loop(node); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/variable_force.rb#159
  def process_regexp_named_captures(node); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/variable_force.rb#245
  def process_rescue(node); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/variable_force.rb#264
  def process_scope(node); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/variable_force.rb#283
  def process_send(node); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/variable_force.rb#141
  def process_variable_assignment(node); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/variable_force.rb#129
  def process_variable_declaration(node); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/variable_force.rb#218
  def process_variable_multiple_assignment(node); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/variable_force.rb#183
  def process_variable_operator_assignment(node); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/variable_force.rb#225
  def process_variable_referencing(node); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/variable_force.rb#256
  def process_zero_arity_super(node); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/variable_force.rb#177
  def regexp_captured_names(node); end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force.rb#350
  def scanned_node?(node); end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/variable_force.rb#354
  def scanned_nodes; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/variable_force.rb#107
  def skip_children!; end

  # @api private
  #
  # source://rubocop//lib/rubocop/cop/variable_force.rb#277
  def twisted_nodes(node); end
end

# @api private
#
# source://rubocop//lib/rubocop/cop/variable_force.rb#32
RuboCop::Cop::VariableForce::ARGUMENT_DECLARATION_TYPES = T.let(T.unsafe(nil), Array)

# This class represents each assignment of a variable.
#
# source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#7
class RuboCop::Cop::VariableForce::Assignment
  include ::RuboCop::Cop::VariableForce::Branchable

  # @return [Assignment] a new instance of Assignment
  #
  # source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#16
  def initialize(node, variable); end

  # source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#67
  def meta_assignment_node; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#56
  def multiple_assignment?; end

  # source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#29
  def name; end

  # Returns the value of attribute node.
  #
  # source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#12
  def node; end

  # source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#62
  def operator; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#50
  def operator_assignment?; end

  # source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#37
  def reference!(node); end

  # Returns the value of attribute referenced.
  #
  # source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#12
  def referenced; end

  # Returns the value of attribute referenced.
  #
  # source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#12
  def referenced?; end

  # Returns the value of attribute references.
  #
  # source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#12
  def references; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#46
  def regexp_named_capture?; end

  # source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#33
  def scope; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#42
  def used?; end

  # Returns the value of attribute variable.
  #
  # source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#12
  def variable; end

  private

  # source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#85
  def multiple_assignment_node; end

  # source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#77
  def operator_assignment_node; end
end

# source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#10
RuboCop::Cop::VariableForce::Assignment::MULTIPLE_LEFT_HAND_SIDE_TYPE = T.let(T.unsafe(nil), Symbol)

# @api private
#
# source://rubocop//lib/rubocop/cop/variable_force.rb#64
class RuboCop::Cop::VariableForce::AssignmentReference < ::Struct
  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force.rb#65
  def assignment?; end

  # Returns the value of attribute node
  #
  # @return [Object] the current value of node
  def node; end

  # Sets the attribute node
  #
  # @param value [Object] the value to set the attribute node to.
  # @return [Object] the newly set value
  def node=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# Namespace for branch classes for each control structure.
#
# source://rubocop//lib/rubocop/cop/variable_force/branch.rb#7
module RuboCop::Cop::VariableForce::Branch
  class << self
    # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#8
    def of(target_node, scope: T.unsafe(nil)); end
  end
end

# left_body && right_body
#
# source://rubocop//lib/rubocop/cop/variable_force/branch.rb#265
class RuboCop::Cop::VariableForce::Branch::And < ::RuboCop::Cop::VariableForce::Branch::Base
  include ::RuboCop::Cop::VariableForce::Branch::LogicalOperator

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57
  def left_body?; end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57
  def right_body?; end
end

# Abstract base class for branch classes.
# A branch represents a conditional branch in a scope.
#
# @example
#   def some_scope
#   do_something     # no branch
#
#   if foo
#   do_something   # branch A
#   do_something   # branch A
#   else
#   do_something   # branch B
#   if bar
#   do_something # branch C (whose parent is branch B)
#   end
#   end
#
#   do_something     # no branch
#   end
#
# source://rubocop//lib/rubocop/cop/variable_force/branch.rb#42
class RuboCop::Cop::VariableForce::Branch::Base < ::Struct
  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#121
  def ==(other); end

  # @raise [NotImplementedError]
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#92
  def always_run?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#88
  def branched?; end

  # Returns the value of attribute child_node
  #
  # @return [Object] the current value of child_node
  def child_node; end

  # Sets the attribute child_node
  #
  # @param value [Object] the value to set the attribute child_node to.
  # @return [Object] the newly set value
  def child_node=(_); end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#70
  def control_node; end

  # @yield [_self]
  # @yieldparam _self [RuboCop::Cop::VariableForce::Branch::Base] the object that the method was called on
  #
  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#80
  def each_ancestor(include_self: T.unsafe(nil), &block); end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#121
  def eql?(other); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#104
  def exclusive_with?(other); end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#129
  def hash; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#96
  def may_jump_to_other_branch?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#100
  def may_run_incompletely?; end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#74
  def parent; end

  # Returns the value of attribute scope
  #
  # @return [Object] the current value of scope
  def scope; end

  # Sets the attribute scope
  #
  # @param value [Object] the value to set the attribute scope to.
  # @return [Object] the newly set value
  def scope=(_); end

  private

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#135
  def scan_ancestors; end

  class << self
    def [](*_arg0); end

    # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#43
    def classes; end

    # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#56
    def define_predicate(name, child_index: T.unsafe(nil)); end

    # @private
    #
    # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#47
    def inherited(subclass); end

    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end

    # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#52
    def type; end
  end
end

# source://rubocop//lib/rubocop/cop/variable_force/branch.rb#325
RuboCop::Cop::VariableForce::Branch::CLASSES_BY_TYPE = T.let(T.unsafe(nil), Hash)

# case target
# when /pattern/ # when_clause
# else
#   else_body
# end
#
# source://rubocop//lib/rubocop/cop/variable_force/branch.rb#219
class RuboCop::Cop::VariableForce::Branch::Case < ::RuboCop::Cop::VariableForce::Branch::Base
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#224
  def always_run?; end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57
  def else_body?; end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57
  def target?; end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57
  def when_clause?; end
end

# case target
# in pattern # in_pattern
# else
#   else_body
# end
#
# source://rubocop//lib/rubocop/cop/variable_force/branch.rb#234
class RuboCop::Cop::VariableForce::Branch::CaseMatch < ::RuboCop::Cop::VariableForce::Branch::Base
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#239
  def always_run?; end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57
  def else_body?; end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57
  def in_pattern?; end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57
  def target?; end
end

# begin
#     main_body
#   ensure
#     ensure_body
#   end
#
# source://rubocop//lib/rubocop/cop/variable_force/branch.rb#314
class RuboCop::Cop::VariableForce::Branch::Ensure < ::RuboCop::Cop::VariableForce::Branch::Base
  include ::RuboCop::Cop::VariableForce::Branch::ExceptionHandler

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#320
  def always_run?; end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57
  def ensure_body?; end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57
  def main_body?; end
end

# Mix-in module for exception handling control structures.
#
# source://rubocop//lib/rubocop/cop/variable_force/branch.rb#281
module RuboCop::Cop::VariableForce::Branch::ExceptionHandler
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#282
  def may_jump_to_other_branch?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#286
  def may_run_incompletely?; end
end

# for element in collection
#   loop_body
# end
#
# source://rubocop//lib/rubocop/cop/variable_force/branch.rb#247
class RuboCop::Cop::VariableForce::Branch::For < ::RuboCop::Cop::VariableForce::Branch::Base
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#252
  def always_run?; end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57
  def collection?; end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57
  def element?; end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57
  def loop_body?; end
end

# if conditional_clause
#   truthy_body
# else
#   falsey_body
# end
#
# unless conditional_clause
#   falsey_body
# else
#   truthy_body
# end
#
# source://rubocop//lib/rubocop/cop/variable_force/branch.rb#166
class RuboCop::Cop::VariableForce::Branch::If < ::RuboCop::Cop::VariableForce::Branch::Base
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57
  def conditional_clause?; end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57
  def falsey_body?; end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57
  def truthy_body?; end
end

# Mix-in module for logical operator control structures.
#
# source://rubocop//lib/rubocop/cop/variable_force/branch.rb#258
module RuboCop::Cop::VariableForce::Branch::LogicalOperator
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#259
  def always_run?; end
end

# left_body || right_body
#
# source://rubocop//lib/rubocop/cop/variable_force/branch.rb#273
class RuboCop::Cop::VariableForce::Branch::Or < ::RuboCop::Cop::VariableForce::Branch::Base
  include ::RuboCop::Cop::VariableForce::Branch::LogicalOperator

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57
  def left_body?; end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57
  def right_body?; end
end

# begin
#     main_body
#   rescue StandardError => error # rescue_clause
#   else
#     else_body
#   end
#
# source://rubocop//lib/rubocop/cop/variable_force/branch.rb#297
class RuboCop::Cop::VariableForce::Branch::Rescue < ::RuboCop::Cop::VariableForce::Branch::Base
  include ::RuboCop::Cop::VariableForce::Branch::ExceptionHandler

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#304
  def always_run?; end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57
  def else_body?; end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57
  def main_body?; end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57
  def rescue_clause?; end
end

# Mix-in module for simple conditional control structures.
#
# source://rubocop//lib/rubocop/cop/variable_force/branch.rb#145
module RuboCop::Cop::VariableForce::Branch::SimpleConditional
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#150
  def always_run?; end

  # @raise [NotImplementedError]
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#146
  def conditional_clause?; end
end

# until conditional_clause
#   loop_body
# end
#
# source://rubocop//lib/rubocop/cop/variable_force/branch.rb#187
class RuboCop::Cop::VariableForce::Branch::Until < ::RuboCop::Cop::VariableForce::Branch::Base
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57
  def conditional_clause?; end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57
  def loop_body?; end
end

# begin
#   loop_body
# end until conditional_clause
#
# source://rubocop//lib/rubocop/cop/variable_force/branch.rb#207
class RuboCop::Cop::VariableForce::Branch::UntilPost < ::RuboCop::Cop::VariableForce::Branch::Base
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57
  def conditional_clause?; end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57
  def loop_body?; end
end

# while conditional_clause
#   loop_body
# end
#
# source://rubocop//lib/rubocop/cop/variable_force/branch.rb#177
class RuboCop::Cop::VariableForce::Branch::While < ::RuboCop::Cop::VariableForce::Branch::Base
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57
  def conditional_clause?; end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57
  def loop_body?; end
end

# begin
#   loop_body
# end while conditional_clause
#
# source://rubocop//lib/rubocop/cop/variable_force/branch.rb#197
class RuboCop::Cop::VariableForce::Branch::WhilePost < ::RuboCop::Cop::VariableForce::Branch::Base
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57
  def conditional_clause?; end

  # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57
  def loop_body?; end
end

# Mix-in module for classes which own a node and need branch information
# of the node. The user classes must implement #node and #scope.
#
# source://rubocop//lib/rubocop/cop/variable_force/branchable.rb#8
module RuboCop::Cop::VariableForce::Branchable
  # source://rubocop//lib/rubocop/cop/variable_force/branchable.rb#9
  def branch; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/branchable.rb#15
  def run_exclusively_with?(other); end
end

# @api private
#
# source://rubocop//lib/rubocop/cop/variable_force.rb#39
RuboCop::Cop::VariableForce::LOGICAL_OPERATOR_ASSIGNMENT_TYPES = T.let(T.unsafe(nil), Array)

# @api private
#
# source://rubocop//lib/rubocop/cop/variable_force.rb#47
RuboCop::Cop::VariableForce::LOOP_TYPES = T.let(T.unsafe(nil), Array)

# @api private
#
# source://rubocop//lib/rubocop/cop/variable_force.rb#42
RuboCop::Cop::VariableForce::MULTIPLE_ASSIGNMENT_TYPE = T.let(T.unsafe(nil), Symbol)

# @api private
#
# source://rubocop//lib/rubocop/cop/variable_force.rb#111
RuboCop::Cop::VariableForce::NODE_HANDLER_METHOD_NAMES = T.let(T.unsafe(nil), Hash)

# @api private
#
# source://rubocop//lib/rubocop/cop/variable_force.rb#40
RuboCop::Cop::VariableForce::OPERATOR_ASSIGNMENT_TYPES = T.let(T.unsafe(nil), Array)

# @api private
#
# source://rubocop//lib/rubocop/cop/variable_force.rb#46
RuboCop::Cop::VariableForce::POST_CONDITION_LOOP_TYPES = T.let(T.unsafe(nil), Array)

# @api private
#
# source://rubocop//lib/rubocop/cop/variable_force.rb#29
RuboCop::Cop::VariableForce::REGEXP_NAMED_CAPTURE_TYPE = T.let(T.unsafe(nil), Symbol)

# @api private
#
# source://rubocop//lib/rubocop/cop/variable_force.rb#49
RuboCop::Cop::VariableForce::RESCUE_TYPE = T.let(T.unsafe(nil), Symbol)

# This class represents each reference of a variable.
#
# source://rubocop//lib/rubocop/cop/variable_force/reference.rb#7
class RuboCop::Cop::VariableForce::Reference
  include ::RuboCop::Cop::VariableForce::Branchable

  # @return [Reference] a new instance of Reference
  #
  # source://rubocop//lib/rubocop/cop/variable_force/reference.rb#16
  def initialize(node, scope); end

  # There's an implicit variable reference by the zero-arity `super`:
  #
  #     def some_method(foo)
  #       super
  #     end
  #
  # Another case is `binding`:
  #
  #     def some_method(foo)
  #       do_something(binding)
  #     end
  #
  # In these cases, the variable `foo` is not explicitly referenced,
  # but it can be considered used implicitly by the `super` or `binding`.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/reference.rb#41
  def explicit?; end

  # Returns the value of attribute node.
  #
  # source://rubocop//lib/rubocop/cop/variable_force/reference.rb#14
  def node; end

  # Returns the value of attribute scope.
  #
  # source://rubocop//lib/rubocop/cop/variable_force/reference.rb#14
  def scope; end
end

# source://rubocop//lib/rubocop/cop/variable_force/reference.rb#10
RuboCop::Cop::VariableForce::Reference::VARIABLE_REFERENCE_TYPES = T.let(T.unsafe(nil), Array)

# @api private
#
# source://rubocop//lib/rubocop/cop/variable_force.rb#54
RuboCop::Cop::VariableForce::SCOPE_TYPES = T.let(T.unsafe(nil), Array)

# @api private
#
# source://rubocop//lib/rubocop/cop/variable_force.rb#56
RuboCop::Cop::VariableForce::SEND_TYPE = T.let(T.unsafe(nil), Symbol)

# A Scope represents a context of local variable visibility.
# This is a place where local variables belong to.
# A scope instance holds a scope node and variable entries.
#
# source://rubocop//lib/rubocop/cop/variable_force/scope.rb#9
class RuboCop::Cop::VariableForce::Scope
  # @return [Scope] a new instance of Scope
  #
  # source://rubocop//lib/rubocop/cop/variable_force/scope.rb#22
  def initialize(node); end

  # source://rubocop//lib/rubocop/cop/variable_force/scope.rb#35
  def ==(other); end

  # source://rubocop//lib/rubocop/cop/variable_force/scope.rb#43
  def body_node; end

  # @yield [node]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/scope.rb#61
  def each_node(&block); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/scope.rb#57
  def include?(target_node); end

  # Returns the value of attribute naked_top_level.
  #
  # source://rubocop//lib/rubocop/cop/variable_force/scope.rb#18
  def naked_top_level; end

  # Returns the value of attribute naked_top_level.
  #
  # source://rubocop//lib/rubocop/cop/variable_force/scope.rb#18
  def naked_top_level?; end

  # source://rubocop//lib/rubocop/cop/variable_force/scope.rb#39
  def name; end

  # Returns the value of attribute node.
  #
  # source://rubocop//lib/rubocop/cop/variable_force/scope.rb#18
  def node; end

  # Returns the value of attribute variables.
  #
  # source://rubocop//lib/rubocop/cop/variable_force/scope.rb#18
  def variables; end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/scope.rb#100
  def ancestor_node?(target_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/scope.rb#90
  def belong_to_inner_scope?(target_node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/scope.rb#79
  def belong_to_outer_scope?(target_node); end

  # source://rubocop//lib/rubocop/cop/variable_force/scope.rb#70
  def scan_node(node, &block); end
end

# source://rubocop//lib/rubocop/cop/variable_force/scope.rb#10
RuboCop::Cop::VariableForce::Scope::OUTER_SCOPE_CHILD_INDICES = T.let(T.unsafe(nil), Hash)

# @api private
#
# source://rubocop//lib/rubocop/cop/variable_force.rb#53
RuboCop::Cop::VariableForce::TWISTED_SCOPE_TYPES = T.let(T.unsafe(nil), Array)

# @api private
#
# source://rubocop//lib/rubocop/cop/variable_force.rb#28
RuboCop::Cop::VariableForce::VARIABLE_ASSIGNMENT_TYPE = T.let(T.unsafe(nil), Symbol)

# @api private
#
# source://rubocop//lib/rubocop/cop/variable_force.rb#30
RuboCop::Cop::VariableForce::VARIABLE_ASSIGNMENT_TYPES = T.let(T.unsafe(nil), Array)

# @api private
#
# source://rubocop//lib/rubocop/cop/variable_force.rb#44
RuboCop::Cop::VariableForce::VARIABLE_REFERENCE_TYPE = T.let(T.unsafe(nil), Symbol)

# A Variable represents existence of a local variable.
# This holds a variable declaration node and some states of the variable.
#
# source://rubocop//lib/rubocop/cop/variable_force/variable.rb#8
class RuboCop::Cop::VariableForce::Variable
  # @return [Variable] a new instance of Variable
  #
  # source://rubocop//lib/rubocop/cop/variable_force/variable.rb#15
  def initialize(name, declaration_node, scope); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/variable.rb#94
  def argument?; end

  # source://rubocop//lib/rubocop/cop/variable_force/variable.rb#31
  def assign(node); end

  # Returns the value of attribute assignments.
  #
  # source://rubocop//lib/rubocop/cop/variable_force/variable.rb#11
  def assignments; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/variable.rb#102
  def block_argument?; end

  # source://rubocop//lib/rubocop/cop/variable_force/variable.rb#74
  def capture_with_block!; end

  # Returns the value of attribute captured_by_block.
  #
  # source://rubocop//lib/rubocop/cop/variable_force/variable.rb#11
  def captured_by_block; end

  # Returns the value of attribute captured_by_block.
  #
  # source://rubocop//lib/rubocop/cop/variable_force/variable.rb#11
  def captured_by_block?; end

  # Returns the value of attribute declaration_node.
  #
  # source://rubocop//lib/rubocop/cop/variable_force/variable.rb#11
  def declaration_node; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/variable.rb#110
  def explicit_block_local_variable?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/variable.rb#66
  def in_modifier_conditional?(assignment); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/variable.rb#106
  def keyword_argument?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/variable.rb#98
  def method_argument?; end

  # Returns the value of attribute name.
  #
  # source://rubocop//lib/rubocop/cop/variable_force/variable.rb#11
  def name; end

  # source://rubocop//lib/rubocop/cop/variable_force/variable.rb#40
  def reference!(node); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/variable.rb#35
  def referenced?; end

  # Returns the value of attribute references.
  #
  # source://rubocop//lib/rubocop/cop/variable_force/variable.rb#11
  def references; end

  # Returns the value of attribute scope.
  #
  # source://rubocop//lib/rubocop/cop/variable_force/variable.rb#11
  def scope; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/variable.rb#90
  def should_be_unused?; end

  # This is a convenient way to check whether the variable is used
  # in its entire variable lifetime.
  # For more precise usage check, refer Assignment#used?.
  #
  # Once the variable is captured by a block, we have no idea
  # when, where, and how many times the block would be invoked.
  # This means we cannot track the usage of the variable.
  # So we consider it's used to suppress false positive offenses.
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/variable.rb#86
  def used?; end
end

# source://rubocop//lib/rubocop/cop/variable_force/variable.rb#9
RuboCop::Cop::VariableForce::Variable::VARIABLE_DECLARATION_TYPES = T.let(T.unsafe(nil), Array)

# @api private
#
# source://rubocop//lib/rubocop/cop/variable_force.rb#58
class RuboCop::Cop::VariableForce::VariableReference < ::Struct
  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force.rb#59
  def assignment?; end

  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  def name; end

  # Sets the attribute name
  #
  # @param value [Object] the value to set the attribute name to.
  # @return [Object] the newly set value
  def name=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# A VariableTable manages the lifetime of all scopes and local variables
# in a program.
# This holds scopes as stack structure, provides a way to add local
# variables to current scope, and find local variables by considering
# variable visibility of the current scope.
#
# source://rubocop//lib/rubocop/cop/variable_force/variable_table.rb#11
class RuboCop::Cop::VariableForce::VariableTable
  # @return [VariableTable] a new instance of VariableTable
  #
  # source://rubocop//lib/rubocop/cop/variable_force/variable_table.rb#12
  def initialize(hook_receiver = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/variable_force/variable_table.rb#113
  def accessible_variables; end

  # source://rubocop//lib/rubocop/cop/variable_force/variable_table.rb#56
  def assign_to_variable(name, node); end

  # source://rubocop//lib/rubocop/cop/variable_force/variable_table.rb#40
  def current_scope; end

  # source://rubocop//lib/rubocop/cop/variable_force/variable_table.rb#44
  def current_scope_level; end

  # source://rubocop//lib/rubocop/cop/variable_force/variable_table.rb#48
  def declare_variable(name, node); end

  # source://rubocop//lib/rubocop/cop/variable_force/variable_table.rb#94
  def find_variable(name); end

  # source://rubocop//lib/rubocop/cop/variable_force/variable_table.rb#16
  def invoke_hook(hook_name, *args); end

  # source://rubocop//lib/rubocop/cop/variable_force/variable_table.rb#32
  def pop_scope; end

  # source://rubocop//lib/rubocop/cop/variable_force/variable_table.rb#24
  def push_scope(scope_node); end

  # source://rubocop//lib/rubocop/cop/variable_force/variable_table.rb#68
  def reference_variable(name, node); end

  # source://rubocop//lib/rubocop/cop/variable_force/variable_table.rb#20
  def scope_stack; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/cop/variable_force/variable_table.rb#109
  def variable_exist?(name); end

  private

  # source://rubocop//lib/rubocop/cop/variable_force/variable_table.rb#122
  def mark_variable_as_captured_by_block_if_so(variable); end
end

# @api private
#
# source://rubocop//lib/rubocop/cop/variable_force.rb#51
RuboCop::Cop::VariableForce::ZERO_ARITY_SUPER_TYPE = T.let(T.unsafe(nil), Symbol)

# Help methods for determining node visibility.
#
# source://rubocop//lib/rubocop/cop/mixin/visibility_help.rb#8
module RuboCop::Cop::VisibilityHelp
  extend ::RuboCop::AST::NodePattern::Macros

  # source://rubocop//lib/rubocop/cop/mixin/visibility_help.rb#57
  def visibility_block?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/mixin/visibility_help.rb#62
  def visibility_inline_on_def?(param0 = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/cop/mixin/visibility_help.rb#67
  def visibility_inline_on_method_name?(param0 = T.unsafe(nil), method_name:); end

  private

  # Navigate to find the last protected method
  #
  # source://rubocop//lib/rubocop/cop/mixin/visibility_help.rb#48
  def find_visibility_end(node); end

  # source://rubocop//lib/rubocop/cop/mixin/visibility_help.rb#43
  def find_visibility_start(node); end

  # source://rubocop//lib/rubocop/cop/mixin/visibility_help.rb#15
  def node_visibility(node); end

  # source://rubocop//lib/rubocop/cop/mixin/visibility_help.rb#39
  def node_visibility_from_visibility_block(node); end

  # source://rubocop//lib/rubocop/cop/mixin/visibility_help.rb#21
  def node_visibility_from_visibility_inline(node); end

  # source://rubocop//lib/rubocop/cop/mixin/visibility_help.rb#28
  def node_visibility_from_visibility_inline_on_def(node); end

  # source://rubocop//lib/rubocop/cop/mixin/visibility_help.rb#33
  def node_visibility_from_visibility_inline_on_method_name(node); end
end

# source://rubocop//lib/rubocop/cop/mixin/visibility_help.rb#11
RuboCop::Cop::VisibilityHelp::VISIBILITY_SCOPES = T.let(T.unsafe(nil), Set)

# This class wraps the `Parser::Source::Comment` object that represents a
# cops it contains.
#
# source://rubocop//lib/rubocop/directive_comment.rb#7
class RuboCop::DirectiveComment
  # @return [DirectiveComment] a new instance of DirectiveComment
  #
  # source://rubocop//lib/rubocop/directive_comment.rb#30
  def initialize(comment, cop_registry = T.unsafe(nil)); end

  # Checks if all cops specified in this directive
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/directive_comment.rb#80
  def all_cops?; end

  # Returns the value of attribute comment.
  #
  # source://rubocop//lib/rubocop/directive_comment.rb#28
  def comment; end

  # Returns array of specified in this directive cop names
  #
  # source://rubocop//lib/rubocop/directive_comment.rb#85
  def cop_names; end

  # Returns the value of attribute cop_registry.
  #
  # source://rubocop//lib/rubocop/directive_comment.rb#28
  def cop_registry; end

  # Returns the value of attribute cops.
  #
  # source://rubocop//lib/rubocop/directive_comment.rb#28
  def cops; end

  # Returns array of specified in this directive department names
  # when all department disabled
  #
  # source://rubocop//lib/rubocop/directive_comment.rb#91
  def department_names; end

  # source://rubocop//lib/rubocop/directive_comment.rb#105
  def directive_count; end

  # Checks if this directive disables cops
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/directive_comment.rb#60
  def disabled?; end

  # Checks if this directive disables all cops
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/directive_comment.rb#75
  def disabled_all?; end

  # Checks if this directive enables cops
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/directive_comment.rb#65
  def enabled?; end

  # Checks if this directive enables all cops
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/directive_comment.rb#70
  def enabled_all?; end

  # Checks if directive departments include cop
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/directive_comment.rb#96
  def in_directive_department?(cop); end

  # Returns line number for directive
  #
  # source://rubocop//lib/rubocop/directive_comment.rb#110
  def line_number; end

  # Checks if this directive contains all the given cop names
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/directive_comment.rb#42
  def match?(cop_names); end

  # Returns match captures to directive comment pattern
  #
  # source://rubocop//lib/rubocop/directive_comment.rb#55
  def match_captures; end

  # Returns the value of attribute mode.
  #
  # source://rubocop//lib/rubocop/directive_comment.rb#28
  def mode; end

  # Checks if cop department has already used in directive comment
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/directive_comment.rb#101
  def overridden_by_department?(cop); end

  # source://rubocop//lib/rubocop/directive_comment.rb#46
  def range; end

  # Checks if this directive relates to single line
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/directive_comment.rb#37
  def single_line?; end

  private

  # source://rubocop//lib/rubocop/directive_comment.rb#130
  def all_cop_names; end

  # source://rubocop//lib/rubocop/directive_comment.rb#134
  def cop_names_for_department(department); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/directive_comment.rb#126
  def department?(name); end

  # source://rubocop//lib/rubocop/directive_comment.rb#140
  def exclude_redundant_directive_cop(cops); end

  # source://rubocop//lib/rubocop/directive_comment.rb#120
  def parsed_cop_names; end

  # source://rubocop//lib/rubocop/directive_comment.rb#116
  def splitted_cops_string; end

  class << self
    # source://rubocop//lib/rubocop/directive_comment.rb#24
    def before_comment(line); end
  end
end

# @api private
#
# source://rubocop//lib/rubocop/directive_comment.rb#17
RuboCop::DirectiveComment::COPS_PATTERN = T.let(T.unsafe(nil), String)

# @api private
#
# source://rubocop//lib/rubocop/directive_comment.rb#15
RuboCop::DirectiveComment::COP_NAMES_PATTERN = T.let(T.unsafe(nil), String)

# @api private
#
# source://rubocop//lib/rubocop/directive_comment.rb#13
RuboCop::DirectiveComment::COP_NAME_PATTERN = T.let(T.unsafe(nil), String)

# @api private
#
# source://rubocop//lib/rubocop/directive_comment.rb#19
RuboCop::DirectiveComment::DIRECTIVE_COMMENT_REGEXP = T.let(T.unsafe(nil), Regexp)

# @api private
#
# source://rubocop//lib/rubocop/directive_comment.rb#11
RuboCop::DirectiveComment::REDUNDANT_DIRECTIVE_COP = T.let(T.unsafe(nil), String)

# @api private
#
# source://rubocop//lib/rubocop/directive_comment.rb#9
RuboCop::DirectiveComment::REDUNDANT_DIRECTIVE_COP_DEPARTMENT = T.let(T.unsafe(nil), String)

# An Error exception is different from an Offense with severity 'error'
# When this exception is raised, it means that RuboCop is unable to perform
# a requested action (probably due to misconfiguration) and must stop
# immediately, rather than carrying on
#
# source://rubocop//lib/rubocop/error.rb#8
class RuboCop::Error < ::StandardError; end

# A wrapper to display errored location of analyzed file.
#
# source://rubocop//lib/rubocop/error.rb#13
class RuboCop::ErrorWithAnalyzedFileLocation < ::RuboCop::Error
  # @return [ErrorWithAnalyzedFileLocation] a new instance of ErrorWithAnalyzedFileLocation
  #
  # source://rubocop//lib/rubocop/error.rb#14
  def initialize(cause:, node:, cop:); end

  # Returns the value of attribute cause.
  #
  # source://rubocop//lib/rubocop/error.rb#21
  def cause; end

  # source://rubocop//lib/rubocop/error.rb#27
  def column; end

  # Returns the value of attribute cop.
  #
  # source://rubocop//lib/rubocop/error.rb#21
  def cop; end

  # source://rubocop//lib/rubocop/error.rb#23
  def line; end

  # source://rubocop//lib/rubocop/error.rb#31
  def message; end
end

# Allows specified configuration options to have an exclude limit
# ie. a maximum value tracked that it can be used by `--auto-gen-config`.
#
# source://rubocop//lib/rubocop/cop/exclude_limit.rb#6
module RuboCop::ExcludeLimit
  # Sets up a configuration option to have an exclude limit tracked.
  # The parameter name given is transformed into a method name (eg. `Max`
  # becomes `self.max=` and `MinDigits` becomes `self.min_digits=`).
  #
  # source://rubocop//lib/rubocop/cop/exclude_limit.rb#10
  def exclude_limit(parameter_name, method_name: T.unsafe(nil)); end

  private

  # source://rubocop//lib/rubocop/cop/exclude_limit.rb#22
  def transform(parameter_name); end
end

# source://rubocop//lib/rubocop/ext/comment.rb#4
module RuboCop::Ext; end

# Extensions to `Parser::Source::Comment`.
#
# source://rubocop//lib/rubocop/ext/comment.rb#6
module RuboCop::Ext::Comment
  # source://rubocop//lib/rubocop/ext/comment.rb#7
  def source; end

  # source://rubocop//lib/rubocop/ext/comment.rb#11
  def source_range; end
end

# Extensions to AST::ProcessedSource for our cached comment_config
#
# source://rubocop//lib/rubocop/ext/processed_source.rb#6
module RuboCop::Ext::ProcessedSource
  # source://rubocop//lib/rubocop/ext/processed_source.rb#9
  def comment_config; end

  # Returns the value of attribute config.
  #
  # source://rubocop//lib/rubocop/ext/processed_source.rb#7
  def config; end

  # Sets the attribute config
  #
  # @param value the value to set the attribute config to.
  #
  # source://rubocop//lib/rubocop/ext/processed_source.rb#7
  def config=(_arg0); end

  # source://rubocop//lib/rubocop/ext/processed_source.rb#13
  def disabled_line_ranges; end

  # Returns the value of attribute registry.
  #
  # source://rubocop//lib/rubocop/ext/processed_source.rb#7
  def registry; end

  # Sets the attribute registry
  #
  # @param value the value to set the attribute registry to.
  #
  # source://rubocop//lib/rubocop/ext/processed_source.rb#7
  def registry=(_arg0); end
end

# Extensions to Parser::Source::Range
#
# source://rubocop//lib/rubocop/ext/range.rb#6
module RuboCop::Ext::Range
  # Adds `Range#single_line?` to parallel `Node#single_line?`
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/ext/range.rb#8
  def single_line?; end
end

# Extensions to AST::RegexpNode for our cached parsed regexp info
#
# source://rubocop//lib/rubocop/ext/regexp_node.rb#6
module RuboCop::Ext::RegexpNode
  # Please remove this `else` branch when support for regexp_parser 1.8 will be dropped.
  # It's for compatibility with regexp_parser 1.8 and will never be maintained.
  #
  # source://rubocop//lib/rubocop/ext/regexp_node.rb#19
  def assign_properties(*_arg0); end

  # source://rubocop//lib/rubocop/ext/regexp_node.rb#53
  def each_capture(named: T.unsafe(nil)); end

  # Note: we extend Regexp nodes to provide `loc` and `expression`
  # see `ext/regexp_parser`.
  #
  # @return [Regexp::Expression::Root, nil]
  #
  # source://rubocop//lib/rubocop/ext/regexp_node.rb#16
  def parsed_tree; end

  private

  # source://rubocop//lib/rubocop/ext/regexp_node.rb#68
  def with_interpolations_blanked; end
end

# source://rubocop//lib/rubocop/ext/regexp_node.rb#7
RuboCop::Ext::RegexpNode::ANY = T.let(T.unsafe(nil), Object)

# Extensions for `regexp_parser` gem
#
# source://rubocop//lib/rubocop/ext/regexp_parser.rb#6
module RuboCop::Ext::RegexpParser; end

# source://rubocop//lib/rubocop/ext/regexp_parser.rb#20
module RuboCop::Ext::RegexpParser::Expression; end

# Add `expression` and `loc` to all `regexp_parser` nodes
#
# source://rubocop//lib/rubocop/ext/regexp_parser.rb#22
module RuboCop::Ext::RegexpParser::Expression::Base
  # Shortcut to `loc.expression`
  #
  # source://rubocop//lib/rubocop/ext/regexp_parser.rb#27
  def expression; end

  # E.g.
  #     [a-z]{2,}
  #     ^^^^^^^^^ expression
  #          ^^^^ quantifier
  #     ^^^^^     body
  #     ^         begin
  #         ^     end
  #
  # Please open issue if you need other locations
  #
  # source://rubocop//lib/rubocop/ext/regexp_parser.rb#61
  def loc; end

  # Returns the value of attribute origin.
  #
  # source://rubocop//lib/rubocop/ext/regexp_parser.rb#23
  def origin; end

  # Sets the attribute origin
  #
  # @param value the value to set the attribute origin to.
  #
  # source://rubocop//lib/rubocop/ext/regexp_parser.rb#23
  def origin=(_arg0); end

  private

  # source://rubocop//lib/rubocop/ext/regexp_parser.rb#67
  def build_location; end
end

# Provide `CharacterSet` with `begin` and `end` locations.
#
# source://rubocop//lib/rubocop/ext/regexp_parser.rb#77
module RuboCop::Ext::RegexpParser::Expression::CharacterSet
  # source://rubocop//lib/rubocop/ext/regexp_parser.rb#78
  def build_location; end
end

# Source map for RegexpParser nodes
#
# source://rubocop//lib/rubocop/ext/regexp_parser.rb#8
class RuboCop::Ext::RegexpParser::Map < ::Parser::Source::Map
  # @return [Map] a new instance of Map
  #
  # source://rubocop//lib/rubocop/ext/regexp_parser.rb#11
  def initialize(expression, body:, quantifier: T.unsafe(nil), begin_l: T.unsafe(nil), end_l: T.unsafe(nil)); end

  # Returns the value of attribute begin.
  #
  # source://rubocop//lib/rubocop/ext/regexp_parser.rb#9
  def begin; end

  # Returns the value of attribute body.
  #
  # source://rubocop//lib/rubocop/ext/regexp_parser.rb#9
  def body; end

  # Returns the value of attribute end.
  #
  # source://rubocop//lib/rubocop/ext/regexp_parser.rb#9
  def end; end

  # Returns the value of attribute quantifier.
  #
  # source://rubocop//lib/rubocop/ext/regexp_parser.rb#9
  def quantifier; end
end

# This class handles loading files (a.k.a. features in Ruby) specified
# by `--require` command line option and `require` directive in the config.
#
# Normally, the given string is directly passed to `require`. If a string
# beginning with `.` is given, it is assumed to be relative to the given
# directory.
#
# If a string containing `-` is given, it will be used as is, but if we
# cannot find the file to load, we will replace `-` with `/` and try it
# again as when Bundler loads gems.
#
# @api private
#
# source://rubocop//lib/rubocop/feature_loader.rb#16
class RuboCop::FeatureLoader
  # @api private
  # @param config_directory_path [String]
  # @param feature [String]
  # @return [FeatureLoader] a new instance of FeatureLoader
  #
  # source://rubocop//lib/rubocop/feature_loader.rb#27
  def initialize(config_directory_path:, feature:); end

  # @api private
  #
  # source://rubocop//lib/rubocop/feature_loader.rb#32
  def load; end

  private

  # @api private
  # @return [String]
  #
  # source://rubocop//lib/rubocop/feature_loader.rb#55
  def namespaced_feature; end

  # @api private
  # @return [String]
  #
  # source://rubocop//lib/rubocop/feature_loader.rb#60
  def namespaced_target; end

  # @api private
  # @param [String]
  # @return [String]
  #
  # source://rubocop//lib/rubocop/feature_loader.rb#70
  def relative(feature); end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/feature_loader.rb#75
  def relative?; end

  # @api private
  # @param error [LoadError]
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/feature_loader.rb#81
  def seems_cannot_load_such_file_error?(error); end

  # @api private
  # @return [String]
  #
  # source://rubocop//lib/rubocop/feature_loader.rb#86
  def target; end

  class << self
    # @api private
    # @param config_directory_path [String]
    # @param feature [String]
    #
    # source://rubocop//lib/rubocop/feature_loader.rb#20
    def load(config_directory_path:, feature:); end
  end
end

# Common methods for finding files.
#
# @api private
#
# source://rubocop//lib/rubocop/file_finder.rb#8
module RuboCop::FileFinder
  # @api private
  #
  # source://rubocop//lib/rubocop/file_finder.rb#17
  def find_file_upwards(filename, start_dir, stop_dir = T.unsafe(nil)); end

  # @api private
  #
  # source://rubocop//lib/rubocop/file_finder.rb#24
  def find_last_file_upwards(filename, start_dir, stop_dir = T.unsafe(nil)); end

  private

  # @api private
  #
  # source://rubocop//lib/rubocop/file_finder.rb#32
  def traverse_files_upwards(filename, start_dir, stop_dir); end

  class << self
    # @api private
    #
    # source://rubocop//lib/rubocop/file_finder.rb#9
    def root_level=(level); end

    # @api private
    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/file_finder.rb#13
    def root_level?(path, stop_dir); end
  end
end

# A wrapper around patterns array to perform optimized search.
#
# For projects with a large set of rubocop todo files, most items in `Exclude`/`Include`
# are exact file names. It is wasteful to linearly check the list of patterns over and over
# to check if the file is relevant to the cop.
#
# This class partitions an array of patterns into a set of exact match strings and the rest
# of the patterns. This way we can firstly do a cheap check in the set and then proceed via
# the costly patterns check, if needed.
#
# @api private
#
# source://rubocop//lib/rubocop/file_patterns.rb#14
class RuboCop::FilePatterns
  # @api private
  # @return [FilePatterns] a new instance of FilePatterns
  #
  # source://rubocop//lib/rubocop/file_patterns.rb#21
  def initialize(patterns); end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/file_patterns.rb#27
  def match?(path); end

  private

  # @api private
  #
  # source://rubocop//lib/rubocop/file_patterns.rb#33
  def partition_patterns(patterns); end

  class << self
    # @api private
    #
    # source://rubocop//lib/rubocop/file_patterns.rb#17
    def from(patterns); end
  end
end

# The bootstrap module for formatter.
#
# source://rubocop//lib/rubocop/formatter.rb#5
module RuboCop::Formatter; end

# Does not show individual offenses in the console.
#
# source://rubocop//lib/rubocop/formatter/auto_gen_config_formatter.rb#6
class RuboCop::Formatter::AutoGenConfigFormatter < ::RuboCop::Formatter::ProgressFormatter
  # source://rubocop//lib/rubocop/formatter/auto_gen_config_formatter.rb#7
  def finished(inspected_files); end
end

# Abstract base class for formatter, implements all public API methods.
#
# ## Creating Custom Formatter
#
# You can create a custom formatter by subclassing
# `RuboCop::Formatter::BaseFormatter` and overriding some methods
# or by implementing all the methods by duck typing.
#
# ## Using Custom Formatter in Command Line
#
# You can tell RuboCop to use your custom formatter with a combination of
# `--format` and `--require` option.
# For example, when you have defined `MyCustomFormatter` in
# `./path/to/my_custom_formatter.rb`, you would type this command:
#
#     rubocop --require ./path/to/my_custom_formatter --format MyCustomFormatter
#
# Note: The path passed to `--require` is directly passed to
# `Kernel.require`.
# If your custom formatter file is not in `$LOAD_PATH`,
# you need to specify the path as relative path prefixed with `./`
# explicitly or absolute path.
#
# ## Method Invocation Order
#
# For example, when RuboCop inspects 2 files,
# the invocation order should be like this:
#
# * `#initialize`
# * `#started`
# * `#file_started`
# * `#file_finished`
# * `#file_started`
# * `#file_finished`
# * `#finished`
#
# source://rubocop//lib/rubocop/formatter/base_formatter.rb#41
class RuboCop::Formatter::BaseFormatter
  # @api public
  # @param output [IO] `$stdout` or opened file
  # @return [BaseFormatter] a new instance of BaseFormatter
  #
  # source://rubocop//lib/rubocop/formatter/base_formatter.rb#63
  def initialize(output, options = T.unsafe(nil)); end

  # Invoked at the end of inspecting each files.
  #
  # @api public
  # @param file [String] the file path
  # @param offenses [Array(RuboCop::Cop::Offense)] all detected offenses for the file
  # @return [void]
  # @see RuboCop::Cop::Offense
  #
  # source://rubocop//lib/rubocop/formatter/base_formatter.rb#104
  def file_finished(file, offenses); end

  # Invoked at the beginning of inspecting each files.
  #
  # @api public
  # @param file [String] the file path
  # @param options [Hash] file specific information, currently this is always empty.
  # @return [void]
  #
  # source://rubocop//lib/rubocop/formatter/base_formatter.rb#89
  def file_started(file, options); end

  # Invoked after all files are inspected or interrupted by user.
  #
  # @api public
  # @param inspected_files [Array(String)] the inspected file paths.
  #   This would be same as `target_files` passed to `#started`
  #   unless RuboCop is interrupted by user.
  # @return [void]
  #
  # source://rubocop//lib/rubocop/formatter/base_formatter.rb#116
  def finished(inspected_files); end

  # @api public
  # @return [Hash]
  #
  # source://rubocop//lib/rubocop/formatter/base_formatter.rb#57
  def options; end

  # @api public
  # @return [IO] the IO object passed to `#initialize`
  # @see #initialize
  #
  # source://rubocop//lib/rubocop/formatter/base_formatter.rb#50
  def output; end

  # Invoked once before any files are inspected.
  #
  # @api public
  # @param target_files [Array(String)] all target file paths to be inspected
  # @return [void]
  #
  # source://rubocop//lib/rubocop/formatter/base_formatter.rb#76
  def started(target_files); end
end

# This formatter formats report data in clang style.
# The precise location of the problem is shown together with the
# relevant source code.
#
# source://rubocop//lib/rubocop/formatter/clang_style_formatter.rb#8
class RuboCop::Formatter::ClangStyleFormatter < ::RuboCop::Formatter::SimpleTextFormatter
  # source://rubocop//lib/rubocop/formatter/clang_style_formatter.rb#11
  def report_file(file, offenses); end

  private

  # source://rubocop//lib/rubocop/formatter/clang_style_formatter.rb#51
  def report_highlighted_area(highlighted_area); end

  # source://rubocop//lib/rubocop/formatter/clang_style_formatter.rb#41
  def report_line(location); end

  # source://rubocop//lib/rubocop/formatter/clang_style_formatter.rb#17
  def report_offense(file, offense); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/formatter/clang_style_formatter.rb#37
  def valid_line?(offense); end
end

# source://rubocop//lib/rubocop/formatter/clang_style_formatter.rb#9
RuboCop::Formatter::ClangStyleFormatter::ELLIPSES = T.let(T.unsafe(nil), String)

# This mix-in module provides string coloring methods for terminals.
# It automatically disables coloring if coloring is disabled in the process
# globally or the formatter's output is not a terminal.
#
# source://rubocop//lib/rubocop/formatter/colorizable.rb#8
module RuboCop::Formatter::Colorizable
  # source://rubocop//lib/rubocop/formatter/colorizable.rb#35
  def black(string); end

  # source://rubocop//lib/rubocop/formatter/colorizable.rb#35
  def blue(string); end

  # source://rubocop//lib/rubocop/formatter/colorizable.rb#21
  def colorize(string, *args); end

  # source://rubocop//lib/rubocop/formatter/colorizable.rb#35
  def cyan(string); end

  # source://rubocop//lib/rubocop/formatter/colorizable.rb#35
  def green(string); end

  # source://rubocop//lib/rubocop/formatter/colorizable.rb#35
  def magenta(string); end

  # source://rubocop//lib/rubocop/formatter/colorizable.rb#9
  def rainbow; end

  # source://rubocop//lib/rubocop/formatter/colorizable.rb#35
  def red(string); end

  # source://rubocop//lib/rubocop/formatter/colorizable.rb#35
  def white(string); end

  # source://rubocop//lib/rubocop/formatter/colorizable.rb#35
  def yellow(string); end
end

# This formatter displays a YAML configuration file where all cops that
# detected any offenses are configured to not detect the offense.
#
# source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#7
class RuboCop::Formatter::DisabledConfigFormatter < ::RuboCop::Formatter::BaseFormatter
  include ::RuboCop::PathUtil

  # @return [DisabledConfigFormatter] a new instance of DisabledConfigFormatter
  #
  # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#27
  def initialize(output, options = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#39
  def file_finished(file, offenses); end

  # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#33
  def file_started(_file, _file_info); end

  # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#47
  def finished(_inspected_files); end

  private

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#68
  def auto_gen_enforced_style?; end

  # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#72
  def command; end

  # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#156
  def cop_config_params(default_cfg, cfg); end

  # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#176
  def default_config(cop_name); end

  # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#220
  def excludes(offending_files, cop_name, parent); end

  # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#191
  def filtered_config(cfg); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#241
  def merge_mode_for_exclude?(cfg); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#262
  def no_exclude_limit?; end

  # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#101
  def output_cop(cop_name, offense_count); end

  # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#128
  def output_cop_comments(output_buffer, cfg, cop_name, offense_count); end

  # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#180
  def output_cop_config(output_buffer, cfg, cop_name); end

  # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#163
  def output_cop_param_comments(output_buffer, params, default_cfg); end

  # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#210
  def output_exclude_list(output_buffer, offending_files, cop_name); end

  # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#245
  def output_exclude_path(output_buffer, exclude_path, parent); end

  # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#199
  def output_offending_files(output_buffer, cfg, cop_name); end

  # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#95
  def output_offenses; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#258
  def safe_autocorrect?(config); end

  # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#115
  def set_max(cfg, cop_name); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#64
  def show_offense_counts?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#60
  def show_timestamp?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#148
  def supports_safe_autocorrect?(cop_class, default_cfg); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#152
  def supports_unsafe_autocorrect?(cop_class, default_cfg); end

  # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#91
  def timestamp; end

  class << self
    # Returns the value of attribute config_to_allow_offenses.
    #
    # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#24
    def config_to_allow_offenses; end

    # Sets the attribute config_to_allow_offenses
    #
    # @param value the value to set the attribute config_to_allow_offenses to.
    #
    # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#24
    def config_to_allow_offenses=(_arg0); end

    # Returns the value of attribute detected_styles.
    #
    # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#24
    def detected_styles; end

    # Sets the attribute detected_styles
    #
    # @param value the value to set the attribute detected_styles to.
    #
    # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#24
    def detected_styles=(_arg0); end
  end
end

# source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#10
RuboCop::Formatter::DisabledConfigFormatter::HEADING = T.let(T.unsafe(nil), String)

# This formatter displays the report data in format that's
# easy to process in the Emacs text editor.
# The output is machine-parsable.
#
# source://rubocop//lib/rubocop/formatter/emacs_style_formatter.rb#8
class RuboCop::Formatter::EmacsStyleFormatter < ::RuboCop::Formatter::BaseFormatter
  # source://rubocop//lib/rubocop/formatter/emacs_style_formatter.rb#9
  def file_finished(file, offenses); end

  private

  # source://rubocop//lib/rubocop/formatter/emacs_style_formatter.rb#24
  def message(offense); end
end

# This formatter displays just a list of the files with offenses in them,
# separated by newlines. The output is machine-parsable.
#
# Here's the format:
#
# /some/file
# /some/other/file
#
# source://rubocop//lib/rubocop/formatter/file_list_formatter.rb#12
class RuboCop::Formatter::FileListFormatter < ::RuboCop::Formatter::BaseFormatter
  # source://rubocop//lib/rubocop/formatter/file_list_formatter.rb#13
  def file_finished(file, offenses); end
end

# This is a collection of formatters. A FormatterSet can hold multiple
# formatter instances and provides transparent formatter API methods
# which invoke same method of each formatters.
#
# source://rubocop//lib/rubocop/formatter/formatter_set.rb#10
class RuboCop::Formatter::FormatterSet < ::Array
  # @return [FormatterSet] a new instance of FormatterSet
  #
  # source://rubocop//lib/rubocop/formatter/formatter_set.rb#39
  def initialize(options = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/formatter/formatter_set.rb#55
  def add_formatter(formatter_type, output_path = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/formatter/formatter_set.rb#67
  def close_output_files; end

  # source://rubocop//lib/rubocop/formatter/formatter_set.rb#50
  def file_finished(file, offenses); end

  # source://rubocop//lib/rubocop/formatter/formatter_set.rb#44
  def file_started(file, options); end

  # source://rubocop//lib/rubocop/formatter/formatter_set.rb#34
  def finished(*args); end

  # source://rubocop//lib/rubocop/formatter/formatter_set.rb#34
  def started(*args); end

  private

  # source://rubocop//lib/rubocop/formatter/formatter_set.rb#86
  def builtin_formatter_class(specified_key); end

  # source://rubocop//lib/rubocop/formatter/formatter_set.rb#99
  def custom_formatter_class(specified_class_name); end

  # source://rubocop//lib/rubocop/formatter/formatter_set.rb#75
  def formatter_class(formatter_type); end
end

# source://rubocop//lib/rubocop/formatter/formatter_set.rb#11
RuboCop::Formatter::FormatterSet::BUILTIN_FORMATTERS_FOR_KEYS = T.let(T.unsafe(nil), Hash)

# source://rubocop//lib/rubocop/formatter/formatter_set.rb#31
RuboCop::Formatter::FormatterSet::FORMATTER_APIS = T.let(T.unsafe(nil), Array)

# This formatter displays a progress bar and shows details of offenses as
# soon as they are detected.
# This is inspired by the Fuubar formatter for RSpec by Jeff Kreeftmeijer.
# https://github.com/jeffkreeftmeijer/fuubar
#
# source://rubocop//lib/rubocop/formatter/fuubar_style_formatter.rb#11
class RuboCop::Formatter::FuubarStyleFormatter < ::RuboCop::Formatter::ClangStyleFormatter
  # @return [FuubarStyleFormatter] a new instance of FuubarStyleFormatter
  #
  # source://rubocop//lib/rubocop/formatter/fuubar_style_formatter.rb#14
  def initialize(*output); end

  # source://rubocop//lib/rubocop/formatter/fuubar_style_formatter.rb#51
  def count_stats(offenses); end

  # source://rubocop//lib/rubocop/formatter/fuubar_style_formatter.rb#40
  def file_finished(file, offenses); end

  # source://rubocop//lib/rubocop/formatter/fuubar_style_formatter.rb#71
  def progressbar_color; end

  # source://rubocop//lib/rubocop/formatter/fuubar_style_formatter.rb#20
  def started(target_files); end

  # source://rubocop//lib/rubocop/formatter/fuubar_style_formatter.rb#61
  def with_color; end
end

# source://rubocop//lib/rubocop/formatter/fuubar_style_formatter.rb#12
RuboCop::Formatter::FuubarStyleFormatter::RESET_SEQUENCE = T.let(T.unsafe(nil), String)

# This formatter formats report data as GitHub Workflow commands resulting
# in GitHub check annotations when run within GitHub Actions.
#
# source://rubocop//lib/rubocop/formatter/git_hub_actions_formatter.rb#7
class RuboCop::Formatter::GitHubActionsFormatter < ::RuboCop::Formatter::BaseFormatter
  # source://rubocop//lib/rubocop/formatter/git_hub_actions_formatter.rb#14
  def file_finished(file, offenses); end

  # source://rubocop//lib/rubocop/formatter/git_hub_actions_formatter.rb#18
  def finished(_inspected_files); end

  # source://rubocop//lib/rubocop/formatter/git_hub_actions_formatter.rb#10
  def started(_target_files); end

  private

  # source://rubocop//lib/rubocop/formatter/git_hub_actions_formatter.rb#29
  def github_escape(string); end

  # source://rubocop//lib/rubocop/formatter/git_hub_actions_formatter.rb#41
  def github_severity(offense); end

  # source://rubocop//lib/rubocop/formatter/git_hub_actions_formatter.rb#33
  def minimum_severity_to_fail; end

  # source://rubocop//lib/rubocop/formatter/git_hub_actions_formatter.rb#45
  def report_offense(file, offense); end
end

# source://rubocop//lib/rubocop/formatter/git_hub_actions_formatter.rb#8
RuboCop::Formatter::GitHubActionsFormatter::ESCAPE_MAP = T.let(T.unsafe(nil), Hash)

# This formatter saves the output as an html file.
#
# source://rubocop//lib/rubocop/formatter/html_formatter.rb#11
class RuboCop::Formatter::HTMLFormatter < ::RuboCop::Formatter::BaseFormatter
  # @return [HTMLFormatter] a new instance of HTMLFormatter
  #
  # source://rubocop//lib/rubocop/formatter/html_formatter.rb#30
  def initialize(output, options = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/formatter/html_formatter.rb#40
  def file_finished(file, offenses); end

  # Returns the value of attribute files.
  #
  # source://rubocop//lib/rubocop/formatter/html_formatter.rb#28
  def files; end

  # source://rubocop//lib/rubocop/formatter/html_formatter.rb#45
  def finished(inspected_files); end

  # source://rubocop//lib/rubocop/formatter/html_formatter.rb#51
  def render_html; end

  # source://rubocop//lib/rubocop/formatter/html_formatter.rb#36
  def started(target_files); end

  # Returns the value of attribute summary.
  #
  # source://rubocop//lib/rubocop/formatter/html_formatter.rb#28
  def summary; end
end

# source://rubocop//lib/rubocop/formatter/html_formatter.rb#15
class RuboCop::Formatter::HTMLFormatter::Color < ::Struct
  # Returns the value of attribute alpha
  #
  # @return [Object] the current value of alpha
  def alpha; end

  # Sets the attribute alpha
  #
  # @param value [Object] the value to set the attribute alpha to.
  # @return [Object] the newly set value
  def alpha=(_); end

  # Returns the value of attribute blue
  #
  # @return [Object] the current value of blue
  def blue; end

  # Sets the attribute blue
  #
  # @param value [Object] the value to set the attribute blue to.
  # @return [Object] the newly set value
  def blue=(_); end

  # source://rubocop//lib/rubocop/formatter/html_formatter.rb#20
  def fade_out(amount); end

  # Returns the value of attribute green
  #
  # @return [Object] the current value of green
  def green; end

  # Sets the attribute green
  #
  # @param value [Object] the value to set the attribute green to.
  # @return [Object] the newly set value
  def green=(_); end

  # Returns the value of attribute red
  #
  # @return [Object] the current value of red
  def red; end

  # Sets the attribute red
  #
  # @param value [Object] the value to set the attribute red to.
  # @return [Object] the newly set value
  def red=(_); end

  # source://rubocop//lib/rubocop/formatter/html_formatter.rb#16
  def to_s; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://rubocop//lib/rubocop/formatter/html_formatter.rb#12
RuboCop::Formatter::HTMLFormatter::ELLIPSES = T.let(T.unsafe(nil), String)

# This class provides helper methods used in the ERB template.
#
# source://rubocop//lib/rubocop/formatter/html_formatter.rb#62
class RuboCop::Formatter::HTMLFormatter::ERBContext
  include ::RuboCop::PathUtil
  include ::RuboCop::Formatter::TextUtil

  # @return [ERBContext] a new instance of ERBContext
  #
  # source://rubocop//lib/rubocop/formatter/html_formatter.rb#78
  def initialize(files, summary); end

  # source://rubocop//lib/rubocop/formatter/html_formatter.rb#125
  def base64_encoded_logo_image; end

  # Make Kernel#binding public.
  #
  # source://rubocop//lib/rubocop/formatter/html_formatter.rb#85
  def binding; end

  # source://rubocop//lib/rubocop/formatter/html_formatter.rb#90
  def decorated_message(offense); end

  # source://rubocop//lib/rubocop/formatter/html_formatter.rb#121
  def escape(string); end

  # Returns the value of attribute files.
  #
  # source://rubocop//lib/rubocop/formatter/html_formatter.rb#76
  def files; end

  # source://rubocop//lib/rubocop/formatter/html_formatter.rb#101
  def highlight_source_tag(offense); end

  # source://rubocop//lib/rubocop/formatter/html_formatter.rb#94
  def highlighted_source_line(offense); end

  # source://rubocop//lib/rubocop/formatter/html_formatter.rb#117
  def possible_ellipses(location); end

  # source://rubocop//lib/rubocop/formatter/html_formatter.rb#112
  def source_after_highlight(offense); end

  # source://rubocop//lib/rubocop/formatter/html_formatter.rb#107
  def source_before_highlight(offense); end

  # Returns the value of attribute summary.
  #
  # source://rubocop//lib/rubocop/formatter/html_formatter.rb#76
  def summary; end
end

# source://rubocop//lib/rubocop/formatter/html_formatter.rb#74
RuboCop::Formatter::HTMLFormatter::ERBContext::LOGO_IMAGE_PATH = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/formatter/html_formatter.rb#66
RuboCop::Formatter::HTMLFormatter::ERBContext::SEVERITY_COLORS = T.let(T.unsafe(nil), Hash)

# source://rubocop//lib/rubocop/formatter/html_formatter.rb#26
class RuboCop::Formatter::HTMLFormatter::FileOffenses < ::Struct
  # Returns the value of attribute offenses
  #
  # @return [Object] the current value of offenses
  def offenses; end

  # Sets the attribute offenses
  #
  # @param value [Object] the value to set the attribute offenses to.
  # @return [Object] the newly set value
  def offenses=(_); end

  # Returns the value of attribute path
  #
  # @return [Object] the current value of path
  def path; end

  # Sets the attribute path
  #
  # @param value [Object] the value to set the attribute path to.
  # @return [Object] the newly set value
  def path=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://rubocop//lib/rubocop/formatter/html_formatter.rb#25
class RuboCop::Formatter::HTMLFormatter::Summary < ::Struct
  # Returns the value of attribute inspected_files
  #
  # @return [Object] the current value of inspected_files
  def inspected_files; end

  # Sets the attribute inspected_files
  #
  # @param value [Object] the value to set the attribute inspected_files to.
  # @return [Object] the newly set value
  def inspected_files=(_); end

  # Returns the value of attribute offense_count
  #
  # @return [Object] the current value of offense_count
  def offense_count; end

  # Sets the attribute offense_count
  #
  # @param value [Object] the value to set the attribute offense_count to.
  # @return [Object] the newly set value
  def offense_count=(_); end

  # Returns the value of attribute target_files
  #
  # @return [Object] the current value of target_files
  def target_files; end

  # Sets the attribute target_files
  #
  # @param value [Object] the value to set the attribute target_files to.
  # @return [Object] the newly set value
  def target_files=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://rubocop//lib/rubocop/formatter/html_formatter.rb#13
RuboCop::Formatter::HTMLFormatter::TEMPLATE_PATH = T.let(T.unsafe(nil), String)

# This formatter formats the report data in JSON format.
#
# source://rubocop//lib/rubocop/formatter/json_formatter.rb#9
class RuboCop::Formatter::JSONFormatter < ::RuboCop::Formatter::BaseFormatter
  include ::RuboCop::PathUtil

  # @return [JSONFormatter] a new instance of JSONFormatter
  #
  # source://rubocop//lib/rubocop/formatter/json_formatter.rb#14
  def initialize(output, options = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/formatter/json_formatter.rb#23
  def file_finished(file, offenses); end

  # source://rubocop//lib/rubocop/formatter/json_formatter.rb#28
  def finished(inspected_files); end

  # source://rubocop//lib/rubocop/formatter/json_formatter.rb#43
  def hash_for_file(file, offenses); end

  # TODO: Consider better solution for Offense#real_column.
  #       The minimum value of `start_column: real_column` is 1.
  #       So, the minimum value of `last_column` should be 1.
  #       And non-zero value of `last_column` should be used as is.
  #
  # source://rubocop//lib/rubocop/formatter/json_formatter.rb#65
  def hash_for_location(offense); end

  # source://rubocop//lib/rubocop/formatter/json_formatter.rb#50
  def hash_for_offense(offense); end

  # source://rubocop//lib/rubocop/formatter/json_formatter.rb#33
  def metadata_hash; end

  # Returns the value of attribute output_hash.
  #
  # source://rubocop//lib/rubocop/formatter/json_formatter.rb#12
  def output_hash; end

  # source://rubocop//lib/rubocop/formatter/json_formatter.rb#19
  def started(target_files); end
end

# This formatter formats the report data in JUnit format.
#
# source://rubocop//lib/rubocop/formatter/junit_formatter.rb#17
class RuboCop::Formatter::JUnitFormatter < ::RuboCop::Formatter::BaseFormatter
  # @return [JUnitFormatter] a new instance of JUnitFormatter
  #
  # source://rubocop//lib/rubocop/formatter/junit_formatter.rb#18
  def initialize(output, options = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/formatter/junit_formatter.rb#55
  def add_testcase_element_to_testsuite_element(file, target_offenses, cop); end

  # source://rubocop//lib/rubocop/formatter/junit_formatter.rb#64
  def classname_attribute_value(file); end

  # source://rubocop//lib/rubocop/formatter/junit_formatter.rb#29
  def file_finished(file, offenses); end

  # source://rubocop//lib/rubocop/formatter/junit_formatter.rb#71
  def finished(_inspected_files); end

  # source://rubocop//lib/rubocop/formatter/junit_formatter.rb#51
  def offenses_for_cop(all_offenses, cop); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/formatter/junit_formatter.rb#47
  def relevant_for_output?(options, target_offenses); end

  private

  # source://rubocop//lib/rubocop/formatter/junit_formatter.rb#83
  def add_failure_to(testcase, offenses, cop_name); end

  # source://rubocop//lib/rubocop/formatter/junit_formatter.rb#78
  def reset_count; end
end

# This formatter displays the report data in markdown
#
# source://rubocop//lib/rubocop/formatter/markdown_formatter.rb#6
class RuboCop::Formatter::MarkdownFormatter < ::RuboCop::Formatter::BaseFormatter
  include ::RuboCop::Formatter::TextUtil
  include ::RuboCop::PathUtil

  # @return [MarkdownFormatter] a new instance of MarkdownFormatter
  #
  # source://rubocop//lib/rubocop/formatter/markdown_formatter.rb#11
  def initialize(output, options = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/formatter/markdown_formatter.rb#21
  def file_finished(file, offenses); end

  # Returns the value of attribute files.
  #
  # source://rubocop//lib/rubocop/formatter/markdown_formatter.rb#9
  def files; end

  # source://rubocop//lib/rubocop/formatter/markdown_formatter.rb#26
  def finished(inspected_files); end

  # source://rubocop//lib/rubocop/formatter/markdown_formatter.rb#17
  def started(target_files); end

  # Returns the value of attribute summary.
  #
  # source://rubocop//lib/rubocop/formatter/markdown_formatter.rb#9
  def summary; end

  private

  # source://rubocop//lib/rubocop/formatter/markdown_formatter.rb#73
  def possible_ellipses(location); end

  # source://rubocop//lib/rubocop/formatter/markdown_formatter.rb#33
  def render_markdown; end

  # source://rubocop//lib/rubocop/formatter/markdown_formatter.rb#67
  def write_code(offense); end

  # source://rubocop//lib/rubocop/formatter/markdown_formatter.rb#61
  def write_context(offense); end

  # source://rubocop//lib/rubocop/formatter/markdown_formatter.rb#42
  def write_file_messages; end

  # source://rubocop//lib/rubocop/formatter/markdown_formatter.rb#54
  def write_heading(file); end
end

# This formatter displays the list of offended cops with a count of how
# many offenses of their kind were found. Ordered by desc offense count
#
# Here's the format:
#
# 26  LineLength
# 3   OneLineConditional
# --
# 29  Total in 5 files
#
# source://rubocop//lib/rubocop/formatter/offense_count_formatter.rb#16
class RuboCop::Formatter::OffenseCountFormatter < ::RuboCop::Formatter::BaseFormatter
  # source://rubocop//lib/rubocop/formatter/offense_count_formatter.rb#42
  def file_finished(_file, offenses); end

  # source://rubocop//lib/rubocop/formatter/offense_count_formatter.rb#51
  def finished(_inspected_files); end

  # Returns the value of attribute offense_counts.
  #
  # source://rubocop//lib/rubocop/formatter/offense_count_formatter.rb#17
  def offense_counts; end

  # source://rubocop//lib/rubocop/formatter/offense_count_formatter.rb#74
  def ordered_offense_counts(offense_counts); end

  # source://rubocop//lib/rubocop/formatter/offense_count_formatter.rb#56
  def report_summary(offense_counts, offending_files_count); end

  # source://rubocop//lib/rubocop/formatter/offense_count_formatter.rb#19
  def started(target_files); end

  # source://rubocop//lib/rubocop/formatter/offense_count_formatter.rb#78
  def total_offense_count(offense_counts); end
end

# This formatter prints a PACDOT per every file to be analyzed.
# Pacman will "eat" one PACDOT per file when no offense is detected.
# Otherwise it will print a Ghost.
# This is inspired by the Pacman formatter for RSpec by Carlos Rojas.
# https://github.com/go-labs/rspec_pacman_formatter
#
# source://rubocop//lib/rubocop/formatter/pacman_formatter.rb#10
class RuboCop::Formatter::PacmanFormatter < ::RuboCop::Formatter::ClangStyleFormatter
  include ::RuboCop::Formatter::TextUtil

  # @return [PacmanFormatter] a new instance of PacmanFormatter
  #
  # source://rubocop//lib/rubocop/formatter/pacman_formatter.rb#19
  def initialize(output, options = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/formatter/pacman_formatter.rb#50
  def cols; end

  # source://rubocop//lib/rubocop/formatter/pacman_formatter.rb#37
  def file_finished(file, offenses); end

  # source://rubocop//lib/rubocop/formatter/pacman_formatter.rb#33
  def file_started(_file, _options); end

  # source://rubocop//lib/rubocop/formatter/pacman_formatter.rb#43
  def next_step(offenses); end

  # source://rubocop//lib/rubocop/formatter/pacman_formatter.rb#64
  def pacdots(number); end

  # Returns the value of attribute progress_line.
  #
  # source://rubocop//lib/rubocop/formatter/pacman_formatter.rb#12
  def progress_line; end

  # Sets the attribute progress_line
  #
  # @param value the value to set the attribute progress_line to.
  #
  # source://rubocop//lib/rubocop/formatter/pacman_formatter.rb#12
  def progress_line=(_arg0); end

  # source://rubocop//lib/rubocop/formatter/pacman_formatter.rb#26
  def started(target_files); end

  # source://rubocop//lib/rubocop/formatter/pacman_formatter.rb#68
  def step(character); end

  # source://rubocop//lib/rubocop/formatter/pacman_formatter.rb#57
  def update_progress_line; end
end

# source://rubocop//lib/rubocop/formatter/pacman_formatter.rb#14
RuboCop::Formatter::PacmanFormatter::FALLBACK_TERMINAL_WIDTH = T.let(T.unsafe(nil), Integer)

# source://rubocop//lib/rubocop/formatter/pacman_formatter.rb#15
RuboCop::Formatter::PacmanFormatter::GHOST = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/formatter/pacman_formatter.rb#17
RuboCop::Formatter::PacmanFormatter::PACDOT = T.let(T.unsafe(nil), Rainbow::Presenter)

# source://rubocop//lib/rubocop/formatter/pacman_formatter.rb#16
RuboCop::Formatter::PacmanFormatter::PACMAN = T.let(T.unsafe(nil), Rainbow::Presenter)

# This formatter display dots for files with no offenses and
# letters for files with problems in the them. In the end it
# appends the regular report data in the clang style format.
#
# source://rubocop//lib/rubocop/formatter/progress_formatter.rb#8
class RuboCop::Formatter::ProgressFormatter < ::RuboCop::Formatter::ClangStyleFormatter
  include ::RuboCop::Formatter::TextUtil

  # @return [ProgressFormatter] a new instance of ProgressFormatter
  #
  # source://rubocop//lib/rubocop/formatter/progress_formatter.rb#13
  def initialize(output, options = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/formatter/progress_formatter.rb#24
  def file_finished(file, offenses); end

  # source://rubocop//lib/rubocop/formatter/progress_formatter.rb#33
  def finished(inspected_files); end

  # source://rubocop//lib/rubocop/formatter/progress_formatter.rb#50
  def report_file_as_mark(offenses); end

  # source://rubocop//lib/rubocop/formatter/progress_formatter.rb#18
  def started(target_files); end
end

# source://rubocop//lib/rubocop/formatter/progress_formatter.rb#11
RuboCop::Formatter::ProgressFormatter::DOT = T.let(T.unsafe(nil), String)

# If no offenses are found, no output is displayed.
# Otherwise, SimpleTextFormatter's output is displayed.
#
# source://rubocop//lib/rubocop/formatter/quiet_formatter.rb#7
class RuboCop::Formatter::QuietFormatter < ::RuboCop::Formatter::SimpleTextFormatter
  # source://rubocop//lib/rubocop/formatter/quiet_formatter.rb#8
  def report_summary(file_count, offense_count, correction_count, correctable_count); end
end

# A basic formatter that displays only files with offenses.
# Offenses are displayed at compact form - just the
# location of the problem and the associated message.
#
# source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#10
class RuboCop::Formatter::SimpleTextFormatter < ::RuboCop::Formatter::BaseFormatter
  include ::RuboCop::Formatter::Colorizable
  include ::RuboCop::PathUtil

  # source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#29
  def file_finished(file, offenses); end

  # source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#36
  def finished(inspected_files); end

  # source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#43
  def report_file(file, offenses); end

  # source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#57
  def report_summary(file_count, offense_count, correction_count, correctable_count); end

  # source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#23
  def started(_target_files); end

  private

  # source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#85
  def annotate_message(msg); end

  # source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#80
  def colored_severity_code(offense); end

  # source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#73
  def count_stats(offenses); end

  # source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#89
  def message(offense); end
end

# source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#14
RuboCop::Formatter::SimpleTextFormatter::COLOR_FOR_SEVERITY = T.let(T.unsafe(nil), Hash)

# A helper class for building the report summary text.
#
# source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#105
class RuboCop::Formatter::SimpleTextFormatter::Report
  include ::RuboCop::Formatter::Colorizable
  include ::RuboCop::Formatter::TextUtil

  # @return [Report] a new instance of Report
  #
  # source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#110
  def initialize(file_count, offense_count, correction_count, correctable_count, rainbow, safe_autocorrect: T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#123
  def summary; end

  private

  # source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#160
  def correctable; end

  # source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#153
  def corrections; end

  # source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#142
  def files; end

  # source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#146
  def offenses; end

  # Returns the value of attribute rainbow.
  #
  # source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#140
  def rainbow; end
end

# This formatter formats report data using the Test Anything Protocol.
# TAP allows for to communicate tests results in a language agnostics way.
#
# source://rubocop//lib/rubocop/formatter/tap_formatter.rb#7
class RuboCop::Formatter::TapFormatter < ::RuboCop::Formatter::ClangStyleFormatter
  # source://rubocop//lib/rubocop/formatter/tap_formatter.rb#14
  def file_finished(file, offenses); end

  # source://rubocop//lib/rubocop/formatter/tap_formatter.rb#8
  def started(target_files); end

  private

  # source://rubocop//lib/rubocop/formatter/tap_formatter.rb#66
  def annotate_message(msg); end

  # source://rubocop//lib/rubocop/formatter/tap_formatter.rb#70
  def message(offense); end

  # source://rubocop//lib/rubocop/formatter/tap_formatter.rb#39
  def report_highlighted_area(highlighted_area); end

  # source://rubocop//lib/rubocop/formatter/tap_formatter.rb#29
  def report_line(location); end

  # source://rubocop//lib/rubocop/formatter/tap_formatter.rb#46
  def report_offense(file, offense); end
end

# Common logic for UI texts.
#
# source://rubocop//lib/rubocop/formatter/text_util.rb#6
module RuboCop::Formatter::TextUtil
  private

  # source://rubocop//lib/rubocop/formatter/text_util.rb#9
  def pluralize(number, thing, options = T.unsafe(nil)); end

  class << self
    # source://rubocop//lib/rubocop/formatter/text_util.rb#9
    def pluralize(number, thing, options = T.unsafe(nil)); end
  end
end

# This formatter displays the list of offensive files, sorted by number of
# offenses with the worst offenders first.
#
# Here's the format:
#
# 26  this/file/is/really/bad.rb
# 3   just/ok.rb
# --
# 29  Total in 2 files
#
# source://rubocop//lib/rubocop/formatter/worst_offenders_formatter.rb#16
class RuboCop::Formatter::WorstOffendersFormatter < ::RuboCop::Formatter::BaseFormatter
  # source://rubocop//lib/rubocop/formatter/worst_offenders_formatter.rb#24
  def file_finished(file, offenses); end

  # source://rubocop//lib/rubocop/formatter/worst_offenders_formatter.rb#31
  def finished(_inspected_files); end

  # Returns the value of attribute offense_counts.
  #
  # source://rubocop//lib/rubocop/formatter/worst_offenders_formatter.rb#17
  def offense_counts; end

  # source://rubocop//lib/rubocop/formatter/worst_offenders_formatter.rb#55
  def ordered_offense_counts(offense_counts); end

  # source://rubocop//lib/rubocop/formatter/worst_offenders_formatter.rb#36
  def report_summary(offense_counts); end

  # source://rubocop//lib/rubocop/formatter/worst_offenders_formatter.rb#19
  def started(target_files); end

  # source://rubocop//lib/rubocop/formatter/worst_offenders_formatter.rb#59
  def total_offense_count(offense_counts); end
end

# source://rubocop//lib/rubocop/options.rb#8
class RuboCop::IncorrectCopNameError < ::StandardError; end

# Encapsulation of a lockfile for use when checking for gems.
# Does not actually resolve gems, just parses the lockfile.
#
# @api private
#
# source://rubocop//lib/rubocop/lockfile.rb#7
class RuboCop::Lockfile
  # Gems that the bundle depends on
  #
  # @api private
  #
  # source://rubocop//lib/rubocop/lockfile.rb#9
  def dependencies; end

  # All activated gems, including transitive dependencies
  #
  # @api private
  #
  # source://rubocop//lib/rubocop/lockfile.rb#16
  def gems; end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/lockfile.rb#24
  def includes_gem?(name); end

  private

  # @api private
  #
  # source://rubocop//lib/rubocop/lockfile.rb#30
  def parser; end
end

# Parse different formats of magic comments.
#
# @abstract parent of three different magic comment handlers
#
# source://rubocop//lib/rubocop/magic_comment.rb#7
class RuboCop::MagicComment
  # @return [MagicComment] a new instance of MagicComment
  #
  # source://rubocop//lib/rubocop/magic_comment.rb#32
  def initialize(comment); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/magic_comment.rb#36
  def any?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/magic_comment.rb#104
  def encoding_specified?; end

  # Expose the `frozen_string_literal` value coerced to a boolean if possible.
  #
  # @return [Boolean] if value is `true` or `false`
  # @return [nil] if frozen_string_literal comment isn't found
  # @return [String] if comment is found but isn't true or false
  #
  # source://rubocop//lib/rubocop/magic_comment.rb#86
  def frozen_string_literal; end

  # Does the magic comment enable the frozen string literal feature.
  #
  # Test whether the frozen string literal value is `true`. Cannot
  # just return `frozen_string_literal` since an invalid magic comment
  # `'yes'` does not actually enable the feature
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/magic_comment.rb#55
  def frozen_string_literal?; end

  # Was a magic comment for the frozen string literal found?
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/magic_comment.rb#70
  def frozen_string_literal_specified?; end

  # Expose the `shareable_constant_value` value coerced to a boolean if possible.
  #
  # @return [String] for shareable_constant_value config
  #
  # source://rubocop//lib/rubocop/magic_comment.rb#100
  def shareable_constant_value; end

  # Was a shareable_constant_value specified?
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/magic_comment.rb#77
  def shareable_constant_value_specified?; end

  # source://rubocop//lib/rubocop/magic_comment.rb#115
  def typed; end

  # Was the Sorbet `typed` sigil specified?
  #
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/magic_comment.rb#111
  def typed_specified?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/magic_comment.rb#43
  def valid?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/magic_comment.rb#59
  def valid_literal_value?; end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/magic_comment.rb#63
  def valid_shareable_constant_value?; end

  private

  # Match the entire comment string with a pattern and take the first capture.
  #
  # @param pattern [Regexp]
  # @return [String] if pattern matched
  # @return [nil] otherwise
  #
  # source://rubocop//lib/rubocop/magic_comment.rb#131
  def extract(pattern); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/magic_comment.rb#121
  def specified?(value); end

  class << self
    # Detect magic comment format and pass it to the appropriate wrapper.
    #
    # @param comment [String]
    # @return [RuboCop::MagicComment]
    #
    # source://rubocop//lib/rubocop/magic_comment.rb#23
    def parse(comment); end
  end
end

# Parent to Vim and Emacs magic comment handling.
#
# @abstract
#
# source://rubocop//lib/rubocop/magic_comment.rb#138
class RuboCop::MagicComment::EditorComment < ::RuboCop::MagicComment
  # source://rubocop//lib/rubocop/magic_comment.rb#139
  def encoding; end

  # Rewrite the comment without a given token type
  #
  # source://rubocop//lib/rubocop/magic_comment.rb#144
  def without(type); end

  private

  # Find a token starting with the provided keyword and extract its value.
  #
  # @param keyword [String]
  # @return [String] extracted value if it is found
  # @return [nil] otherwise
  #
  # source://rubocop//lib/rubocop/magic_comment.rb#159
  def match(keyword); end

  # Individual tokens composing an editor specific comment string.
  #
  # @return [Array<String>]
  #
  # source://rubocop//lib/rubocop/magic_comment.rb#174
  def tokens; end
end

# Wrapper for Emacs style magic comments.
#
# @example Emacs style comment
#   comment = RuboCop::MagicComment.parse(
#   '# -*- encoding: ASCII-8BIT -*-'
#   )
#
#   comment.encoding # => 'ascii-8bit'
# @see https://www.gnu.org/software/emacs/manual/html_node/emacs/Specify-Coding.html
# @see https://github.com/ruby/ruby/blob/3f306dc/parse.y#L6873-L6892 Emacs handling in parse.y
#
# source://rubocop//lib/rubocop/magic_comment.rb#190
class RuboCop::MagicComment::EmacsComment < ::RuboCop::MagicComment::EditorComment
  private

  # source://rubocop//lib/rubocop/magic_comment.rb#198
  def extract_frozen_string_literal; end

  # source://rubocop//lib/rubocop/magic_comment.rb#202
  def extract_shareable_constant_value; end

  # Emacs comments cannot specify Sorbet typechecking behavior.
  #
  # source://rubocop//lib/rubocop/magic_comment.rb#207
  def extract_typed; end
end

# source://rubocop//lib/rubocop/magic_comment.rb#192
RuboCop::MagicComment::EmacsComment::FORMAT = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/magic_comment.rb#194
RuboCop::MagicComment::EmacsComment::OPERATOR = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/magic_comment.rb#191
RuboCop::MagicComment::EmacsComment::REGEXP = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/magic_comment.rb#193
RuboCop::MagicComment::EmacsComment::SEPARATOR = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/magic_comment.rb#11
RuboCop::MagicComment::KEYWORDS = T.let(T.unsafe(nil), Hash)

# Wrapper for regular magic comments not bound to an editor.
#
# Simple comments can only specify one setting per comment.
#
# @example frozen string literal comments
#   comment1 = RuboCop::MagicComment.parse('# frozen_string_literal: true')
#   comment1.frozen_string_literal # => true
#   comment1.encoding              # => nil
# @example encoding comments
#   comment2 = RuboCop::MagicComment.parse('# encoding: utf-8')
#   comment2.frozen_string_literal # => nil
#   comment2.encoding              # => 'utf-8'
#
# source://rubocop//lib/rubocop/magic_comment.rb#261
class RuboCop::MagicComment::SimpleComment < ::RuboCop::MagicComment
  # Match `encoding` or `coding`
  #
  # source://rubocop//lib/rubocop/magic_comment.rb#263
  def encoding; end

  # Rewrite the comment without a given token type
  #
  # source://rubocop//lib/rubocop/magic_comment.rb#268
  def without(type); end

  private

  # Extract `frozen_string_literal`.
  #
  # The `frozen_string_literal` magic comment only works if it
  # is the only text in the comment.
  #
  # Case-insensitive and dashes/underscores are acceptable.
  #
  # @see https://github.com/ruby/ruby/blob/78b95b4/parse.y#L7134-L7138
  #
  # source://rubocop//lib/rubocop/magic_comment.rb#285
  def extract_frozen_string_literal; end

  # source://rubocop//lib/rubocop/magic_comment.rb#289
  def extract_shareable_constant_value; end

  # source://rubocop//lib/rubocop/magic_comment.rb#293
  def extract_typed; end
end

# IRB's pattern for matching magic comment tokens.
#
# @see https://github.com/ruby/ruby/blob/b4a55c1/lib/irb/magic-file.rb#L5
#
# source://rubocop//lib/rubocop/magic_comment.rb#10
RuboCop::MagicComment::TOKEN = T.let(T.unsafe(nil), Regexp)

# Wrapper for Vim style magic comments.
#
# @example Vim style comment
#   comment = RuboCop::MagicComment.parse(
#   '# vim: filetype=ruby, fileencoding=ascii-8bit'
#   )
#
#   comment.encoding # => 'ascii-8bit'
#
# source://rubocop//lib/rubocop/magic_comment.rb#218
class RuboCop::MagicComment::VimComment < ::RuboCop::MagicComment::EditorComment
  # For some reason the fileencoding keyword only works if there
  # is at least one other token included in the string. For example
  #
  #    # works
  #      # vim: foo=bar, fileencoding=ascii-8bit
  #
  #    # does nothing
  #      # vim: foo=bar, fileencoding=ascii-8bit
  #
  # source://rubocop//lib/rubocop/magic_comment.rb#234
  def encoding; end

  # Vim comments cannot specify Sorbet typechecking behavior.
  #
  # source://rubocop//lib/rubocop/magic_comment.rb#245
  def extract_typed; end

  # Vim comments cannot specify frozen string literal behavior.
  #
  # source://rubocop//lib/rubocop/magic_comment.rb#239
  def frozen_string_literal; end

  # Vim comments cannot specify shareable constant values behavior.
  #
  # source://rubocop//lib/rubocop/magic_comment.rb#242
  def shareable_constant_value; end
end

# source://rubocop//lib/rubocop/magic_comment.rb#220
RuboCop::MagicComment::VimComment::FORMAT = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/magic_comment.rb#223
RuboCop::MagicComment::VimComment::KEYWORDS = T.let(T.unsafe(nil), Hash)

# source://rubocop//lib/rubocop/magic_comment.rb#222
RuboCop::MagicComment::VimComment::OPERATOR = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/magic_comment.rb#219
RuboCop::MagicComment::VimComment::REGEXP = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/magic_comment.rb#221
RuboCop::MagicComment::VimComment::SEPARATOR = T.let(T.unsafe(nil), String)

# Common functionality for finding names that are similar to a given name.
#
# @api private
#
# source://rubocop//lib/rubocop/name_similarity.rb#6
module RuboCop::NameSimilarity
  private

  # @api private
  #
  # source://rubocop//lib/rubocop/name_similarity.rb#9
  def find_similar_name(target_name, names); end

  # @api private
  #
  # source://rubocop//lib/rubocop/name_similarity.rb#15
  def find_similar_names(target_name, names); end

  class << self
    # @api private
    #
    # source://rubocop//lib/rubocop/name_similarity.rb#9
    def find_similar_name(target_name, names); end

    # @api private
    #
    # source://rubocop//lib/rubocop/name_similarity.rb#15
    def find_similar_names(target_name, names); end
  end
end

# source://rubocop//lib/rubocop/ast_aliases.rb#5
RuboCop::NodePattern = RuboCop::AST::NodePattern

# source://rubocop//lib/rubocop/options.rb#10
class RuboCop::OptionArgumentError < ::StandardError; end

# This class handles command line options.
#
# @api private
#
# source://rubocop//lib/rubocop/options.rb#14
class RuboCop::Options
  # @api private
  # @return [Options] a new instance of Options
  #
  # source://rubocop//lib/rubocop/options.rb#22
  def initialize; end

  # @api private
  #
  # source://rubocop//lib/rubocop/options.rb#27
  def parse(command_line_args); end

  private

  # @api private
  #
  # source://rubocop//lib/rubocop/options.rb#219
  def add_additional_modes(opts); end

  # the autocorrect command-line arguments map to the autocorrect @options values like so:
  #                            :fix_layout  :autocorrect  :safe_autocorrect  :autocorrect_all
  # -x, --fix-layout           true         true          -                  -
  # -a, --auto-correct         -            true          true               -
  #     --safe-auto-correct    -            true          true               -
  # -A, --auto-correct-all     -            true          -                  true
  #
  # @api private
  #
  # source://rubocop//lib/rubocop/options.rb#136
  def add_autocorrection_options(opts); end

  # @api private
  #
  # source://rubocop//lib/rubocop/options.rb#201
  def add_cache_options(opts); end

  # @api private
  #
  # source://rubocop//lib/rubocop/options.rb#70
  def add_check_options(opts); end

  # @api private
  #
  # source://rubocop//lib/rubocop/options.rb#159
  def add_config_generation_options(opts); end

  # @api private
  #
  # source://rubocop//lib/rubocop/options.rb#177
  def add_cop_selection_csv_option(option, opts); end

  # @api private
  #
  # source://rubocop//lib/rubocop/options.rb#231
  def add_general_options(opts); end

  # @api private
  #
  # source://rubocop//lib/rubocop/options.rb#101
  def add_output_options(opts); end

  # @api private
  #
  # source://rubocop//lib/rubocop/options.rb#243
  def add_profile_options(opts); end

  # @api private
  #
  # source://rubocop//lib/rubocop/options.rb#208
  def add_server_options(opts); end

  # @api private
  #
  # source://rubocop//lib/rubocop/options.rb#192
  def add_severity_option(opts); end

  # @api private
  #
  # source://rubocop//lib/rubocop/options.rb#52
  def define_options; end

  # @api private
  #
  # source://rubocop//lib/rubocop/options.rb#253
  def handle_deprecated_option(old_option, new_option); end

  # Finds the option in `args` starting with -- and converts it to a symbol,
  # e.g. [..., '--autocorrect', ...] to :autocorrect.
  #
  # @api private
  #
  # source://rubocop//lib/rubocop/options.rb#287
  def long_opt_symbol(args); end

  # Sets a value in the @options hash, based on the given long option and its
  # value, in addition to calling the block if a block is given.
  #
  # @api private
  #
  # source://rubocop//lib/rubocop/options.rb#276
  def option(opts, *args); end

  # @api private
  #
  # source://rubocop//lib/rubocop/options.rb#258
  def rainbow; end

  # @api private
  #
  # source://rubocop//lib/rubocop/options.rb#292
  def require_feature(file); end

  # Creates a section of options in order to separate them visually when
  # using `--help`.
  #
  # @api private
  #
  # source://rubocop//lib/rubocop/options.rb#268
  def section(opts, heading, &_block); end
end

# @api private
#
# source://rubocop//lib/rubocop/options.rb#20
RuboCop::Options::DEFAULT_MAXIMUM_EXCLUSION_ITEMS = T.let(T.unsafe(nil), Integer)

# @api private
#
# source://rubocop//lib/rubocop/options.rb#19
RuboCop::Options::EXITING_OPTIONS = T.let(T.unsafe(nil), Array)

# @api private
#
# source://rubocop//lib/rubocop/options.rb#15
RuboCop::Options::E_STDIN_NO_PATH = T.let(T.unsafe(nil), String)

# This module contains help texts for command line options.
#
# @api private
#
# source://rubocop//lib/rubocop/options.rb#488
module RuboCop::OptionsHelp; end

# @api private
#
# source://rubocop//lib/rubocop/options.rb#490
RuboCop::OptionsHelp::FORMATTER_OPTION_LIST = T.let(T.unsafe(nil), Array)

# @api private
#
# source://rubocop//lib/rubocop/options.rb#489
RuboCop::OptionsHelp::MAX_EXCL = T.let(T.unsafe(nil), String)

# @api private
#
# source://rubocop//lib/rubocop/options.rb#492
RuboCop::OptionsHelp::TEXT = T.let(T.unsafe(nil), Hash)

# Validates option arguments and the options' compatibility with each other.
#
# @api private
#
# source://rubocop//lib/rubocop/options.rb#302
class RuboCop::OptionsValidator
  # @api private
  # @return [OptionsValidator] a new instance of OptionsValidator
  #
  # source://rubocop//lib/rubocop/options.rb#340
  def initialize(options); end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/options.rb#462
  def boolean_or_empty_cache?; end

  # @api private
  #
  # source://rubocop//lib/rubocop/options.rb#428
  def disable_parallel_when_invalid_option_combo; end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/options.rb#454
  def display_only_fail_level_offenses_with_autocorrect?; end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/options.rb#458
  def except_syntax?; end

  # @api private
  #
  # source://rubocop//lib/rubocop/options.rb#466
  def incompatible_options; end

  # @api private
  #
  # source://rubocop//lib/rubocop/options.rb#441
  def invalid_arguments_for_parallel; end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/options.rb#449
  def only_includes_redundant_disable?; end

  # @api private
  #
  # source://rubocop//lib/rubocop/options.rb#375
  def validate_auto_gen_config; end

  # @api private
  # @raise [OptionArgumentError]
  #
  # source://rubocop//lib/rubocop/options.rb#414
  def validate_autocorrect; end

  # @api private
  # @raise [OptionArgumentError]
  #
  # source://rubocop//lib/rubocop/options.rb#478
  def validate_cache_enabled_for_cache_root; end

  # @api private
  # @raise [OptionArgumentError]
  #
  # source://rubocop//lib/rubocop/options.rb#349
  def validate_compatibility; end

  # @api private
  #
  # source://rubocop//lib/rubocop/options.rb#344
  def validate_cop_options; end

  # @api private
  # @raise [OptionArgumentError]
  #
  # source://rubocop//lib/rubocop/options.rb#396
  def validate_display_only_correctable_and_autocorrect; end

  # @api private
  # @raise [OptionArgumentError]
  #
  # source://rubocop//lib/rubocop/options.rb#388
  def validate_display_only_failed; end

  # @api private
  # @raise [OptionArgumentError]
  #
  # source://rubocop//lib/rubocop/options.rb#405
  def validate_display_only_failed_and_display_only_correctable; end

  # @api private
  # @raise [OptionParser::MissingArgument]
  #
  # source://rubocop//lib/rubocop/options.rb#470
  def validate_exclude_limit_option; end

  class << self
    # Cop name validation must be done later than option parsing, so it's not
    # called from within Options.
    #
    # @api private
    #
    # source://rubocop//lib/rubocop/options.rb#309
    def validate_cop_list(names); end

    private

    # @api private
    #
    # source://rubocop//lib/rubocop/options.rb#326
    def format_message_from(name, cop_names); end
  end
end

# Common methods and behaviors for dealing with paths.
#
# source://rubocop//lib/rubocop/path_util.rb#5
module RuboCop::PathUtil
  private

  # Returns true for an absolute Unix or Windows path.
  #
  # source://rubocop//lib/rubocop/path_util.rb#72
  def absolute?(path); end

  # Returns true for a glob
  #
  # source://rubocop//lib/rubocop/path_util.rb#77
  def glob?(path); end

  # source://rubocop//lib/rubocop/path_util.rb#107
  def hidden_dir?(path); end

  # source://rubocop//lib/rubocop/path_util.rb#90
  def hidden_file?(path); end

  # source://rubocop//lib/rubocop/path_util.rb#81
  def hidden_file_in_not_hidden_dir?(pattern, path); end

  # source://rubocop//lib/rubocop/path_util.rb#48
  def match_path?(pattern, path); end

  # Loose check to reduce memory allocations
  #
  # source://rubocop//lib/rubocop/path_util.rb#97
  def maybe_hidden_file?(path); end

  # source://rubocop//lib/rubocop/path_util.rb#13
  def relative_path(path, base_dir = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/path_util.rb#34
  def smart_path(path); end

  class << self
    # Returns true for an absolute Unix or Windows path.
    #
    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/path_util.rb#72
    def absolute?(path); end

    # Returns true for a glob
    #
    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/path_util.rb#77
    def glob?(path); end

    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/path_util.rb#107
    def hidden_dir?(path); end

    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/path_util.rb#90
    def hidden_file?(path); end

    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/path_util.rb#81
    def hidden_file_in_not_hidden_dir?(pattern, path); end

    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/path_util.rb#48
    def match_path?(pattern, path); end

    # Loose check to reduce memory allocations
    #
    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/path_util.rb#97
    def maybe_hidden_file?(path); end

    # source://rubocop//lib/rubocop/path_util.rb#13
    def relative_path(path, base_dir = T.unsafe(nil)); end

    # Returns the value of attribute relative_paths_cache.
    #
    # source://rubocop//lib/rubocop/path_util.rb#7
    def relative_paths_cache; end

    # Sets the attribute relative_paths_cache
    #
    # @param value the value to set the attribute relative_paths_cache to.
    #
    # source://rubocop//lib/rubocop/path_util.rb#7
    def relative_paths_cache=(_arg0); end

    # source://rubocop//lib/rubocop/path_util.rb#34
    def smart_path(path); end
  end
end

# source://rubocop//lib/rubocop/path_util.rb#94
RuboCop::PathUtil::HIDDEN_FILE_PATTERN = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/path_util.rb#31
RuboCop::PathUtil::SMART_PATH_CACHE = T.let(T.unsafe(nil), Hash)

# This module provides information on the platform that RuboCop is being run
# on.
#
# source://rubocop//lib/rubocop/platform.rb#6
module RuboCop::Platform
  class << self
    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/platform.rb#7
    def windows?; end
  end
end

# source://rubocop//lib/rubocop/ast_aliases.rb#6
RuboCop::ProcessedSource = RuboCop::AST::ProcessedSource

# Common methods and behaviors for dealing with remote config files.
#
# @api private
#
# source://rubocop//lib/rubocop/remote_config.rb#9
class RuboCop::RemoteConfig
  # @api private
  # @return [RemoteConfig] a new instance of RemoteConfig
  #
  # source://rubocop//lib/rubocop/remote_config.rb#14
  def initialize(url, base_dir); end

  # @api private
  #
  # source://rubocop//lib/rubocop/remote_config.rb#19
  def file; end

  # @api private
  #
  # source://rubocop//lib/rubocop/remote_config.rb#32
  def inherit_from_remote(file, path); end

  # @api private
  #
  # source://rubocop//lib/rubocop/remote_config.rb#10
  def uri; end

  private

  # @api private
  #
  # source://rubocop//lib/rubocop/remote_config.rb#95
  def cache_name_from_uri; end

  # @api private
  #
  # source://rubocop//lib/rubocop/remote_config.rb#78
  def cache_path; end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/remote_config.rb#82
  def cache_path_exists?; end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/remote_config.rb#86
  def cache_path_expired?; end

  # @api private
  #
  # source://rubocop//lib/rubocop/remote_config.rb#101
  def cloned_url; end

  # @api private
  # @yield [request]
  #
  # source://rubocop//lib/rubocop/remote_config.rb#53
  def generate_request(uri); end

  # @api private
  #
  # source://rubocop//lib/rubocop/remote_config.rb#62
  def handle_response(response, limit, &block); end

  # @api private
  # @raise [ArgumentError]
  #
  # source://rubocop//lib/rubocop/remote_config.rb#40
  def request(uri = T.unsafe(nil), limit = T.unsafe(nil), &block); end
end

# @api private
#
# source://rubocop//lib/rubocop/remote_config.rb#12
RuboCop::RemoteConfig::CACHE_LIFETIME = T.let(T.unsafe(nil), Integer)

# Provides functionality for caching RuboCop runs.
#
# @api private
#
# source://rubocop//lib/rubocop/result_cache.rb#12
class RuboCop::ResultCache
  # @api private
  # @return [ResultCache] a new instance of ResultCache
  #
  # source://rubocop//lib/rubocop/result_cache.rb#88
  def initialize(file, team, options, config_store, cache_root = T.unsafe(nil)); end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/result_cache.rb#101
  def debug?; end

  # @api private
  #
  # source://rubocop//lib/rubocop/result_cache.rb#109
  def load; end

  # @api private
  #
  # source://rubocop//lib/rubocop/result_cache.rb#86
  def path; end

  # @api private
  #
  # source://rubocop//lib/rubocop/result_cache.rb#114
  def save(offenses); end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/result_cache.rb#105
  def valid?; end

  private

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/result_cache.rb#147
  def any_symlink?(path); end

  # We combine team and options into a single "context" checksum to avoid
  # making file names that are too long for some filesystems to handle.
  # This context is for anything that's not (1) the RuboCop executable
  # checksum or (2) the inspected file checksum.
  #
  # @api private
  #
  # source://rubocop//lib/rubocop/result_cache.rb#233
  def context_checksum(team, options); end

  # @api private
  #
  # source://rubocop//lib/rubocop/result_cache.rb#190
  def digest(path); end

  # @api private
  #
  # source://rubocop//lib/rubocop/result_cache.rb#158
  def file_checksum(file, config_store); end

  # Return a hash of the options given at invocation, minus the ones that have
  # no effect on which offenses and disabled line ranges are found, and thus
  # don't affect caching.
  #
  # @api private
  #
  # source://rubocop//lib/rubocop/result_cache.rb#217
  def relevant_options_digest(options); end

  # The checksum of the RuboCop program running the inspection.
  #
  # @api private
  #
  # source://rubocop//lib/rubocop/result_cache.rb#175
  def rubocop_checksum; end

  # @api private
  #
  # source://rubocop//lib/rubocop/result_cache.rb#201
  def rubocop_extra_features; end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/result_cache.rb#143
  def symlink_protection_triggered?(path); end

  # The external dependency checksums are cached per RuboCop team so that
  # the checksums don't need to be recomputed for each file.
  #
  # @api private
  #
  # source://rubocop//lib/rubocop/result_cache.rb#224
  def team_checksum(team); end

  class << self
    # @api private
    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/result_cache.rb#82
    def allow_symlinks_in_cache_location?(config_store); end

    # @api private
    #
    # source://rubocop//lib/rubocop/result_cache.rb#76
    def cache_root(config_store); end

    # Remove old files so that the cache doesn't grow too big. When the
    # threshold MaxFilesInCache has been exceeded, the oldest 50% of all the
    # files in the cache are removed. The reason for removing so much is that
    # cleaning should be done relatively seldom, since there is a slight risk
    # that some other RuboCop process was just about to read the file, when
    # there's parallel execution and the cache is shared.
    #
    # @api private
    #
    # source://rubocop//lib/rubocop/result_cache.rb#29
    def cleanup(config_store, verbose, cache_root = T.unsafe(nil)); end

    # @api private
    #
    # source://rubocop//lib/rubocop/result_cache.rb#171
    def inhibit_cleanup; end

    # @api private
    #
    # source://rubocop//lib/rubocop/result_cache.rb#171
    def inhibit_cleanup=(_arg0); end

    # @api private
    #
    # source://rubocop//lib/rubocop/result_cache.rb#43
    def rubocop_required_features; end

    # @api private
    #
    # source://rubocop//lib/rubocop/result_cache.rb#43
    def rubocop_required_features=(_arg0); end

    # @api private
    #
    # source://rubocop//lib/rubocop/result_cache.rb#171
    def source_checksum; end

    # @api private
    #
    # source://rubocop//lib/rubocop/result_cache.rb#171
    def source_checksum=(_arg0); end

    private

    # @api private
    #
    # source://rubocop//lib/rubocop/result_cache.rb#66
    def remove_files(files, dirs, remove_count); end

    # @api private
    #
    # source://rubocop//lib/rubocop/result_cache.rb#53
    def remove_oldest_files(files, dirs, cache_root, verbose); end

    # @api private
    # @return [Boolean]
    #
    # source://rubocop//lib/rubocop/result_cache.rb#49
    def requires_file_removal?(file_count, config_store); end
  end
end

# @api private
#
# source://rubocop//lib/rubocop/result_cache.rb#17
RuboCop::ResultCache::DL_EXTENSIONS = T.let(T.unsafe(nil), Array)

# @api private
#
# source://rubocop//lib/rubocop/result_cache.rb#13
RuboCop::ResultCache::NON_CHANGING = T.let(T.unsafe(nil), Array)

# This class handles the processing of files, which includes dealing with
# formatters and letting cops inspect the files.
#
# source://rubocop//lib/rubocop/runner.rb#8
class RuboCop::Runner
  # @return [Runner] a new instance of Runner
  #
  # source://rubocop//lib/rubocop/runner.rb#59
  def initialize(options, config_store); end

  # Sets the attribute aborting
  #
  # @param value the value to set the attribute aborting to.
  #
  # source://rubocop//lib/rubocop/runner.rb#57
  def aborting=(_arg0); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/runner.rb#83
  def aborting?; end

  # Returns the value of attribute errors.
  #
  # source://rubocop//lib/rubocop/runner.rb#56
  def errors; end

  # source://rubocop//lib/rubocop/runner.rb#67
  def run(paths); end

  # Returns the value of attribute warnings.
  #
  # source://rubocop//lib/rubocop/runner.rb#56
  def warnings; end

  private

  # source://rubocop//lib/rubocop/runner.rb#196
  def add_redundant_disables(file, offenses, source); end

  # source://rubocop//lib/rubocop/runner.rb#170
  def cached_result(file, team); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/runner.rb#250
  def cached_run?; end

  # Check whether a run created source identical to a previous run, which
  # means that we definitely have an infinite loop.
  #
  # source://rubocop//lib/rubocop/runner.rb#328
  def check_for_infinite_loop(processed_source, offenses_by_iteration); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/runner.rb#222
  def check_for_redundant_disables?(source); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/runner.rb#423
  def considered_failure?(offense); end

  # source://rubocop//lib/rubocop/runner.rb#456
  def default_config(cop_name); end

  # source://rubocop//lib/rubocop/runner.rb#272
  def do_inspection_loop(file); end

  # source://rubocop//lib/rubocop/runner.rb#133
  def each_inspected_file(files); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/runner.rb#236
  def except_redundant_cop_disable_directive?; end

  # source://rubocop//lib/rubocop/runner.rb#357
  def extract_ruby_sources(processed_source); end

  # source://rubocop//lib/rubocop/runner.rb#245
  def file_finished(file, offenses); end

  # source://rubocop//lib/rubocop/runner.rb#174
  def file_offense_cache(file); end

  # source://rubocop//lib/rubocop/runner.rb#162
  def file_offenses(file); end

  # source://rubocop//lib/rubocop/runner.rb#240
  def file_started(file); end

  # source://rubocop//lib/rubocop/runner.rb#403
  def filter_cop_classes(cop_classes, config); end

  # source://rubocop//lib/rubocop/runner.rb#104
  def find_target_files(paths); end

  # source://rubocop//lib/rubocop/runner.rb#414
  def formatter_set; end

  # source://rubocop//lib/rubocop/runner.rb#468
  def get_processed_source(file); end

  # source://rubocop//lib/rubocop/runner.rb#342
  def inspect_file(processed_source, team = T.unsafe(nil)); end

  # source://rubocop//lib/rubocop/runner.rb#115
  def inspect_files(files); end

  # source://rubocop//lib/rubocop/runner.rb#303
  def iterate_until_no_changes(source, offenses_by_iteration); end

  # source://rubocop//lib/rubocop/runner.rb#148
  def list_files(paths); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/runner.rb#452
  def mark_as_safe_by_config?(config); end

  # source://rubocop//lib/rubocop/runner.rb#460
  def minimum_severity_to_fail; end

  # source://rubocop//lib/rubocop/runner.rb#364
  def mobilize_team(processed_source); end

  # source://rubocop//lib/rubocop/runner.rb#369
  def mobilized_cop_classes(config); end

  # source://rubocop//lib/rubocop/runner.rb#432
  def offenses_to_report(offenses); end

  # source://rubocop//lib/rubocop/runner.rb#152
  def process_file(file); end

  # source://rubocop//lib/rubocop/runner.rb#393
  def qualify_option_cop_names; end

  # @yield [cop]
  #
  # source://rubocop//lib/rubocop/runner.rb#228
  def redundant_cop_disable_directive(file); end

  # source://rubocop//lib/rubocop/runner.rb#262
  def save_in_cache(cache, offenses); end

  # A Cop::Team instance is stateful and may change when inspecting.
  # The "standby" team for a given config is an initialized but
  # otherwise dormant team that can be used for config- and option-
  # level caching in ResultCache.
  #
  # source://rubocop//lib/rubocop/runner.rb#490
  def standby_team(config); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/runner.rb#410
  def style_guide_cops_only?(config); end

  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/runner.rb#444
  def supports_safe_autocorrect?(offense); end

  # @yield [team]
  #
  # source://rubocop//lib/rubocop/runner.rb#211
  def team_for_redundant_disables(file, offenses, source); end

  # Warms up the RuboCop cache by forking a suitable number of RuboCop
  # instances that each inspects its allotted group of files.
  #
  # source://rubocop//lib/rubocop/runner.rb#91
  def warm_cache(target_files); end

  class << self
    # @return [Array<#call>]
    #
    # source://rubocop//lib/rubocop/runner.rb#29
    def ruby_extractors; end

    private

    # @return [#call]
    #
    # source://rubocop//lib/rubocop/runner.rb#36
    def default_ruby_extractor; end
  end
end

# An exception indicating that the inspection loop got stuck correcting
# offenses back and forth.
#
# source://rubocop//lib/rubocop/runner.rb#11
class RuboCop::Runner::InfiniteCorrectionLoop < ::StandardError
  # @return [InfiniteCorrectionLoop] a new instance of InfiniteCorrectionLoop
  #
  # source://rubocop//lib/rubocop/runner.rb#14
  def initialize(path, offenses_by_iteration, loop_start: T.unsafe(nil)); end

  # Returns the value of attribute offenses.
  #
  # source://rubocop//lib/rubocop/runner.rb#12
  def offenses; end
end

# @api private
#
# source://rubocop//lib/rubocop/runner.rb#49
RuboCop::Runner::MAX_ITERATIONS = T.let(T.unsafe(nil), Integer)

# @api private
#
# source://rubocop//lib/rubocop/runner.rb#52
RuboCop::Runner::REDUNDANT_COP_DISABLE_DIRECTIVE_RULES = T.let(T.unsafe(nil), Array)

# Take a string with embedded escapes, and convert the escapes as the Ruby
# interpreter would when reading a double-quoted string literal.
# For example, "\\n" will be converted to "\n".
#
# source://rubocop//lib/rubocop/string_interpreter.rb#7
class RuboCop::StringInterpreter
  class << self
    # source://rubocop//lib/rubocop/string_interpreter.rb#24
    def interpret(string); end

    private

    # source://rubocop//lib/rubocop/string_interpreter.rb#51
    def interpret_hex(escape); end

    # source://rubocop//lib/rubocop/string_interpreter.rb#55
    def interpret_octal(escape); end

    # source://rubocop//lib/rubocop/string_interpreter.rb#33
    def interpret_string_escape(escape); end

    # source://rubocop//lib/rubocop/string_interpreter.rb#43
    def interpret_unicode(escape); end
  end
end

# source://rubocop//lib/rubocop/string_interpreter.rb#8
RuboCop::StringInterpreter::STRING_ESCAPES = T.let(T.unsafe(nil), Hash)

# source://rubocop//lib/rubocop/string_interpreter.rb#12
RuboCop::StringInterpreter::STRING_ESCAPE_REGEX = T.let(T.unsafe(nil), Regexp)

# This class finds target files to inspect by scanning the directory tree
# and picking ruby files.
#
# @api private
#
# source://rubocop//lib/rubocop/target_finder.rb#7
class RuboCop::TargetFinder
  # @api private
  # @return [TargetFinder] a new instance of TargetFinder
  #
  # source://rubocop//lib/rubocop/target_finder.rb#10
  def initialize(config_store, options = T.unsafe(nil)); end

  # @api private
  #
  # source://rubocop//lib/rubocop/target_finder.rb#145
  def all_cops_include; end

  # @api private
  #
  # source://rubocop//lib/rubocop/target_finder.rb#116
  def combined_exclude_glob_patterns(base_dir); end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/target_finder.rb#172
  def configured_include?(file); end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/target_finder.rb#19
  def debug?; end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/target_finder.rb#23
  def fail_fast?; end

  # Generate a list of target files by expanding globbing patterns
  # (if any). If args is empty, recursively find all Ruby source
  # files under the current directory
  #
  # @api private
  # @return [Array] array of file paths
  #
  # source://rubocop//lib/rubocop/target_finder.rb#31
  def find(args, mode); end

  # Search for files recursively starting at the given base directory using
  # the given flags that determine how the match is made. Excluded files will
  # be removed later by the caller, but as an optimization find_files removes
  # the top level directories that are excluded in configuration in the
  # normal way (dir/**/*).
  #
  # @api private
  #
  # source://rubocop//lib/rubocop/target_finder.rb#83
  def find_files(base_dir, flags); end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/target_finder.rb#15
  def force_exclusion?; end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/target_finder.rb#176
  def included_file?(file); end

  # @api private
  #
  # source://rubocop//lib/rubocop/target_finder.rb#180
  def process_explicit_path(path, mode); end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/target_finder.rb#149
  def ruby_executable?(file); end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/target_finder.rb#123
  def ruby_extension?(file); end

  # @api private
  #
  # source://rubocop//lib/rubocop/target_finder.rb#127
  def ruby_extensions; end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/target_finder.rb#168
  def ruby_file?(file); end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/target_finder.rb#134
  def ruby_filename?(file); end

  # @api private
  #
  # source://rubocop//lib/rubocop/target_finder.rb#138
  def ruby_filenames; end

  # @api private
  #
  # source://rubocop//lib/rubocop/target_finder.rb#160
  def ruby_interpreters(file); end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/target_finder.rb#164
  def stdin?; end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/target_finder.rb#108
  def symlink_excluded_or_infinite_loop?(base_dir, current_dir, exclude_pattern, flags); end

  # Finds all Ruby source files under the current or other supplied
  # directory. A Ruby source file is defined as a file with the `.rb`
  # extension or a file with no extension that has a ruby shebang line
  # as its first line.
  # It is possible to specify includes and excludes using the config file,
  # so you can include other Ruby files like Rakefiles and gemspecs.
  #
  # @api private
  # @param base_dir Root directory under which to search for
  #   ruby source files
  # @return [Array] Array of filenames
  #
  # source://rubocop//lib/rubocop/target_finder.rb#56
  def target_files_in_dir(base_dir = T.unsafe(nil)); end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/target_finder.rb#69
  def to_inspect?(file, hidden_files, base_dir_config); end

  # @api private
  #
  # source://rubocop//lib/rubocop/target_finder.rb#96
  def wanted_dir_patterns(base_dir, exclude_pattern, flags); end

  private

  # @api private
  #
  # source://rubocop//lib/rubocop/target_finder.rb#197
  def order; end
end

# @api private
#
# source://rubocop//lib/rubocop/target_finder.rb#8
RuboCop::TargetFinder::HIDDEN_PATH_SUBSTRING = T.let(T.unsafe(nil), String)

# The kind of Ruby that code inspected by RuboCop is written in.
#
# @api private
#
# source://rubocop//lib/rubocop/target_ruby.rb#6
class RuboCop::TargetRuby
  # @api private
  # @return [TargetRuby] a new instance of TargetRuby
  #
  # source://rubocop//lib/rubocop/target_ruby.rb#247
  def initialize(config); end

  # @api private
  #
  # source://rubocop//lib/rubocop/target_ruby.rb#263
  def rubocop_version_with_support; end

  # @api private
  #
  # source://rubocop//lib/rubocop/target_ruby.rb#251
  def source; end

  # @api private
  # @return [Boolean]
  #
  # source://rubocop//lib/rubocop/target_ruby.rb#259
  def supported?; end

  # @api private
  #
  # source://rubocop//lib/rubocop/target_ruby.rb#255
  def version; end

  class << self
    # @api private
    #
    # source://rubocop//lib/rubocop/target_ruby.rb#233
    def supported_versions; end
  end
end

# The lock file of Bundler may identify the target ruby version.
#
# @api private
#
# source://rubocop//lib/rubocop/target_ruby.rb#106
class RuboCop::TargetRuby::BundlerLockFile < ::RuboCop::TargetRuby::Source
  # @api private
  #
  # source://rubocop//lib/rubocop/target_ruby.rb#107
  def name; end

  private

  # @api private
  #
  # source://rubocop//lib/rubocop/target_ruby.rb#140
  def bundler_lock_file_path; end

  # @api private
  #
  # source://rubocop//lib/rubocop/target_ruby.rb#113
  def find_version; end
end

# @api private
#
# source://rubocop//lib/rubocop/target_ruby.rb#8
RuboCop::TargetRuby::DEFAULT_VERSION = T.let(T.unsafe(nil), Float)

# If all else fails, a default version will be picked.
#
# @api private
#
# source://rubocop//lib/rubocop/target_ruby.rb#221
class RuboCop::TargetRuby::Default < ::RuboCop::TargetRuby::Source
  # @api private
  #
  # source://rubocop//lib/rubocop/target_ruby.rb#222
  def name; end

  private

  # @api private
  #
  # source://rubocop//lib/rubocop/target_ruby.rb#228
  def find_version; end
end

# The target ruby version may be found in a .gemspec file.
#
# @api private
#
# source://rubocop//lib/rubocop/target_ruby.rb#147
class RuboCop::TargetRuby::GemspecFile < ::RuboCop::TargetRuby::Source
  extend ::RuboCop::AST::NodePattern::Macros

  # source://rubocop//lib/rubocop/target_ruby.rb#158
  def gem_requirement?(param0 = T.unsafe(nil)); end

  # @api private
  #
  # source://rubocop//lib/rubocop/target_ruby.rb#162
  def name; end

  # source://rubocop//lib/rubocop/target_ruby.rb#153
  def required_ruby_version(param0); end

  private

  # @api private
  #
  # source://rubocop//lib/rubocop/target_ruby.rb#209
  def find_default_minimal_known_ruby(right_hand_side); end

  # @api private
  #
  # source://rubocop//lib/rubocop/target_ruby.rb#168
  def find_version; end

  # @api private
  #
  # source://rubocop//lib/rubocop/target_ruby.rb#178
  def gemspec_filename; end

  # @api private
  #
  # source://rubocop//lib/rubocop/target_ruby.rb#185
  def gemspec_filepath; end

  # @api private
  #
  # source://rubocop//lib/rubocop/target_ruby.rb#205
  def version_from_array(array); end

  # @api private
  #
  # source://rubocop//lib/rubocop/target_ruby.rb#190
  def version_from_gemspec_file(file); end

  # @api private
  #
  # source://rubocop//lib/rubocop/target_ruby.rb#195
  def version_from_right_hand_side(right_hand_side); end
end

# @api private
#
# source://rubocop//lib/rubocop/target_ruby.rb#150
RuboCop::TargetRuby::GemspecFile::GEMSPEC_EXTENSION = T.let(T.unsafe(nil), String)

# @api private
#
# source://rubocop//lib/rubocop/target_ruby.rb#7
RuboCop::TargetRuby::KNOWN_RUBIES = T.let(T.unsafe(nil), Array)

# @api private
#
# source://rubocop//lib/rubocop/target_ruby.rb#10
RuboCop::TargetRuby::OBSOLETE_RUBIES = T.let(T.unsafe(nil), Hash)

# The target ruby version may be configured in RuboCop's config.
#
# @api private
#
# source://rubocop//lib/rubocop/target_ruby.rb#38
class RuboCop::TargetRuby::RuboCopConfig < ::RuboCop::TargetRuby::Source
  # @api private
  #
  # source://rubocop//lib/rubocop/target_ruby.rb#39
  def name; end

  private

  # @api private
  #
  # source://rubocop//lib/rubocop/target_ruby.rb#45
  def find_version; end
end

# The target ruby version may be found in a .ruby-version file.
#
# @api private
#
# source://rubocop//lib/rubocop/target_ruby.rb#52
class RuboCop::TargetRuby::RubyVersionFile < ::RuboCop::TargetRuby::Source
  # @api private
  #
  # source://rubocop//lib/rubocop/target_ruby.rb#56
  def name; end

  private

  # @api private
  #
  # source://rubocop//lib/rubocop/target_ruby.rb#62
  def filename; end

  # @api private
  #
  # source://rubocop//lib/rubocop/target_ruby.rb#70
  def find_version; end

  # @api private
  #
  # source://rubocop//lib/rubocop/target_ruby.rb#66
  def pattern; end

  # @api private
  #
  # source://rubocop//lib/rubocop/target_ruby.rb#77
  def version_file; end
end

# @api private
#
# source://rubocop//lib/rubocop/target_ruby.rb#53
RuboCop::TargetRuby::RubyVersionFile::RUBY_VERSION_FILENAME = T.let(T.unsafe(nil), String)

# @api private
#
# source://rubocop//lib/rubocop/target_ruby.rb#54
RuboCop::TargetRuby::RubyVersionFile::RUBY_VERSION_PATTERN = T.let(T.unsafe(nil), Regexp)

# @api private
#
# source://rubocop//lib/rubocop/target_ruby.rb#237
RuboCop::TargetRuby::SOURCES = T.let(T.unsafe(nil), Array)

# A place where information about a target ruby version is found.
#
# @api private
#
# source://rubocop//lib/rubocop/target_ruby.rb#23
class RuboCop::TargetRuby::Source
  # @api private
  # @return [Source] a new instance of Source
  #
  # source://rubocop//lib/rubocop/target_ruby.rb#26
  def initialize(config); end

  # @api private
  #
  # source://rubocop//lib/rubocop/target_ruby.rb#24
  def name; end

  # @api private
  #
  # source://rubocop//lib/rubocop/target_ruby.rb#31
  def to_s; end

  # @api private
  #
  # source://rubocop//lib/rubocop/target_ruby.rb#24
  def version; end
end

# The target ruby version may be found in a .tool-versions file, in a line
# starting with `ruby`.
#
# @api private
#
# source://rubocop//lib/rubocop/target_ruby.rb#85
class RuboCop::TargetRuby::ToolVersionsFile < ::RuboCop::TargetRuby::RubyVersionFile
  # @api private
  #
  # source://rubocop//lib/rubocop/target_ruby.rb#89
  def name; end

  private

  # @api private
  #
  # source://rubocop//lib/rubocop/target_ruby.rb#95
  def filename; end

  # @api private
  #
  # source://rubocop//lib/rubocop/target_ruby.rb#99
  def pattern; end
end

# @api private
#
# source://rubocop//lib/rubocop/target_ruby.rb#86
RuboCop::TargetRuby::ToolVersionsFile::TOOL_VERSIONS_FILENAME = T.let(T.unsafe(nil), String)

# @api private
#
# source://rubocop//lib/rubocop/target_ruby.rb#87
RuboCop::TargetRuby::ToolVersionsFile::TOOL_VERSIONS_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://rubocop//lib/rubocop/ast_aliases.rb#7
RuboCop::Token = RuboCop::AST::Token

# This module contains a collection of useful utility methods.
#
# source://rubocop//lib/rubocop/util.rb#5
module RuboCop::Util
  class << self
    # source://rubocop//lib/rubocop/util.rb#6
    def silence_warnings; end
  end
end

# source://rubocop//lib/rubocop/error.rb#10
class RuboCop::ValidationError < ::RuboCop::Error; end

# This module holds the RuboCop version information.
#
# source://rubocop//lib/rubocop/version.rb#5
module RuboCop::Version
  class << self
    # @api private
    #
    # source://rubocop//lib/rubocop/version.rb#89
    def document_version; end

    # @api private
    #
    # source://rubocop//lib/rubocop/version.rb#39
    def extension_versions(env); end

    # Returns feature version in one of two ways:
    #
    # * Find by RuboCop core version style (e.g. rubocop-performance, rubocop-rspec)
    # * Find by `bundle gem` version style (e.g. rubocop-rake)
    #
    # @api private
    #
    # source://rubocop//lib/rubocop/version.rb#73
    def feature_version(feature); end

    # @api private
    #
    # source://rubocop//lib/rubocop/version.rb#94
    def server_mode; end

    # @api private
    #
    # source://rubocop//lib/rubocop/version.rb#17
    def version(debug: T.unsafe(nil), env: T.unsafe(nil)); end
  end
end

# source://rubocop//lib/rubocop/version.rb#12
RuboCop::Version::CANONICAL_FEATURE_NAMES = T.let(T.unsafe(nil), Hash)

# source://rubocop//lib/rubocop/version.rb#14
RuboCop::Version::EXTENSION_PATH_NAMES = T.let(T.unsafe(nil), Hash)

# source://rubocop//lib/rubocop/version.rb#8
RuboCop::Version::MSG = T.let(T.unsafe(nil), String)

# source://rubocop//lib/rubocop/version.rb#6
RuboCop::Version::STRING = T.let(T.unsafe(nil), String)

# A Warning exception is different from an Offense with severity 'warning'
# When a Warning is raised, this means that RuboCop was unable to perform a
# requested operation (such as inspecting or correcting a source file) due to
# user error
# For example, a configuration value in .rubocop.yml might be malformed
#
# source://rubocop//lib/rubocop/warning.rb#9
class RuboCop::Warning < ::StandardError; end

# Find duplicated keys from YAML.
#
# @api private
#
# source://rubocop//lib/rubocop/yaml_duplication_checker.rb#6
module RuboCop::YAMLDuplicationChecker
  class << self
    # @api private
    #
    # source://rubocop//lib/rubocop/yaml_duplication_checker.rb#7
    def check(yaml_string, filename, &on_duplicated); end

    private

    # @api private
    #
    # source://rubocop//lib/rubocop/yaml_duplication_checker.rb#21
    def traverse(tree, &on_duplicated); end
  end
end

# Extensions to the core String class
#
# source://rubocop//lib/rubocop/core_ext/string.rb#4
class String
  include ::Comparable

  # Checks whether a string is blank. A string is considered blank if it
  # is either empty or contains only whitespace characters.
  #
  # @example
  #   ''.blank? #=> true
  # @example
  #   '    '.blank? #=> true
  # @example
  #   '  test'.blank? #=> false
  # @return [Boolean] true is the string is blank, false otherwise
  #
  # source://rubocop//lib/rubocop/core_ext/string.rb#19
  def blank?; end
end
